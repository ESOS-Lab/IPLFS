!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOC_LEFT	segment.h	/^	ALLOC_LEFT$/;"	e	enum:__anon6
ALLOC_MODE_DEFAULT	f2fs.h	/^	ALLOC_MODE_DEFAULT,	\/* stay default *\/$/;"	e	enum:__anon33
ALLOC_MODE_REUSE	f2fs.h	/^	ALLOC_MODE_REUSE,	\/* reuse segments as much as possible *\/$/;"	e	enum:__anon33
ALLOC_NEXT	segment.h	/^	ALLOC_NEXT,$/;"	e	enum:__anon8
ALLOC_NODE	f2fs.h	/^	ALLOC_NODE,			\/* allocate a new node page if needed *\/$/;"	e	enum:__anon20
ALLOC_RIGHT	segment.h	/^	ALLOC_RIGHT = 0,$/;"	e	enum:__anon6
APPEND_INO	f2fs.h	/^	APPEND_INO,		\/* for append ino list *\/$/;"	e	enum:__anon15
APP_BUFFERED_IO	f2fs.h	/^	APP_BUFFERED_IO,		\/* app buffered write IOs *\/$/;"	e	enum:iostat_type
APP_BUFFERED_READ_IO	f2fs.h	/^	APP_BUFFERED_READ_IO,		\/* app buffered read IOs *\/$/;"	e	enum:iostat_type
APP_DIRECT_IO	f2fs.h	/^	APP_DIRECT_IO,			\/* app direct write IOs *\/$/;"	e	enum:iostat_type
APP_DIRECT_READ_IO	f2fs.h	/^	APP_DIRECT_READ_IO,		\/* app direct read IOs *\/$/;"	e	enum:iostat_type
APP_MAPPED_IO	f2fs.h	/^	APP_MAPPED_IO,			\/* app mapped IOs *\/$/;"	e	enum:iostat_type
APP_MAPPED_READ_IO	f2fs.h	/^	APP_MAPPED_READ_IO,		\/* app mapped read IOs *\/$/;"	e	enum:iostat_type
APP_READ_IO	f2fs.h	/^	APP_READ_IO,			\/* app read IOs *\/$/;"	e	enum:iostat_type
APP_WRITE_IO	f2fs.h	/^	APP_WRITE_IO,			\/* app write IOs *\/$/;"	e	enum:iostat_type
ATOMIC_FILE	f2fs.h	/^	ATOMIC_FILE,			\/* for all atomic files *\/$/;"	e	enum:inode_type
ATOMIC_WRITTEN_PAGE	f2fs.h	1350;"	d
ATTR_LIST	sysfs.c	613;"	d	file:
AT_SSR	segment.h	/^	AT_SSR,$/;"	e	enum:__anon7
BASE_CHECK	node.h	/^	BASE_CHECK,	\/* check kernel status *\/$/;"	e	enum:mem_type
BGGC_MODE_OFF	f2fs.h	/^	BGGC_MODE_OFF,		\/* background gc is off *\/$/;"	e	enum:__anon30
BGGC_MODE_ON	f2fs.h	/^	BGGC_MODE_ON,		\/* background gc is on *\/$/;"	e	enum:__anon30
BGGC_MODE_SYNC	f2fs.h	/^	BGGC_MODE_SYNC,		\/*$/;"	e	enum:__anon30
BG_GC	segment.h	/^	BG_GC = 0,$/;"	e	enum:__anon9
BLKS_PER_SEC	segment.h	113;"	d
COLD	f2fs.h	/^	COLD,$/;"	e	enum:temp_type
COMPRESS_CHKSUM	f2fs.h	/^	COMPRESS_CHKSUM,$/;"	e	enum:compress_flag
COMPRESS_DATA_RESERVED_SIZE	f2fs.h	1380;"	d
COMPRESS_EXT_NUM	f2fs.h	116;"	d
COMPRESS_HEADER_SIZE	f2fs.h	1388;"	d
COMPRESS_LZ4	f2fs.h	/^	COMPRESS_LZ4,$/;"	e	enum:compress_algorithm_type
COMPRESS_LZO	f2fs.h	/^	COMPRESS_LZO,$/;"	e	enum:compress_algorithm_type
COMPRESS_LZORLE	f2fs.h	/^	COMPRESS_LZORLE,$/;"	e	enum:compress_algorithm_type
COMPRESS_MAX	f2fs.h	/^	COMPRESS_MAX,$/;"	e	enum:compress_algorithm_type
COMPRESS_MAX_FLAG	f2fs.h	/^	COMPRESS_MAX_FLAG,$/;"	e	enum:compress_flag
COMPRESS_ZSTD	f2fs.h	/^	COMPRESS_ZSTD,$/;"	e	enum:compress_algorithm_type
COMPR_MODE_FS	f2fs.h	/^	COMPR_MODE_FS,		\/*$/;"	e	enum:__anon34
COMPR_MODE_USER	f2fs.h	/^	COMPR_MODE_USER,	\/*$/;"	e	enum:__anon34
CP_COMPRESSED	f2fs.h	/^	CP_COMPRESSED,$/;"	e	enum:cp_reason_type
CP_DISCARD	f2fs.h	196;"	d
CP_FASTBOOT	f2fs.h	193;"	d
CP_FASTBOOT_MODE	f2fs.h	/^	CP_FASTBOOT_MODE,$/;"	e	enum:cp_reason_type
CP_HARDLINK	f2fs.h	/^	CP_HARDLINK,$/;"	e	enum:cp_reason_type
CP_NODE_NEED_CP	f2fs.h	/^	CP_NODE_NEED_CP,$/;"	e	enum:cp_reason_type
CP_NON_REGULAR	f2fs.h	/^	CP_NON_REGULAR,$/;"	e	enum:cp_reason_type
CP_NO_NEEDED	f2fs.h	/^	CP_NO_NEEDED,$/;"	e	enum:cp_reason_type
CP_NO_SPC_ROLL	f2fs.h	/^	CP_NO_SPC_ROLL,$/;"	e	enum:cp_reason_type
CP_PAUSE	f2fs.h	198;"	d
CP_RECOVERY	f2fs.h	195;"	d
CP_RECOVER_DIR	f2fs.h	/^	CP_RECOVER_DIR,$/;"	e	enum:cp_reason_type
CP_RESIZE	f2fs.h	199;"	d
CP_SB_NEED_CP	f2fs.h	/^	CP_SB_NEED_CP,$/;"	e	enum:cp_reason_type
CP_SPEC_LOG_NUM	f2fs.h	/^	CP_SPEC_LOG_NUM,$/;"	e	enum:cp_reason_type
CP_SYNC	f2fs.h	194;"	d
CP_TIME	f2fs.h	/^	CP_TIME,$/;"	e	enum:__anon28
CP_TRIMMED	f2fs.h	197;"	d
CP_UMOUNT	f2fs.h	192;"	d
CP_WRONG_PINO	f2fs.h	/^	CP_WRONG_PINO,$/;"	e	enum:cp_reason_type
CREATE_TRACE_POINTS	super.c	36;"	d	file:
CURSEG_ALL_DATA_ATGC	f2fs.h	/^	CURSEG_ALL_DATA_ATGC,	\/* SSR alloctor in hot\/warm\/cold data area *\/$/;"	e	enum:__anon26
CURSEG_COLD_DATA	f2fs.h	/^	CURSEG_COLD_DATA,	\/* multimedia or GCed data blocks *\/$/;"	e	enum:__anon26
CURSEG_COLD_DATA_PINNED	f2fs.h	/^	CURSEG_COLD_DATA_PINNED = NR_PERSISTENT_LOG,$/;"	e	enum:__anon26
CURSEG_COLD_NODE	f2fs.h	/^	CURSEG_COLD_NODE,	\/* indirect node blocks *\/$/;"	e	enum:__anon26
CURSEG_HOT_DATA	f2fs.h	/^	CURSEG_HOT_DATA	= 0,	\/* directory entry blocks *\/$/;"	e	enum:__anon26
CURSEG_HOT_NODE	f2fs.h	/^	CURSEG_HOT_NODE,	\/* direct node blocks of directory files *\/$/;"	e	enum:__anon26
CURSEG_I	segment.h	/^static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)$/;"	f
CURSEG_WARM_DATA	f2fs.h	/^	CURSEG_WARM_DATA,	\/* data blocks *\/$/;"	e	enum:__anon26
CURSEG_WARM_NODE	f2fs.h	/^	CURSEG_WARM_NODE,	\/* direct node blocks of normal files *\/$/;"	e	enum:__anon26
DATA	f2fs.h	/^	DATA,$/;"	e	enum:page_type
DATA_GENERIC	f2fs.h	/^	DATA_GENERIC,		\/* check range only *\/$/;"	e	enum:__anon14
DATA_GENERIC_ENHANCE	f2fs.h	/^	DATA_GENERIC_ENHANCE,	\/* strong check on range and segment bitmap *\/$/;"	e	enum:__anon14
DATA_GENERIC_ENHANCE_READ	f2fs.h	/^	DATA_GENERIC_ENHANCE_READ,	\/*$/;"	e	enum:__anon14
DCC_INFO	sysfs.c	/^	DCC_INFO,	\/* struct discard_cmd_control *\/$/;"	e	enum:__anon5	file:
DEFAULT_ACCURACY_CLASS	gc.h	23;"	d
DEFAULT_DISCARD_GRANULARITY	f2fs.h	281;"	d
DEFAULT_IOSTAT_PERIOD_MS	f2fs.h	3132;"	d
DEFAULT_IO_TIMEOUT	f2fs.h	526;"	d
DEFAULT_RETRY_IO_COUNT	f2fs.h	523;"	d
DEFAULT_RETRY_QUOTA_FLUSH_COUNT	f2fs.h	529;"	d
DEF_CP_INTERVAL	f2fs.h	209;"	d
DEF_DIRTY_NAT_RATIO_THRESHOLD	node.h	30;"	d
DEF_DIR_LEVEL	f2fs.h	711;"	d
DEF_DISABLE_INTERVAL	f2fs.h	211;"	d
DEF_DISABLE_QUICK_INTERVAL	f2fs.h	212;"	d
DEF_DISCARD_URGENT_UTIL	f2fs.h	208;"	d
DEF_GC_FAILED_PINNED_FILES	gc.h	28;"	d
DEF_GC_THREAD_AGE_THRESHOLD	gc.h	19;"	d
DEF_GC_THREAD_AGE_WEIGHT	gc.h	22;"	d
DEF_GC_THREAD_CANDIDATE_RATIO	gc.h	20;"	d
DEF_GC_THREAD_MAX_CANDIDATE_COUNT	gc.h	21;"	d
DEF_GC_THREAD_MAX_SLEEP_TIME	gc.h	15;"	d
DEF_GC_THREAD_MIN_SLEEP_TIME	gc.h	14;"	d
DEF_GC_THREAD_NOGC_SLEEP_TIME	gc.h	16;"	d
DEF_GC_THREAD_URGENT_SLEEP_TIME	gc.h	13;"	d
DEF_IDLE_INTERVAL	f2fs.h	210;"	d
DEF_INLINE_RESERVED_SIZE	f2fs.h	410;"	d
DEF_MAX_DISCARD_ISSUE_TIME	f2fs.h	207;"	d
DEF_MAX_DISCARD_REQUEST	f2fs.h	202;"	d
DEF_MAX_RECLAIM_PREFREE_SEGMENTS	segment.h	16;"	d
DEF_MAX_VICTIM_SEARCH	gc.h	31;"	d
DEF_MID_DISCARD_ISSUE_TIME	f2fs.h	206;"	d
DEF_MIN_DISCARD_ISSUE_TIME	f2fs.h	204;"	d
DEF_MIN_FSYNC_BLOCKS	segment.h	715;"	d
DEF_MIN_HOT_BLOCKS	segment.h	716;"	d
DEF_MIN_IPU_UTIL	segment.h	714;"	d
DEF_NAT_CACHE_THRESHOLD	node.h	32;"	d
DEF_RAM_THRESHOLD	node.h	27;"	d
DEF_RA_NID_PAGES	node.h	21;"	d
DEF_RECLAIM_PREFREE_SEGMENTS	segment.h	15;"	d
DEF_UMOUNT_DISCARD_TIMEOUT	f2fs.h	213;"	d
DELTA	hash.c	23;"	d	file:
DIRTY	segment.h	/^	DIRTY,			\/* to count # of dirty segments *\/$/;"	e	enum:dirty_type
DIRTY_COLD_DATA	segment.h	/^	DIRTY_COLD_DATA,	\/* dirty segments assigned as cold data logs *\/$/;"	e	enum:dirty_type
DIRTY_COLD_NODE	segment.h	/^	DIRTY_COLD_NODE,	\/* dirty segments assigned as cold node logs *\/$/;"	e	enum:dirty_type
DIRTY_DENTS	node.h	/^	DIRTY_DENTS,	\/* indicates dirty dentry pages *\/$/;"	e	enum:mem_type
DIRTY_HOT_DATA	segment.h	/^	DIRTY_HOT_DATA,		\/* dirty segments assigned as hot data logs *\/$/;"	e	enum:dirty_type
DIRTY_HOT_NODE	segment.h	/^	DIRTY_HOT_NODE,		\/* dirty segments assigned as hot node logs *\/$/;"	e	enum:dirty_type
DIRTY_I	f2fs.h	/^static inline struct dirty_seglist_info *DIRTY_I(struct f2fs_sb_info *sbi)$/;"	f
DIRTY_META	f2fs.h	/^	DIRTY_META,			\/* for all dirtied inode metadata *\/$/;"	e	enum:inode_type
DIRTY_NAT	f2fs.h	/^	DIRTY_NAT,$/;"	e	enum:nat_state
DIRTY_WARM_DATA	segment.h	/^	DIRTY_WARM_DATA,	\/* dirty segments assigned as warm data logs *\/$/;"	e	enum:dirty_type
DIRTY_WARM_NODE	segment.h	/^	DIRTY_WARM_NODE,	\/* dirty segments assigned as warm node logs *\/$/;"	e	enum:dirty_type
DIR_INODE	f2fs.h	/^	DIR_INODE,			\/* for dirty dir inode *\/$/;"	e	enum:inode_type
DISABLE_TIME	f2fs.h	/^	DISABLE_TIME,$/;"	e	enum:__anon28
DISCARD_TIME	f2fs.h	/^	DISCARD_TIME,$/;"	e	enum:__anon28
DPOLICY_BG	f2fs.h	/^	DPOLICY_BG,$/;"	e	enum:__anon19
DPOLICY_FORCE	f2fs.h	/^	DPOLICY_FORCE,$/;"	e	enum:__anon19
DPOLICY_FSTRIM	f2fs.h	/^	DPOLICY_FSTRIM,$/;"	e	enum:__anon19
DPOLICY_UMOUNT	f2fs.h	/^	DPOLICY_UMOUNT,$/;"	e	enum:__anon19
DUMMY_WRITTEN_PAGE	f2fs.h	1351;"	d
D_DONE	f2fs.h	/^	D_DONE,			\/* finished *\/$/;"	e	enum:__anon16
D_PARTIAL	f2fs.h	/^	D_PARTIAL,		\/* partially submitted *\/$/;"	e	enum:__anon16
D_PREP	f2fs.h	/^	D_PREP,			\/* initial *\/$/;"	e	enum:__anon16
D_SUBMIT	f2fs.h	/^	D_SUBMIT,		\/* all submitted *\/$/;"	e	enum:__anon16
EFSBADCRC	f2fs.h	4234;"	d
EFSCORRUPTED	f2fs.h	4235;"	d
ENTRY_SIZE	xattr.h	62;"	d
EXTENT_CACHE	node.h	/^	EXTENT_CACHE,	\/* indicates extent cache *\/$/;"	e	enum:mem_type
EXTENT_CACHE_SHRINK_NUMBER	f2fs.h	539;"	d
F2FS_ACL_VERSION	acl.h	17;"	d
F2FS_ALL_FAULT_TYPE	f2fs.h	61;"	d
F2FS_APPEND_FL	f2fs.h	2659;"	d
F2FS_ATTR_OFFSET	sysfs.c	495;"	d	file:
F2FS_BIO_POOL_SIZE	data.c	38;"	d	file:
F2FS_CASEFOLD_FL	f2fs.h	2666;"	d
F2FS_CKPT	f2fs.h	/^static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)$/;"	f
F2FS_CLEAR_FEATURE	f2fs.h	175;"	d
F2FS_COMPRESSED_PAGE_MAGIC	f2fs.h	1390;"	d
F2FS_COMPR_FL	f2fs.h	2656;"	d
F2FS_DEF_RESGID	f2fs.h	182;"	d
F2FS_DEF_RESUID	f2fs.h	181;"	d
F2FS_DIO_READ	f2fs.h	/^	F2FS_DIO_READ,$/;"	e	enum:count_type
F2FS_DIO_WRITE	f2fs.h	/^	F2FS_DIO_WRITE,$/;"	e	enum:count_type
F2FS_DIRSYNC_FL	f2fs.h	2664;"	d
F2FS_DIRTY_DATA	f2fs.h	/^	F2FS_DIRTY_DATA,$/;"	e	enum:count_type
F2FS_DIRTY_DENTS	f2fs.h	/^	F2FS_DIRTY_DENTS,$/;"	e	enum:count_type
F2FS_DIRTY_IMETA	f2fs.h	/^	F2FS_DIRTY_IMETA,$/;"	e	enum:count_type
F2FS_DIRTY_META	f2fs.h	/^	F2FS_DIRTY_META,$/;"	e	enum:count_type
F2FS_DIRTY_NODES	f2fs.h	/^	F2FS_DIRTY_NODES,$/;"	e	enum:count_type
F2FS_DIRTY_QDATA	f2fs.h	/^	F2FS_DIRTY_QDATA,$/;"	e	enum:count_type
F2FS_FEATURE_ATOMIC_WRITE	f2fs.h	157;"	d
F2FS_FEATURE_BLKZONED	f2fs.h	156;"	d
F2FS_FEATURE_CASEFOLD	f2fs.h	167;"	d
F2FS_FEATURE_COMPRESSION	f2fs.h	168;"	d
F2FS_FEATURE_ENCRYPT	f2fs.h	155;"	d
F2FS_FEATURE_EXTRA_ATTR	f2fs.h	158;"	d
F2FS_FEATURE_FLEXIBLE_INLINE_XATTR	f2fs.h	161;"	d
F2FS_FEATURE_FUNCS	f2fs.h	4057;"	d
F2FS_FEATURE_INODE_CHKSUM	f2fs.h	160;"	d
F2FS_FEATURE_INODE_CRTIME	f2fs.h	163;"	d
F2FS_FEATURE_LOST_FOUND	f2fs.h	164;"	d
F2FS_FEATURE_PRJQUOTA	f2fs.h	159;"	d
F2FS_FEATURE_QUOTA_INO	f2fs.h	162;"	d
F2FS_FEATURE_RO_ATTR	sysfs.c	512;"	d	file:
F2FS_FEATURE_SB_CHKSUM	f2fs.h	166;"	d
F2FS_FEATURE_VERITY	f2fs.h	165;"	d
F2FS_FITS_IN_INODE	f2fs.h	3127;"	d
F2FS_FL_INHERITED	f2fs.h	2669;"	d
F2FS_GENERAL_RO_ATTR	sysfs.c	509;"	d	file:
F2FS_GETTABLE_FS_FL	file.c	1888;"	d	file:
F2FS_GET_BLOCK_BMAP	f2fs.h	/^	F2FS_GET_BLOCK_BMAP,$/;"	e	enum:__anon23
F2FS_GET_BLOCK_DEFAULT	f2fs.h	/^	F2FS_GET_BLOCK_DEFAULT,$/;"	e	enum:__anon23
F2FS_GET_BLOCK_DIO	f2fs.h	/^	F2FS_GET_BLOCK_DIO,$/;"	e	enum:__anon23
F2FS_GET_BLOCK_FIEMAP	f2fs.h	/^	F2FS_GET_BLOCK_FIEMAP,$/;"	e	enum:__anon23
F2FS_GET_BLOCK_PRECACHE	f2fs.h	/^	F2FS_GET_BLOCK_PRECACHE,$/;"	e	enum:__anon23
F2FS_GET_BLOCK_PRE_AIO	f2fs.h	/^	F2FS_GET_BLOCK_PRE_AIO,$/;"	e	enum:__anon23
F2FS_GET_BLOCK_PRE_DIO	f2fs.h	/^	F2FS_GET_BLOCK_PRE_DIO,$/;"	e	enum:__anon23
F2FS_HAS_BLOCKS	f2fs.h	/^static inline int F2FS_HAS_BLOCKS(struct inode *inode)$/;"	f
F2FS_HAS_FEATURE	f2fs.h	172;"	d
F2FS_I	f2fs.h	/^static inline struct f2fs_inode_info *F2FS_I(struct inode *inode)$/;"	f
F2FS_IMMUTABLE_FL	f2fs.h	2658;"	d
F2FS_INDEX_FL	f2fs.h	2663;"	d
F2FS_INMEM_PAGES	f2fs.h	/^	F2FS_INMEM_PAGES,$/;"	e	enum:count_type
F2FS_INODE	f2fs.h	/^static inline struct f2fs_inode *F2FS_INODE(struct page *page)$/;"	f
F2FS_IOC32_GARBAGE_COLLECT_RANGE	file.c	4446;"	d	file:
F2FS_IOC32_MOVE_RANGE	file.c	4471;"	d	file:
F2FS_IPU_ASYNC	segment.h	/^	F2FS_IPU_ASYNC,$/;"	e	enum:__anon10
F2FS_IPU_FORCE	segment.h	/^	F2FS_IPU_FORCE,$/;"	e	enum:__anon10
F2FS_IPU_FSYNC	segment.h	/^	F2FS_IPU_FSYNC,$/;"	e	enum:__anon10
F2FS_IPU_NOCACHE	segment.h	/^	F2FS_IPU_NOCACHE,$/;"	e	enum:__anon10
F2FS_IPU_SSR	segment.h	/^	F2FS_IPU_SSR,$/;"	e	enum:__anon10
F2FS_IPU_SSR_UTIL	segment.h	/^	F2FS_IPU_SSR_UTIL,$/;"	e	enum:__anon10
F2FS_IPU_UTIL	segment.h	/^	F2FS_IPU_UTIL,$/;"	e	enum:__anon10
F2FS_I_SB	f2fs.h	/^static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)$/;"	f
F2FS_LINK_MAX	f2fs.h	531;"	d
F2FS_MAP_FLAGS	f2fs.h	654;"	d
F2FS_MAP_MAPPED	f2fs.h	652;"	d
F2FS_MAP_NEW	f2fs.h	651;"	d
F2FS_MAP_UNWRITTEN	f2fs.h	653;"	d
F2FS_MIN_EXTENT_LEN	f2fs.h	536;"	d
F2FS_MIN_META_SEGMENTS	segment.h	19;"	d
F2FS_MIN_SEGMENTS	segment.h	18;"	d
F2FS_MOUNT_ATGC	f2fs.h	99;"	d
F2FS_MOUNT_DATA_FLUSH	f2fs.h	89;"	d
F2FS_MOUNT_DISABLE_CHECKPOINT	f2fs.h	97;"	d
F2FS_MOUNT_DISABLE_EXT_IDENTIFY	f2fs.h	81;"	d
F2FS_MOUNT_DISABLE_ROLL_FORWARD	f2fs.h	76;"	d
F2FS_MOUNT_DISCARD	f2fs.h	77;"	d
F2FS_MOUNT_EXTENT_CACHE	f2fs.h	88;"	d
F2FS_MOUNT_FASTBOOT	f2fs.h	87;"	d
F2FS_MOUNT_FAULT_INJECTION	f2fs.h	90;"	d
F2FS_MOUNT_FLUSH_MERGE	f2fs.h	85;"	d
F2FS_MOUNT_GRPQUOTA	f2fs.h	92;"	d
F2FS_MOUNT_INLINE_DATA	f2fs.h	83;"	d
F2FS_MOUNT_INLINE_DENTRY	f2fs.h	84;"	d
F2FS_MOUNT_INLINE_XATTR	f2fs.h	82;"	d
F2FS_MOUNT_INLINE_XATTR_SIZE	f2fs.h	95;"	d
F2FS_MOUNT_NOBARRIER	f2fs.h	86;"	d
F2FS_MOUNT_NOHEAP	f2fs.h	78;"	d
F2FS_MOUNT_NORECOVERY	f2fs.h	98;"	d
F2FS_MOUNT_POSIX_ACL	f2fs.h	80;"	d
F2FS_MOUNT_PRJQUOTA	f2fs.h	93;"	d
F2FS_MOUNT_QUOTA	f2fs.h	94;"	d
F2FS_MOUNT_RESERVE_ROOT	f2fs.h	96;"	d
F2FS_MOUNT_USRQUOTA	f2fs.h	91;"	d
F2FS_MOUNT_XATTR_USER	f2fs.h	79;"	d
F2FS_M_SB	f2fs.h	/^static inline struct f2fs_sb_info *F2FS_M_SB(struct address_space *mapping)$/;"	f
F2FS_NOATIME_FL	f2fs.h	2661;"	d
F2FS_NOCOMP_FL	f2fs.h	2662;"	d
F2FS_NODE	f2fs.h	/^static inline struct f2fs_node *F2FS_NODE(struct page *page)$/;"	f
F2FS_NODUMP_FL	f2fs.h	2660;"	d
F2FS_OLD_ATTRIBUTE_SIZE	f2fs.h	3126;"	d
F2FS_OPTION	f2fs.h	101;"	d
F2FS_OTHER_FLMASK	f2fs.h	2678;"	d
F2FS_PROJINHERIT_FL	f2fs.h	2665;"	d
F2FS_P_SB	f2fs.h	/^static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)$/;"	f
F2FS_RAW_SUPER	f2fs.h	/^static inline struct f2fs_super_block *F2FS_RAW_SUPER(struct f2fs_sb_info *sbi)$/;"	f
F2FS_RD_DATA	f2fs.h	/^	F2FS_RD_DATA,$/;"	e	enum:count_type
F2FS_RD_META	f2fs.h	/^	F2FS_RD_META,$/;"	e	enum:count_type
F2FS_RD_NODE	f2fs.h	/^	F2FS_RD_NODE,$/;"	e	enum:count_type
F2FS_REG_FLMASK	f2fs.h	2674;"	d
F2FS_RW_ATTR	sysfs.c	504;"	d	file:
F2FS_SB	f2fs.h	/^static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)$/;"	f
F2FS_SBI	sysfs.c	/^	F2FS_SBI,	\/* struct f2fs_sb_info *\/$/;"	e	enum:__anon5	file:
F2FS_SETTABLE_FS_FL	file.c	1905;"	d	file:
F2FS_SET_FEATURE	f2fs.h	173;"	d
F2FS_STAT	f2fs.h	/^static inline struct f2fs_stat_info *F2FS_STAT(struct f2fs_sb_info *sbi)$/;"	f
F2FS_STAT_ATTR	sysfs.c	519;"	d	file:
F2FS_SUPPORTED_XFLAGS	file.c	3109;"	d	file:
F2FS_SYNC_FL	f2fs.h	2657;"	d
F2FS_SYSTEM_ADVISE_NAME	xattr.h	27;"	d
F2FS_TOTAL_EXTRA_ATTR_SIZE	f2fs.h	3122;"	d
F2FS_VERIFY_VER	verity.c	32;"	d	file:
F2FS_WB_CP_DATA	f2fs.h	/^	F2FS_WB_CP_DATA,$/;"	e	enum:count_type
F2FS_WB_DATA	f2fs.h	/^	F2FS_WB_DATA,$/;"	e	enum:count_type
F2FS_XATTR_INDEX_ADVISE	xattr.h	34;"	d
F2FS_XATTR_INDEX_ENCRYPTION	xattr.h	36;"	d
F2FS_XATTR_INDEX_LUSTRE	xattr.h	32;"	d
F2FS_XATTR_INDEX_POSIX_ACL_ACCESS	xattr.h	29;"	d
F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT	xattr.h	30;"	d
F2FS_XATTR_INDEX_SECURITY	xattr.h	33;"	d
F2FS_XATTR_INDEX_TRUSTED	xattr.h	31;"	d
F2FS_XATTR_INDEX_USER	xattr.h	28;"	d
F2FS_XATTR_INDEX_VERITY	xattr.h	37;"	d
F2FS_XATTR_MAGIC	xattr.h	21;"	d
F2FS_XATTR_NAME_ENCRYPTION_CONTEXT	xattr.h	39;"	d
F2FS_XATTR_NAME_VERITY	xattr.h	40;"	d
F2FS_XATTR_REFCOUNT_MAX	xattr.h	24;"	d
F2FS_ZSTD_DEFAULT_CLEVEL	compress.c	320;"	d	file:
FADVISE_COLD_BIT	f2fs.h	682;"	d
FADVISE_ENCRYPT_BIT	f2fs.h	684;"	d
FADVISE_ENC_NAME_BIT	f2fs.h	685;"	d
FADVISE_HOT_BIT	f2fs.h	687;"	d
FADVISE_KEEP_SIZE_BIT	f2fs.h	686;"	d
FADVISE_LOST_PINO_BIT	f2fs.h	683;"	d
FADVISE_MODIFIABLE_BITS	f2fs.h	690;"	d
FADVISE_VERITY_BIT	f2fs.h	688;"	d
FAULT_ALLOC_BIO	f2fs.h	/^	FAULT_ALLOC_BIO,$/;"	e	enum:__anon12
FAULT_ALLOC_NID	f2fs.h	/^	FAULT_ALLOC_NID,$/;"	e	enum:__anon12
FAULT_BLOCK	f2fs.h	/^	FAULT_BLOCK,$/;"	e	enum:__anon12
FAULT_CHECKPOINT	f2fs.h	/^	FAULT_CHECKPOINT,$/;"	e	enum:__anon12
FAULT_DIR_DEPTH	f2fs.h	/^	FAULT_DIR_DEPTH,$/;"	e	enum:__anon12
FAULT_DISCARD	f2fs.h	/^	FAULT_DISCARD,$/;"	e	enum:__anon12
FAULT_EVICT_INODE	f2fs.h	/^	FAULT_EVICT_INODE,$/;"	e	enum:__anon12
FAULT_INFO_RATE	sysfs.c	/^	FAULT_INFO_RATE,	\/* struct f2fs_fault_info *\/$/;"	e	enum:__anon5	file:
FAULT_INFO_TYPE	sysfs.c	/^	FAULT_INFO_TYPE,	\/* struct f2fs_fault_info *\/$/;"	e	enum:__anon5	file:
FAULT_KMALLOC	f2fs.h	/^	FAULT_KMALLOC,$/;"	e	enum:__anon12
FAULT_KVMALLOC	f2fs.h	/^	FAULT_KVMALLOC,$/;"	e	enum:__anon12
FAULT_MAX	f2fs.h	/^	FAULT_MAX,$/;"	e	enum:__anon12
FAULT_ORPHAN	f2fs.h	/^	FAULT_ORPHAN,$/;"	e	enum:__anon12
FAULT_PAGE_ALLOC	f2fs.h	/^	FAULT_PAGE_ALLOC,$/;"	e	enum:__anon12
FAULT_PAGE_GET	f2fs.h	/^	FAULT_PAGE_GET,$/;"	e	enum:__anon12
FAULT_READ_IO	f2fs.h	/^	FAULT_READ_IO,$/;"	e	enum:__anon12
FAULT_TRUNCATE	f2fs.h	/^	FAULT_TRUNCATE,$/;"	e	enum:__anon12
FAULT_WRITE_IO	f2fs.h	/^	FAULT_WRITE_IO,$/;"	e	enum:__anon12
FDEV	f2fs.h	1223;"	d
FEAT_ATOMIC_WRITE	sysfs.c	/^	FEAT_ATOMIC_WRITE,$/;"	e	enum:feat_id	file:
FEAT_BLKZONED	sysfs.c	/^	FEAT_BLKZONED,$/;"	e	enum:feat_id	file:
FEAT_CASEFOLD	sysfs.c	/^	FEAT_CASEFOLD,$/;"	e	enum:feat_id	file:
FEAT_COMPRESSION	sysfs.c	/^	FEAT_COMPRESSION,$/;"	e	enum:feat_id	file:
FEAT_CRYPTO	sysfs.c	/^	FEAT_CRYPTO = 0,$/;"	e	enum:feat_id	file:
FEAT_EXTRA_ATTR	sysfs.c	/^	FEAT_EXTRA_ATTR,$/;"	e	enum:feat_id	file:
FEAT_FLEXIBLE_INLINE_XATTR	sysfs.c	/^	FEAT_FLEXIBLE_INLINE_XATTR,$/;"	e	enum:feat_id	file:
FEAT_INODE_CHECKSUM	sysfs.c	/^	FEAT_INODE_CHECKSUM,$/;"	e	enum:feat_id	file:
FEAT_INODE_CRTIME	sysfs.c	/^	FEAT_INODE_CRTIME,$/;"	e	enum:feat_id	file:
FEAT_LOST_FOUND	sysfs.c	/^	FEAT_LOST_FOUND,$/;"	e	enum:feat_id	file:
FEAT_PROJECT_QUOTA	sysfs.c	/^	FEAT_PROJECT_QUOTA,$/;"	e	enum:feat_id	file:
FEAT_QUOTA_INO	sysfs.c	/^	FEAT_QUOTA_INO,$/;"	e	enum:feat_id	file:
FEAT_SB_CHECKSUM	sysfs.c	/^	FEAT_SB_CHECKSUM,$/;"	e	enum:feat_id	file:
FEAT_TEST_DUMMY_ENCRYPTION_V2	sysfs.c	/^	FEAT_TEST_DUMMY_ENCRYPTION_V2,$/;"	e	enum:feat_id	file:
FEAT_VERITY	sysfs.c	/^	FEAT_VERITY,$/;"	e	enum:feat_id	file:
FG_GC	segment.h	/^	FG_GC,$/;"	e	enum:__anon9
FILE_INODE	f2fs.h	/^	FILE_INODE,			\/* for dirty regular\/symlink inode *\/$/;"	e	enum:inode_type
FI_ACL_MODE	f2fs.h	/^	FI_ACL_MODE,		\/* indicate acl mode *\/$/;"	e	enum:__anon25
FI_APPEND_WRITE	f2fs.h	/^	FI_APPEND_WRITE,	\/* inode has appended data *\/$/;"	e	enum:__anon25
FI_ATOMIC_COMMIT	f2fs.h	/^	FI_ATOMIC_COMMIT,	\/* indicate the state of atomical committing *\/$/;"	e	enum:__anon25
FI_ATOMIC_FILE	f2fs.h	/^	FI_ATOMIC_FILE,		\/* indicate atomic file *\/$/;"	e	enum:__anon25
FI_ATOMIC_REVOKE_REQUEST	f2fs.h	/^	FI_ATOMIC_REVOKE_REQUEST, \/* request to drop atomic data *\/$/;"	e	enum:__anon25
FI_AUTO_RECOVER	f2fs.h	/^	FI_AUTO_RECOVER,	\/* indicate inode is recoverable *\/$/;"	e	enum:__anon25
FI_COMPRESSED_FILE	f2fs.h	/^	FI_COMPRESSED_FILE,	\/* indicate file's data can be compressed *\/$/;"	e	enum:__anon25
FI_COMPRESS_CORRUPT	f2fs.h	/^	FI_COMPRESS_CORRUPT,	\/* indicate compressed cluster is corrupted *\/$/;"	e	enum:__anon25
FI_DATA_EXIST	f2fs.h	/^	FI_DATA_EXIST,		\/* indicate data exists *\/$/;"	e	enum:__anon25
FI_DIRTY_DIR	f2fs.h	/^	FI_DIRTY_DIR,		\/* indicate directory has dirty pages *\/$/;"	e	enum:__anon25
FI_DIRTY_FILE	f2fs.h	/^	FI_DIRTY_FILE,		\/* indicate regular\/symlink has dirty pages *\/$/;"	e	enum:__anon25
FI_DIRTY_INODE	f2fs.h	/^	FI_DIRTY_INODE,		\/* indicate inode is dirty or not *\/$/;"	e	enum:__anon25
FI_DO_DEFRAG	f2fs.h	/^	FI_DO_DEFRAG,		\/* indicate defragment is running *\/$/;"	e	enum:__anon25
FI_DROP_CACHE	f2fs.h	/^	FI_DROP_CACHE,		\/* drop dirty page cache *\/$/;"	e	enum:__anon25
FI_ENABLE_COMPRESS	f2fs.h	/^	FI_ENABLE_COMPRESS,	\/* enable compression in "user" compression mode *\/$/;"	e	enum:__anon25
FI_EXTRA_ATTR	f2fs.h	/^	FI_EXTRA_ATTR,		\/* indicate file has extra attribute *\/$/;"	e	enum:__anon25
FI_FIRST_BLOCK_WRITTEN	f2fs.h	/^	FI_FIRST_BLOCK_WRITTEN,	\/* indicate #0 data block was written *\/$/;"	e	enum:__anon25
FI_FREE_NID	f2fs.h	/^	FI_FREE_NID,		\/* free allocated nide *\/$/;"	e	enum:__anon25
FI_HOT_DATA	f2fs.h	/^	FI_HOT_DATA,		\/* indicate file is hot *\/$/;"	e	enum:__anon25
FI_INC_LINK	f2fs.h	/^	FI_INC_LINK,		\/* need to increment i_nlink *\/$/;"	e	enum:__anon25
FI_INLINE_DATA	f2fs.h	/^	FI_INLINE_DATA,		\/* used for inline data*\/$/;"	e	enum:__anon25
FI_INLINE_DENTRY	f2fs.h	/^	FI_INLINE_DENTRY,	\/* used for inline dentry *\/$/;"	e	enum:__anon25
FI_INLINE_DOTS	f2fs.h	/^	FI_INLINE_DOTS,		\/* indicate inline dot dentries *\/$/;"	e	enum:__anon25
FI_INLINE_XATTR	f2fs.h	/^	FI_INLINE_XATTR,	\/* used for inline xattr *\/$/;"	e	enum:__anon25
FI_MAX	f2fs.h	/^	FI_MAX,			\/* max flag, never be used *\/$/;"	e	enum:__anon25
FI_MMAP_FILE	f2fs.h	/^	FI_MMAP_FILE,		\/* indicate file was mmapped *\/$/;"	e	enum:__anon25
FI_NEED_IPU	f2fs.h	/^	FI_NEED_IPU,		\/* used for ipu per file *\/$/;"	e	enum:__anon25
FI_NEW_INODE	f2fs.h	/^	FI_NEW_INODE,		\/* indicate newly allocated inode *\/$/;"	e	enum:__anon25
FI_NO_ALLOC	f2fs.h	/^	FI_NO_ALLOC,		\/* should not allocate any blocks *\/$/;"	e	enum:__anon25
FI_NO_EXTENT	f2fs.h	/^	FI_NO_EXTENT,		\/* not to use the extent cache *\/$/;"	e	enum:__anon25
FI_NO_PREALLOC	f2fs.h	/^	FI_NO_PREALLOC,		\/* indicate skipped preallocated blocks *\/$/;"	e	enum:__anon25
FI_PIN_FILE	f2fs.h	/^	FI_PIN_FILE,		\/* indicate file should not be gced *\/$/;"	e	enum:__anon25
FI_PROJ_INHERIT	f2fs.h	/^	FI_PROJ_INHERIT,	\/* indicate file inherits projectid *\/$/;"	e	enum:__anon25
FI_UPDATE_WRITE	f2fs.h	/^	FI_UPDATE_WRITE,	\/* inode has in-place-update data *\/$/;"	e	enum:__anon25
FI_VERITY_IN_PROGRESS	f2fs.h	/^	FI_VERITY_IN_PROGRESS,	\/* building fs-verity Merkle tree *\/$/;"	e	enum:__anon25
FI_VOLATILE_FILE	f2fs.h	/^	FI_VOLATILE_FILE,	\/* indicate volatile file *\/$/;"	e	enum:__anon25
FLUSH_DEVICE	segment.h	/^	FLUSH_DEVICE,$/;"	e	enum:__anon8
FLUSH_INO	f2fs.h	/^	FLUSH_INO,		\/* for multiple device flushing *\/$/;"	e	enum:__anon15
FORCE_FG_GC	segment.h	/^	FORCE_FG_GC,$/;"	e	enum:__anon9
FREE_I	f2fs.h	/^static inline struct free_segmap_info *FREE_I(struct f2fs_sb_info *sbi)$/;"	f
FREE_NID	f2fs.h	/^	FREE_NID,		\/* newly added to free nid list *\/$/;"	e	enum:nid_state
FREE_NIDS	node.h	/^	FREE_NIDS,	\/* indicates the free nid list *\/$/;"	e	enum:mem_type
FREE_NID_PAGES	node.h	15;"	d
FSYNC_MODE_NOBARRIER	f2fs.h	/^	FSYNC_MODE_NOBARRIER,	\/* fsync behaves nobarrier based on posix *\/$/;"	e	enum:fsync_mode
FSYNC_MODE_POSIX	f2fs.h	/^	FSYNC_MODE_POSIX,	\/* fsync follows posix semantics *\/$/;"	e	enum:fsync_mode
FSYNC_MODE_STRICT	f2fs.h	/^	FSYNC_MODE_STRICT,	\/* fsync behaves in line with ext4 *\/$/;"	e	enum:fsync_mode
FS_CDATA_READ_IO	f2fs.h	/^	FS_CDATA_READ_IO,		\/* compressed data read IOs *\/$/;"	e	enum:iostat_type
FS_CP_DATA_IO	f2fs.h	/^	FS_CP_DATA_IO,			\/* data IOs from checkpoint *\/$/;"	e	enum:iostat_type
FS_CP_META_IO	f2fs.h	/^	FS_CP_META_IO,			\/* meta IOs from checkpoint *\/$/;"	e	enum:iostat_type
FS_CP_NODE_IO	f2fs.h	/^	FS_CP_NODE_IO,			\/* node IOs from checkpoint *\/$/;"	e	enum:iostat_type
FS_DATA_IO	f2fs.h	/^	FS_DATA_IO,			\/* data IOs from kworker\/fsync\/reclaimer *\/$/;"	e	enum:iostat_type
FS_DATA_READ_IO	f2fs.h	/^	FS_DATA_READ_IO,		\/* data read IOs *\/$/;"	e	enum:iostat_type
FS_DISCARD	f2fs.h	/^	FS_DISCARD,			\/* discard *\/$/;"	e	enum:iostat_type
FS_GC_DATA_IO	f2fs.h	/^	FS_GC_DATA_IO,			\/* data IOs from forground gc *\/$/;"	e	enum:iostat_type
FS_GC_NODE_IO	f2fs.h	/^	FS_GC_NODE_IO,			\/* node IOs from forground gc *\/$/;"	e	enum:iostat_type
FS_GDATA_READ_IO	f2fs.h	/^	FS_GDATA_READ_IO,		\/* data read IOs from background gc *\/$/;"	e	enum:iostat_type
FS_META_IO	f2fs.h	/^	FS_META_IO,			\/* meta IOs from kworker\/reclaimer *\/$/;"	e	enum:iostat_type
FS_META_READ_IO	f2fs.h	/^	FS_META_READ_IO,		\/* meta read IOs *\/$/;"	e	enum:iostat_type
FS_MODE_ADAPTIVE	f2fs.h	/^	FS_MODE_ADAPTIVE,	\/* use both lfs\/ssr allocation *\/$/;"	e	enum:__anon31
FS_MODE_LFS	f2fs.h	/^	FS_MODE_LFS,		\/* use lfs allocation only *\/$/;"	e	enum:__anon31
FS_NODE_IO	f2fs.h	/^	FS_NODE_IO,			\/* node IOs from kworker\/fsync\/reclaimer *\/$/;"	e	enum:iostat_type
FS_NODE_READ_IO	f2fs.h	/^	FS_NODE_READ_IO,		\/* node read IOs *\/$/;"	e	enum:iostat_type
GC_AT	segment.h	/^	GC_AT,$/;"	e	enum:__anon8
GC_CB	segment.h	/^	GC_CB = 0,$/;"	e	enum:__anon8
GC_FAILURE_ATOMIC	f2fs.h	/^	GC_FAILURE_ATOMIC,$/;"	e	enum:__anon24
GC_FAILURE_PIN	f2fs.h	/^	GC_FAILURE_PIN,$/;"	e	enum:__anon24
GC_GREEDY	segment.h	/^	GC_GREEDY,$/;"	e	enum:__anon8
GC_IDLE_AT	f2fs.h	/^	GC_IDLE_AT,$/;"	e	enum:__anon29
GC_IDLE_CB	f2fs.h	/^	GC_IDLE_CB,$/;"	e	enum:__anon29
GC_IDLE_GREEDY	f2fs.h	/^	GC_IDLE_GREEDY,$/;"	e	enum:__anon29
GC_NORMAL	f2fs.h	/^	GC_NORMAL,$/;"	e	enum:__anon29
GC_THREAD	sysfs.c	/^	GC_THREAD,	\/* struct f2fs_gc_thread *\/$/;"	e	enum:__anon5	file:
GC_THREAD_MIN_WB_PAGES	gc.h	8;"	d
GC_TIME	f2fs.h	/^	GC_TIME,$/;"	e	enum:__anon28
GC_URGENT_HIGH	f2fs.h	/^	GC_URGENT_HIGH,$/;"	e	enum:__anon29
GC_URGENT_LOW	f2fs.h	/^	GC_URGENT_LOW,$/;"	e	enum:__anon29
GET_BLKOFF_FROM_SEG0	segment.h	101;"	d
GET_L2R_SEGNO	segment.h	26;"	d
GET_R2L_SEGNO	segment.h	27;"	d
GET_SEC_FROM_SEG	segment.h	115;"	d
GET_SEGNO	segment.h	104;"	d
GET_SEGNO_FROM_SEG0	segment.h	99;"	d
GET_SEGOFF_FROM_SEG0	segment.h	98;"	d
GET_SEG_FROM_SEC	segment.h	117;"	d
GET_SUM_BLOCK	segment.h	127;"	d
GET_SUM_TYPE	segment.h	130;"	d
GET_SUPERZONE_FROM_ZONE	segment.h	124;"	d
GET_ZONE_FROM_SEC	segment.h	119;"	d
GET_ZONE_FROM_SEG	segment.h	121;"	d
HAS_FSYNCED_INODE	node.h	/^	HAS_FSYNCED_INODE,	\/* is the inode fsynced before? *\/$/;"	e	enum:__anon11
HAS_LAST_FSYNC	node.h	/^	HAS_LAST_FSYNC,		\/* has the latest node fsync mark? *\/$/;"	e	enum:__anon11
HOT	f2fs.h	/^	HOT = 0,	\/* must be zero for meta bio *\/$/;"	e	enum:temp_type
IFLBA_salloc_ops	segment.c	/^static const struct segment_allocation IFLBA_salloc_ops = {$/;"	v	typeref:struct:segment_allocation	file:
INLINE_DENTRY_BITMAP_SIZE	f2fs.h	422;"	d
INLINE_RESERVED_SIZE	f2fs.h	424;"	d
INMEM	f2fs.h	/^	INMEM,		\/* the below types are used by tracepoints only. *\/$/;"	e	enum:page_type
INMEM_DROP	f2fs.h	/^	INMEM_DROP,$/;"	e	enum:page_type
INMEM_INVALIDATE	f2fs.h	/^	INMEM_INVALIDATE,$/;"	e	enum:page_type
INMEM_PAGES	node.h	/^	INMEM_PAGES,	\/* indicates inmemory pages *\/$/;"	e	enum:mem_type
INMEM_REVOKE	f2fs.h	/^	INMEM_REVOKE,$/;"	e	enum:page_type
INO_ENTRIES	node.h	/^	INO_ENTRIES,	\/* indicates inode entries *\/$/;"	e	enum:mem_type
IPU	f2fs.h	/^	IPU,$/;"	e	enum:page_type
IS_ATOMIC_WRITTEN_PAGE	f2fs.h	1353;"	d
IS_CHECKPOINTED	node.h	/^	IS_CHECKPOINTED,	\/* is it checkpointed before? *\/$/;"	e	enum:__anon11
IS_COLD	segment.h	40;"	d
IS_CURSEC	segment.h	52;"	d
IS_CURSEG	segment.h	42;"	d
IS_DATASEG	segment.h	29;"	d
IS_DIRTY	node.h	/^	IS_DIRTY,		\/* this nat entry is dirty? *\/$/;"	e	enum:__anon11
IS_DNODE	node.h	/^static inline bool IS_DNODE(struct page *node_page)$/;"	f
IS_DUMMY_WRITTEN_PAGE	f2fs.h	1355;"	d
IS_FAULT_SET	f2fs.h	70;"	d
IS_HOT	segment.h	38;"	d
IS_INODE	f2fs.h	/^static inline bool IS_INODE(struct page *page)$/;"	f
IS_IO_TRACED_PAGE	f2fs.h	1359;"	d
IS_IO_TRACED_PAGE	f2fs.h	1363;"	d
IS_NODESEG	segment.h	30;"	d
IS_PREALLOC	node.h	/^	IS_PREALLOC,		\/* nat entry is preallocated *\/$/;"	e	enum:__anon11
IS_WARM	segment.h	39;"	d
IS_XATTR_LAST_ENTRY	xattr.h	68;"	d
JW_set_zone	segment.c	/^static inline struct curseg_info *JW_set_zone(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
LFS	segment.h	/^	LFS = 0,$/;"	e	enum:__anon7
LIMIT_FREE_BLOCK	gc.h	26;"	d
LIMIT_INVALID_BLOCK	gc.h	25;"	d
LOCKED_PAGE	node.h	39;"	d
LOCK_DONE	f2fs.h	/^	LOCK_DONE,$/;"	e	enum:need_lock_type
LOCK_REQ	f2fs.h	/^	LOCK_REQ = 0,$/;"	e	enum:need_lock_type
LOCK_RETRY	f2fs.h	/^	LOCK_RETRY,$/;"	e	enum:need_lock_type
LONG_DISCARD_THRESHOLD	segment.c	5258;"	d	file:
LOOKUP_NODE	f2fs.h	/^	LOOKUP_NODE,			\/* look up a node without readahead *\/$/;"	e	enum:__anon20
LOOKUP_NODE_RA	f2fs.h	/^	LOOKUP_NODE_RA,			\/*$/;"	e	enum:__anon20
MAIN_BLKADDR	segment.h	70;"	d
MAIN_SECS	segment.h	78;"	d
MAIN_SEGS	segment.h	77;"	d
MAX_BLKADDR	segment.h	85;"	d
MAX_COMPRESS_LOG_SIZE	f2fs.h	1444;"	d
MAX_COMPRESS_WINDOW_SIZE	f2fs.h	1445;"	d
MAX_DIR_RA_PAGES	f2fs.h	533;"	d
MAX_DISCARD_BLOCKS	f2fs.h	201;"	d
MAX_DPOLICY	f2fs.h	/^	MAX_DPOLICY,$/;"	e	enum:__anon19
MAX_FREE_NIDS	node.h	16;"	d
MAX_GC_FAILURE	f2fs.h	/^	MAX_GC_FAILURE$/;"	e	enum:__anon24
MAX_GC_POLICY	segment.h	/^	MAX_GC_POLICY,$/;"	e	enum:__anon8
MAX_INLINE_DATA	f2fs.h	413;"	d
MAX_INLINE_XATTR_SIZE	xattr.h	86;"	d
MAX_INO_ENTRY	f2fs.h	/^	MAX_INO_ENTRY,		\/* max. list *\/$/;"	e	enum:__anon15
MAX_IOSTAT_PERIOD_MS	f2fs.h	3135;"	d
MAX_NAT_JENTRIES	f2fs.h	382;"	d
MAX_NAT_STATE	f2fs.h	/^	MAX_NAT_STATE,$/;"	e	enum:nat_state
MAX_NID_STATE	f2fs.h	/^	MAX_NID_STATE,$/;"	e	enum:nid_state
MAX_PLIST_NUM	f2fs.h	284;"	d
MAX_RA_NODE	node.h	24;"	d
MAX_SIT_JENTRIES	f2fs.h	383;"	d
MAX_SKIP_GC_COUNT	segment.h	242;"	d
MAX_TIME	f2fs.h	/^	MAX_TIME,$/;"	e	enum:__anon28
MAX_VALUE_LEN	xattr.h	82;"	d
MAX_VMAP_RETRIES	compress.c	582;"	d	file:
META	f2fs.h	/^	META,$/;"	e	enum:page_type
META_CP	f2fs.h	/^	META_CP,$/;"	e	enum:__anon14
META_FLUSH	f2fs.h	/^	META_FLUSH,$/;"	e	enum:page_type
META_GENERIC	f2fs.h	/^	META_GENERIC,$/;"	e	enum:__anon14
META_MAPPING	f2fs.h	/^static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)$/;"	f
META_MAX	f2fs.h	/^	META_MAX,$/;"	e	enum:__anon14
META_NAT	f2fs.h	/^	META_NAT,$/;"	e	enum:__anon14
META_POR	f2fs.h	/^	META_POR,$/;"	e	enum:__anon14
META_SIT	f2fs.h	/^	META_SIT,$/;"	e	enum:__anon14
META_SSA	f2fs.h	/^	META_SSA,$/;"	e	enum:__anon14
MIN_COMPRESS_LOG_SIZE	f2fs.h	1443;"	d
MIN_IOSTAT_PERIOD_MS	f2fs.h	3133;"	d
MIN_OFFSET	xattr.h	79;"	d
NATVEC_SIZE	node.h	35;"	d
NAT_BITMAP	f2fs.h	/^	NAT_BITMAP,$/;"	e	enum:__anon13
NAT_BLOCK_OFFSET	node.h	12;"	d
NAT_ENTRIES	node.h	/^	NAT_ENTRIES,	\/* indicates the cached nat entry *\/$/;"	e	enum:mem_type
NEXT_FREE_BLKADDR	segment.h	95;"	d
NM_I	f2fs.h	/^static inline struct f2fs_nm_info *NM_I(struct f2fs_sb_info *sbi)$/;"	f
NM_INFO	sysfs.c	/^	NM_INFO,	\/* struct f2fs_nm_info *\/$/;"	e	enum:__anon5	file:
NODE	f2fs.h	/^	NODE,$/;"	e	enum:page_type
NODE_MAPPING	f2fs.h	/^static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)$/;"	f
NO_CHECK_TYPE	f2fs.h	/^	NO_CHECK_TYPE,		\/* number of persistent & inmem log *\/$/;"	e	enum:__anon26
NR_COUNT_TYPE	f2fs.h	/^	NR_COUNT_TYPE,$/;"	e	enum:count_type
NR_CURSEG_DATA_TYPE	f2fs.h	986;"	d
NR_CURSEG_INMEM_TYPE	f2fs.h	988;"	d
NR_CURSEG_NODE_TYPE	f2fs.h	987;"	d
NR_CURSEG_PERSIST_TYPE	f2fs.h	989;"	d
NR_CURSEG_TYPE	f2fs.h	990;"	d
NR_DIRTY_TYPE	segment.h	/^	NR_DIRTY_TYPE$/;"	e	enum:dirty_type
NR_INLINE_DENTRY	f2fs.h	419;"	d
NR_INODE_TYPE	f2fs.h	/^	NR_INODE_TYPE,$/;"	e	enum:inode_type
NR_IO_TYPE	f2fs.h	/^	NR_IO_TYPE,$/;"	e	enum:iostat_type
NR_PAGE_TYPE	f2fs.h	/^	NR_PAGE_TYPE,$/;"	e	enum:page_type
NR_PERSISTENT_LOG	f2fs.h	/^	NR_PERSISTENT_LOG,	\/* number of persistent log *\/$/;"	e	enum:__anon26
NR_TEMP_TYPE	f2fs.h	/^	NR_TEMP_TYPE,$/;"	e	enum:temp_type
NULL_CLUSTER	f2fs.h	1442;"	d
NULL_SECNO	segment.h	13;"	d
NULL_SEGNO	segment.h	12;"	d
NUM_PREALLOC_POST_READ_CTXS	data.c	31;"	d	file:
OPU	f2fs.h	/^	OPU,$/;"	e	enum:page_type
ORPHAN_INO	f2fs.h	/^	ORPHAN_INO,		\/* for orphan ino list *\/$/;"	e	enum:__anon15
Opt_acl	super.c	/^	Opt_acl,$/;"	e	enum:__anon35	file:
Opt_active_logs	super.c	/^	Opt_active_logs,$/;"	e	enum:__anon35	file:
Opt_alloc	super.c	/^	Opt_alloc,$/;"	e	enum:__anon35	file:
Opt_atgc	super.c	/^	Opt_atgc,$/;"	e	enum:__anon35	file:
Opt_checkpoint_disable	super.c	/^	Opt_checkpoint_disable,$/;"	e	enum:__anon35	file:
Opt_checkpoint_disable_cap	super.c	/^	Opt_checkpoint_disable_cap,$/;"	e	enum:__anon35	file:
Opt_checkpoint_disable_cap_perc	super.c	/^	Opt_checkpoint_disable_cap_perc,$/;"	e	enum:__anon35	file:
Opt_checkpoint_enable	super.c	/^	Opt_checkpoint_enable,$/;"	e	enum:__anon35	file:
Opt_compress_algorithm	super.c	/^	Opt_compress_algorithm,$/;"	e	enum:__anon35	file:
Opt_compress_chksum	super.c	/^	Opt_compress_chksum,$/;"	e	enum:__anon35	file:
Opt_compress_extension	super.c	/^	Opt_compress_extension,$/;"	e	enum:__anon35	file:
Opt_compress_log_size	super.c	/^	Opt_compress_log_size,$/;"	e	enum:__anon35	file:
Opt_compress_mode	super.c	/^	Opt_compress_mode,$/;"	e	enum:__anon35	file:
Opt_data_flush	super.c	/^	Opt_data_flush,$/;"	e	enum:__anon35	file:
Opt_disable_ext_identify	super.c	/^	Opt_disable_ext_identify,$/;"	e	enum:__anon35	file:
Opt_disable_roll_forward	super.c	/^	Opt_disable_roll_forward,$/;"	e	enum:__anon35	file:
Opt_discard	super.c	/^	Opt_discard,$/;"	e	enum:__anon35	file:
Opt_err	super.c	/^	Opt_err,$/;"	e	enum:__anon35	file:
Opt_extent_cache	super.c	/^	Opt_extent_cache,$/;"	e	enum:__anon35	file:
Opt_fastboot	super.c	/^	Opt_fastboot,$/;"	e	enum:__anon35	file:
Opt_fault_injection	super.c	/^	Opt_fault_injection,$/;"	e	enum:__anon35	file:
Opt_fault_type	super.c	/^	Opt_fault_type,$/;"	e	enum:__anon35	file:
Opt_flush_merge	super.c	/^	Opt_flush_merge,$/;"	e	enum:__anon35	file:
Opt_fsync	super.c	/^	Opt_fsync,$/;"	e	enum:__anon35	file:
Opt_gc_background	super.c	/^	Opt_gc_background,$/;"	e	enum:__anon35	file:
Opt_grpjquota	super.c	/^	Opt_grpjquota,$/;"	e	enum:__anon35	file:
Opt_grpquota	super.c	/^	Opt_grpquota,$/;"	e	enum:__anon35	file:
Opt_heap	super.c	/^	Opt_heap,$/;"	e	enum:__anon35	file:
Opt_inline_data	super.c	/^	Opt_inline_data,$/;"	e	enum:__anon35	file:
Opt_inline_dentry	super.c	/^	Opt_inline_dentry,$/;"	e	enum:__anon35	file:
Opt_inline_xattr	super.c	/^	Opt_inline_xattr,$/;"	e	enum:__anon35	file:
Opt_inline_xattr_size	super.c	/^	Opt_inline_xattr_size,$/;"	e	enum:__anon35	file:
Opt_inlinecrypt	super.c	/^	Opt_inlinecrypt,$/;"	e	enum:__anon35	file:
Opt_io_size_bits	super.c	/^	Opt_io_size_bits,$/;"	e	enum:__anon35	file:
Opt_jqfmt_vfsold	super.c	/^	Opt_jqfmt_vfsold,$/;"	e	enum:__anon35	file:
Opt_jqfmt_vfsv0	super.c	/^	Opt_jqfmt_vfsv0,$/;"	e	enum:__anon35	file:
Opt_jqfmt_vfsv1	super.c	/^	Opt_jqfmt_vfsv1,$/;"	e	enum:__anon35	file:
Opt_lazytime	super.c	/^	Opt_lazytime,$/;"	e	enum:__anon35	file:
Opt_mode	super.c	/^	Opt_mode,$/;"	e	enum:__anon35	file:
Opt_noacl	super.c	/^	Opt_noacl,$/;"	e	enum:__anon35	file:
Opt_nobarrier	super.c	/^	Opt_nobarrier,$/;"	e	enum:__anon35	file:
Opt_nodiscard	super.c	/^	Opt_nodiscard,$/;"	e	enum:__anon35	file:
Opt_noextent_cache	super.c	/^	Opt_noextent_cache,$/;"	e	enum:__anon35	file:
Opt_noflush_merge	super.c	/^	Opt_noflush_merge,$/;"	e	enum:__anon35	file:
Opt_noheap	super.c	/^	Opt_noheap,$/;"	e	enum:__anon35	file:
Opt_noinline_data	super.c	/^	Opt_noinline_data,$/;"	e	enum:__anon35	file:
Opt_noinline_dentry	super.c	/^	Opt_noinline_dentry,$/;"	e	enum:__anon35	file:
Opt_noinline_xattr	super.c	/^	Opt_noinline_xattr,$/;"	e	enum:__anon35	file:
Opt_nolazytime	super.c	/^	Opt_nolazytime,$/;"	e	enum:__anon35	file:
Opt_noquota	super.c	/^	Opt_noquota,$/;"	e	enum:__anon35	file:
Opt_norecovery	super.c	/^	Opt_norecovery,$/;"	e	enum:__anon35	file:
Opt_nouser_xattr	super.c	/^	Opt_nouser_xattr,$/;"	e	enum:__anon35	file:
Opt_offgrpjquota	super.c	/^	Opt_offgrpjquota,$/;"	e	enum:__anon35	file:
Opt_offprjjquota	super.c	/^	Opt_offprjjquota,$/;"	e	enum:__anon35	file:
Opt_offusrjquota	super.c	/^	Opt_offusrjquota,$/;"	e	enum:__anon35	file:
Opt_prjjquota	super.c	/^	Opt_prjjquota,$/;"	e	enum:__anon35	file:
Opt_prjquota	super.c	/^	Opt_prjquota,$/;"	e	enum:__anon35	file:
Opt_quota	super.c	/^	Opt_quota,$/;"	e	enum:__anon35	file:
Opt_reserve_root	super.c	/^	Opt_reserve_root,$/;"	e	enum:__anon35	file:
Opt_resgid	super.c	/^	Opt_resgid,$/;"	e	enum:__anon35	file:
Opt_resuid	super.c	/^	Opt_resuid,$/;"	e	enum:__anon35	file:
Opt_test_dummy_encryption	super.c	/^	Opt_test_dummy_encryption,$/;"	e	enum:__anon35	file:
Opt_user_xattr	super.c	/^	Opt_user_xattr,$/;"	e	enum:__anon35	file:
Opt_usrjquota	super.c	/^	Opt_usrjquota,$/;"	e	enum:__anon35	file:
Opt_usrquota	super.c	/^	Opt_usrquota,$/;"	e	enum:__anon35	file:
Opt_whint	super.c	/^	Opt_whint,$/;"	e	enum:__anon35	file:
PAGE_TYPE_OF_BIO	f2fs.h	1105;"	d
PIDVEC_SIZE	trace.c	131;"	d	file:
PRE	segment.h	/^	PRE,			\/* to count # of entirely obsolete segments *\/$/;"	e	enum:dirty_type
PREALLOC_NID	f2fs.h	/^	PREALLOC_NID,		\/* it is preallocated *\/$/;"	e	enum:nid_state
QTYPE2NAME	super.c	321;"	d	file:
RAW_IS_INODE	f2fs.h	2545;"	d
RDEV	f2fs.h	1224;"	d
RECLAIMABLE_NAT	f2fs.h	/^	RECLAIMABLE_NAT,$/;"	e	enum:nat_state
REQ_TIME	f2fs.h	/^	REQ_TIME,$/;"	e	enum:__anon28
RESERVED_BLOCKS	sysfs.c	/^	RESERVED_BLOCKS,	\/* struct f2fs_sb_info *\/$/;"	e	enum:__anon5	file:
SBI_CP_DISABLED	f2fs.h	/^	SBI_CP_DISABLED,			\/* CP was disabled last mount *\/$/;"	e	enum:__anon27
SBI_CP_DISABLED_QUICK	f2fs.h	/^	SBI_CP_DISABLED_QUICK,			\/* CP was disabled quickly *\/$/;"	e	enum:__anon27
SBI_IS_CLOSE	f2fs.h	/^	SBI_IS_CLOSE,				\/* specify unmounting *\/$/;"	e	enum:__anon27
SBI_IS_DIRTY	f2fs.h	/^	SBI_IS_DIRTY,				\/* dirty flag for checkpoint *\/$/;"	e	enum:__anon27
SBI_IS_RECOVERED	f2fs.h	/^	SBI_IS_RECOVERED,			\/* recovered orphan\/data *\/$/;"	e	enum:__anon27
SBI_IS_RESIZEFS	f2fs.h	/^	SBI_IS_RESIZEFS,			\/* resizefs is in process *\/$/;"	e	enum:__anon27
SBI_IS_SHUTDOWN	f2fs.h	/^	SBI_IS_SHUTDOWN,			\/* shutdown by ioctl *\/$/;"	e	enum:__anon27
SBI_NEED_CP	f2fs.h	/^	SBI_NEED_CP,				\/* need to checkpoint *\/$/;"	e	enum:__anon27
SBI_NEED_FSCK	f2fs.h	/^	SBI_NEED_FSCK,				\/* need fsck.f2fs to fix *\/$/;"	e	enum:__anon27
SBI_NEED_SB_WRITE	f2fs.h	/^	SBI_NEED_SB_WRITE,			\/* need to recover superblock *\/$/;"	e	enum:__anon27
SBI_POR_DOING	f2fs.h	/^	SBI_POR_DOING,				\/* recovery is doing or not *\/$/;"	e	enum:__anon27
SBI_QUOTA_NEED_FLUSH	f2fs.h	/^	SBI_QUOTA_NEED_FLUSH,			\/* need to flush quota info in CP *\/$/;"	e	enum:__anon27
SBI_QUOTA_NEED_REPAIR	f2fs.h	/^	SBI_QUOTA_NEED_REPAIR,			\/* quota file may be corrupted *\/$/;"	e	enum:__anon27
SBI_QUOTA_SKIP_FLUSH	f2fs.h	/^	SBI_QUOTA_SKIP_FLUSH,			\/* skip flushing quota in current CP *\/$/;"	e	enum:__anon27
SECTOR_FROM_BLOCK	segment.h	144;"	d
SECTOR_TO_BLOCK	segment.h	146;"	d
SEG0_BLKADDR	segment.h	73;"	d
SEGMENT_SIZE	segment.h	86;"	d
SETVEC_SIZE	node.h	36;"	d
SET_SUM_TYPE	segment.h	131;"	d
SHRINK_NID_BATCH_SIZE	node.h	19;"	d
SIT_BITMAP	f2fs.h	/^	SIT_BITMAP$/;"	e	enum:__anon13
SIT_BLK_CNT	segment.h	139;"	d
SIT_BLOCK_OFFSET	segment.h	135;"	d
SIT_ENTRY_OFFSET	segment.h	133;"	d
SIT_I	f2fs.h	/^static inline struct sit_info *SIT_I(struct f2fs_sb_info *sbi)$/;"	f
SMALL_VOLUME_SEGMENTS	segment.h	718;"	d
SM_I	f2fs.h	/^static inline struct f2fs_sm_info *SM_I(struct f2fs_sb_info *sbi)$/;"	f
SM_INFO	sysfs.c	/^	SM_INFO,	\/* struct f2fs_sm_info *\/$/;"	e	enum:__anon5	file:
SSR	segment.h	/^	SSR,$/;"	e	enum:__anon7
START_BLOCK	segment.h	89;"	d
START_NID	node.h	9;"	d
START_SEGNO	segment.h	137;"	d
STAT_INFO	sysfs.c	/^	STAT_INFO,	\/* struct f2fs_stat_info *\/$/;"	e	enum:__anon5	file:
STEP_DECOMPRESS	data.c	/^	STEP_DECOMPRESS,		\/* handle compressed cluster data in workqueue *\/$/;"	e	enum:bio_post_read_step	file:
STEP_DECOMPRESS_NOWQ	data.c	/^	STEP_DECOMPRESS_NOWQ,		\/* handle normal cluster data inplace *\/$/;"	e	enum:bio_post_read_step	file:
STEP_DECRYPT	data.c	/^	STEP_DECRYPT,$/;"	e	enum:bio_post_read_step	file:
STEP_VERITY	data.c	/^	STEP_VERITY,$/;"	e	enum:bio_post_read_step	file:
TEA_hash_name	hash.c	/^static u32 TEA_hash_name(const u8 *p, size_t len)$/;"	f	file:
TEA_transform	hash.c	/^static void TEA_transform(unsigned int buf[4], unsigned int const in[])$/;"	f	file:
TOTAL_BLKS	segment.h	83;"	d
TOTAL_NAT	f2fs.h	/^	TOTAL_NAT,$/;"	e	enum:nat_state
TOTAL_SEGS	segment.h	80;"	d
TRANS_DIR_INO	f2fs.h	/^	TRANS_DIR_INO,		\/* for trasactions dir ino list *\/$/;"	e	enum:__anon15
UMOUNT_DISCARD_TIMEOUT	f2fs.h	/^	UMOUNT_DISCARD_TIMEOUT,$/;"	e	enum:__anon28
UPDATE_INO	f2fs.h	/^	UPDATE_INO,		\/* for update ino list *\/$/;"	e	enum:__anon15
VALID_XATTR_BLOCK_SIZE	xattr.h	74;"	d
WARM	f2fs.h	/^	WARM,$/;"	e	enum:temp_type
WB_DATA_TYPE	f2fs.h	1075;"	d
WHINT_MODE_FS	f2fs.h	/^	WHINT_MODE_FS,		\/* pass down hints with F2FS policy *\/$/;"	e	enum:__anon32
WHINT_MODE_OFF	f2fs.h	/^	WHINT_MODE_OFF,		\/* not pass down write hints *\/$/;"	e	enum:__anon32
WHINT_MODE_USER	f2fs.h	/^	WHINT_MODE_USER,	\/* try to pass down hints given by users *\/$/;"	e	enum:__anon32
W_SIZE	segment.c	5649;"	d	file:
XATTR_ALIGN	xattr.h	60;"	d
XATTR_ENTRY	xattr.h	56;"	d
XATTR_FIRST_ENTRY	xattr.h	57;"	d
XATTR_HDR	xattr.h	55;"	d
XATTR_NEXT_ENTRY	xattr.h	65;"	d
XATTR_NODE_OFFSET	f2fs.h	512;"	d
XATTR_PADDING_SIZE	xattr.h	75;"	d
XATTR_ROUND	xattr.h	58;"	d
XATTR_SIZE	xattr.h	76;"	d
ZONES_PER_SUPERZONE	segment.h	21;"	d
_LINUX_F2FS_H	f2fs.h	9;"	d
__ATOMIC_FILE	trace.h	/^	__ATOMIC_FILE,$/;"	e	enum:file_type
__DIR_FILE	trace.h	/^	__DIR_FILE,$/;"	e	enum:file_type
__F2FS_ACL_H__	acl.h	13;"	d
__F2FS_HAS_FEATURE	f2fs.h	170;"	d
__F2FS_TRACE_H__	trace.h	9;"	d
__F2FS_XATTR_H__	xattr.h	15;"	d
__META_FILE	trace.h	/^	__META_FILE,$/;"	e	enum:file_type
__MISC_FILE	trace.h	/^	__MISC_FILE,$/;"	e	enum:file_type
__NODE_FILE	trace.h	/^	__NODE_FILE,$/;"	e	enum:file_type
__NORMAL_FILE	trace.h	/^	__NORMAL_FILE,$/;"	e	enum:file_type
__VOLATILE_FILE	trace.h	/^	__VOLATILE_FILE,$/;"	e	enum:file_type
__add_dirty_inode	checkpoint.c	/^static void __add_dirty_inode(struct inode *inode, enum inode_type type)$/;"	f	file:
__add_ino_entry	checkpoint.c	/^static void __add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino,$/;"	f	file:
__add_sum_entry	segment.c	/^static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,$/;"	f	file:
__adjust_nat_entry_set	node.c	/^static void __adjust_nat_entry_set(struct nat_entry_set *nes,$/;"	f	file:
__alloc_nat_entry	node.c	/^static struct nat_entry *__alloc_nat_entry(nid_t nid, bool no_fail)$/;"	f	file:
__allocate_data_block	data.c	/^static int __allocate_data_block(struct dnode_of_data *dn, int seg_type)$/;"	f	file:
__allocate_new_segment	segment.c	/^static void __allocate_new_segment(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
__allow_reserved_blocks	f2fs.h	/^static inline bool __allow_reserved_blocks(struct f2fs_sb_info *sbi,$/;"	f
__attach_discard_cmd	segment.c	/^static struct discard_cmd *__attach_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__attach_extent_node	extent_cache.c	/^static struct extent_node *__attach_extent_node(struct f2fs_sb_info *sbi,$/;"	f	file:
__attach_io_flag	data.c	/^static void __attach_io_flag(struct f2fs_io_info *fio)$/;"	f	file:
__bio_alloc	data.c	/^static struct bio *__bio_alloc(struct f2fs_io_info *fio, int npages)$/;"	f	file:
__bitmap_ptr	f2fs.h	/^static inline void *__bitmap_ptr(struct f2fs_sb_info *sbi, int flag)$/;"	f
__bitmap_size	f2fs.h	/^static inline unsigned long __bitmap_size(struct f2fs_sb_info *sbi, int flag)$/;"	f
__check_sit_bitmap	segment.c	/^static void __check_sit_bitmap(struct f2fs_sb_info *sbi,$/;"	f	file:
__clear_ckpt_flags	f2fs.h	/^static inline void __clear_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)$/;"	f
__clear_nat_cache_dirty	node.c	/^static void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,$/;"	f	file:
__clone_blkaddrs	file.c	/^static int __clone_blkaddrs(struct inode *src_inode, struct inode *dst_inode,$/;"	f	file:
__cluster_may_compress	compress.c	/^static bool __cluster_may_compress(struct compress_ctx *cc)$/;"	f	file:
__count_extent_cache	shrinker.c	/^static unsigned long __count_extent_cache(struct f2fs_sb_info *sbi)$/;"	f	file:
__count_free_nids	shrinker.c	/^static unsigned long __count_free_nids(struct f2fs_sb_info *sbi)$/;"	f	file:
__count_nat_entries	shrinker.c	/^static unsigned long __count_nat_entries(struct f2fs_sb_info *sbi)$/;"	f	file:
__cp_payload	f2fs.h	/^static inline block_t __cp_payload(struct f2fs_sb_info *sbi)$/;"	f
__create_discard_cmd	segment.c	/^static struct discard_cmd *__create_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__create_discard_map	segment.c	/^static struct dynamic_discard_map *__create_discard_map(struct f2fs_sb_info *sbi)$/;"	f	file:
__create_discard_range_entry	segment.c	/^static struct discard_range_entry *__create_discard_range_entry(void)$/;"	f	file:
__del_from_nat_cache	node.c	/^static void __del_from_nat_cache(struct f2fs_nm_info *nm_i, struct nat_entry *e)$/;"	f	file:
__detach_discard_cmd	segment.c	/^static void __detach_discard_cmd(struct discard_cmd_control *dcc,$/;"	f	file:
__detach_extent_node	extent_cache.c	/^static void __detach_extent_node(struct f2fs_sb_info *sbi,$/;"	f	file:
__drop_discard_cmd	segment.c	/^static bool __drop_discard_cmd(struct f2fs_sb_info *sbi)$/;"	f	file:
__drop_largest_extent	extent_cache.c	/^static void __drop_largest_extent(struct extent_tree *et,$/;"	f	file:
__exchange_data_block	file.c	/^static int __exchange_data_block(struct inode *src_inode,$/;"	f	file:
__exist_node_summaries	f2fs.h	/^static inline bool __exist_node_summaries(struct f2fs_sb_info *sbi)$/;"	f
__f2fs_bio_alloc	data.c	/^static inline struct bio *__f2fs_bio_alloc(gfp_t gfp_mask,$/;"	f	file:
__f2fs_build_free_nids	node.c	/^static int __f2fs_build_free_nids(struct f2fs_sb_info *sbi,$/;"	f	file:
__f2fs_cluster_blocks	compress.c	/^static int __f2fs_cluster_blocks(struct compress_ctx *cc, bool compr)$/;"	f	file:
__f2fs_commit_inmem_pages	segment.c	/^static int __f2fs_commit_inmem_pages(struct inode *inode)$/;"	f	file:
__f2fs_commit_super	super.c	/^static int __f2fs_commit_super(struct buffer_head *bh,$/;"	f	file:
__f2fs_crc32	f2fs.h	/^static inline u32 __f2fs_crc32(struct f2fs_sb_info *sbi, u32 crc,$/;"	f
__f2fs_find_entry	dir.c	/^struct f2fs_dir_entry *__f2fs_find_entry(struct inode *dir,$/;"	f
__f2fs_get_acl	acl.c	/^static struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,$/;"	f	file:
__f2fs_get_curseg	segment.c	/^static inline int __f2fs_get_curseg(struct f2fs_sb_info *sbi,$/;"	f	file:
__f2fs_init_atgc_curseg	segment.c	/^static void __f2fs_init_atgc_curseg(struct f2fs_sb_info *sbi)$/;"	f	file:
__f2fs_init_extent_tree	extent_cache.c	/^static void __f2fs_init_extent_tree(struct inode *inode, struct page *ipage)$/;"	f	file:
__f2fs_ioc_gc_range	file.c	/^static int __f2fs_ioc_gc_range(struct file *filp, struct f2fs_gc_range *range)$/;"	f	file:
__f2fs_ioc_move_range	file.c	/^static int __f2fs_ioc_move_range(struct file *filp,$/;"	f	file:
__f2fs_ioctl	file.c	/^static long __f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)$/;"	f	file:
__f2fs_issue_discard_zone	segment.c	/^static int __f2fs_issue_discard_zone(struct f2fs_sb_info *sbi,$/;"	f	file:
__f2fs_quota_off	super.c	/^static int __f2fs_quota_off(struct super_block *sb, int type)$/;"	f	file:
__f2fs_read_end_io	data.c	/^static void __f2fs_read_end_io(struct bio *bio, bool compr, bool verity)$/;"	f	file:
__f2fs_restore_inmem_curseg	segment.c	/^static void __f2fs_restore_inmem_curseg(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
__f2fs_save_inmem_curseg	segment.c	/^static void __f2fs_save_inmem_curseg(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
__f2fs_set_acl	acl.c	/^static int __f2fs_set_acl(struct inode *inode, int type,$/;"	f	file:
__f2fs_setup_filename	dir.c	/^static int __f2fs_setup_filename(const struct inode *dir,$/;"	f	file:
__f2fs_setxattr	xattr.c	/^static int __f2fs_setxattr(struct inode *inode, int index,$/;"	f	file:
__f2fs_submit_merged_write	data.c	/^static void __f2fs_submit_merged_write(struct f2fs_sb_info *sbi,$/;"	f	file:
__f2fs_tmpfile	namei.c	/^static int __f2fs_tmpfile(struct inode *dir, struct dentry *dentry,$/;"	f	file:
__f2fs_write_data_pages	data.c	/^static int __f2fs_write_data_pages(struct address_space *mapping,$/;"	f	file:
__f2fs_write_meta_page	checkpoint.c	/^static int __f2fs_write_meta_page(struct page *page,$/;"	f	file:
__file_type	trace.c	/^static int __file_type(struct inode *inode, pid_t pid)$/;"	f	file:
__find_inline_xattr	xattr.c	/^static struct f2fs_xattr_entry *__find_inline_xattr(struct inode *inode,$/;"	f	file:
__find_rev_next_bit	segment.c	/^static unsigned long __find_rev_next_bit(const unsigned long *addr,$/;"	f	file:
__find_rev_next_zero_bit	segment.c	/^static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,$/;"	f	file:
__find_xattr	xattr.c	/^static struct f2fs_xattr_entry *__find_xattr(void *base_addr,$/;"	f	file:
__flush_nat_entry_set	node.c	/^static int __flush_nat_entry_set(struct f2fs_sb_info *sbi,$/;"	f	file:
__found_offset	file.c	/^static bool __found_offset(struct address_space *mapping, block_t blkaddr,$/;"	f	file:
__free_extent_tree	extent_cache.c	/^static unsigned int __free_extent_tree(struct f2fs_sb_info *sbi,$/;"	f	file:
__free_nat_entry	node.c	/^static void __free_nat_entry(struct nat_entry *e)$/;"	f	file:
__gang_lookup_nat_cache	node.c	/^static unsigned int __gang_lookup_nat_cache(struct f2fs_nm_info *nm_i,$/;"	f	file:
__gang_lookup_nat_set	node.c	/^static unsigned int __gang_lookup_nat_set(struct f2fs_nm_info *nm_i,$/;"	f	file:
__get_cp_reason	f2fs.h	/^static inline int __get_cp_reason(struct f2fs_sb_info *sbi)$/;"	f
__get_data_block	data.c	/^static int __get_data_block(struct inode *inode, sector_t iblock,$/;"	f	file:
__get_inode_rdev	inode.c	/^static void __get_inode_rdev(struct inode *inode, struct f2fs_inode *ri)$/;"	f	file:
__get_meta_page	checkpoint.c	/^static struct page *__get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index,$/;"	f	file:
__get_nat_bitmaps	node.c	/^static int __get_nat_bitmaps(struct f2fs_sb_info *sbi)$/;"	f	file:
__get_next_segno	segment.c	/^static unsigned int __get_next_segno(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
__get_node_page	node.c	/^static struct page *__get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid,$/;"	f	file:
__get_segment_type	segment.c	/^static int __get_segment_type(struct f2fs_io_info *fio)$/;"	f	file:
__get_segment_type_2	segment.c	/^static int __get_segment_type_2(struct f2fs_io_info *fio)$/;"	f	file:
__get_segment_type_4	segment.c	/^static int __get_segment_type_4(struct f2fs_io_info *fio)$/;"	f	file:
__get_segment_type_6	segment.c	/^static int __get_segment_type_6(struct f2fs_io_info *fio)$/;"	f	file:
__get_victim	gc.c	/^static int __get_victim(struct f2fs_sb_info *sbi, unsigned int *victim,$/;"	f	file:
__grab_extent_tree	extent_cache.c	/^static struct extent_tree *__grab_extent_tree(struct inode *inode)$/;"	f	file:
__grab_nat_entry_set	node.c	/^static struct nat_entry_set *__grab_nat_entry_set(struct f2fs_nm_info *nm_i,$/;"	f	file:
__has_curseg_space	segment.c	/^static bool __has_curseg_space(struct f2fs_sb_info *sbi,$/;"	f	file:
__has_cursum_space	f2fs.h	/^static inline bool __has_cursum_space(struct f2fs_journal *journal,$/;"	f
__has_merged_page	data.c	/^static bool __has_merged_page(struct bio *bio, struct inode *inode,$/;"	f	file:
__init_discard_policy	segment.c	/^static void __init_discard_policy(struct f2fs_sb_info *sbi,$/;"	f	file:
__init_extent_tree	extent_cache.c	/^static struct extent_node *__init_extent_tree(struct f2fs_sb_info *sbi,$/;"	f	file:
__init_nat_entry	node.c	/^static struct nat_entry *__init_nat_entry(struct f2fs_nm_info *nm_i,$/;"	f	file:
__insert_discard_tree	segment.c	/^static void __insert_discard_tree(struct f2fs_sb_info *sbi,$/;"	f	file:
__insert_extent_tree	extent_cache.c	/^static struct extent_node *__insert_extent_tree(struct f2fs_sb_info *sbi,$/;"	f	file:
__insert_free_nid	node.c	/^static int __insert_free_nid(struct f2fs_sb_info *sbi,$/;"	f	file:
__is_back_mergeable	f2fs.h	/^static inline bool __is_back_mergeable(struct extent_info *cur,$/;"	f
__is_bitmap_valid	checkpoint.c	/^static bool __is_bitmap_valid(struct f2fs_sb_info *sbi, block_t blkaddr,$/;"	f	file:
__is_cp_guaranteed	data.c	/^static bool __is_cp_guaranteed(struct page *page)$/;"	f	file:
__is_discard_back_mergeable	f2fs.h	/^static inline bool __is_discard_back_mergeable(struct discard_info *cur,$/;"	f
__is_discard_front_mergeable	f2fs.h	/^static inline bool __is_discard_front_mergeable(struct discard_info *cur,$/;"	f
__is_discard_mergeable	f2fs.h	/^static inline bool __is_discard_mergeable(struct discard_info *back,$/;"	f
__is_extent_mergeable	f2fs.h	/^static inline bool __is_extent_mergeable(struct extent_info *back,$/;"	f
__is_front_mergeable	f2fs.h	/^static inline bool __is_front_mergeable(struct extent_info *cur,$/;"	f
__is_large_section	f2fs.h	3173;"	d
__is_meta_io	f2fs.h	3175;"	d
__is_set_ckpt_flags	f2fs.h	/^static inline bool __is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)$/;"	f
__is_valid_data_blkaddr	f2fs.h	/^static inline bool __is_valid_data_blkaddr(block_t blkaddr)$/;"	f
__issue_discard_async	segment.c	/^static int __issue_discard_async(struct f2fs_sb_info *sbi,$/;"	f	file:
__issue_discard_cmd	segment.c	/^static int __issue_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__issue_discard_cmd_orderly	segment.c	/^static unsigned int __issue_discard_cmd_orderly(struct f2fs_sb_info *sbi,$/;"	f	file:
__issue_discard_cmd_range	segment.c	/^static unsigned int __issue_discard_cmd_range(struct f2fs_sb_info *sbi,$/;"	f	file:
__locate_dirty_segment	segment.c	/^static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,$/;"	f	file:
__lookup_free_nid_list	node.c	/^static struct free_nid *__lookup_free_nid_list(struct f2fs_nm_info *nm_i,$/;"	f	file:
__lookup_nat_cache	node.c	/^static struct nat_entry *__lookup_nat_cache(struct f2fs_nm_info *nm_i, nid_t n)$/;"	f	file:
__lookup_rb_tree_fast	extent_cache.c	/^static struct rb_entry *__lookup_rb_tree_fast(struct rb_entry *cached_re,$/;"	f	file:
__lookup_rb_tree_slow	extent_cache.c	/^static struct rb_entry *__lookup_rb_tree_slow(struct rb_root_cached *root,$/;"	f	file:
__mark_inode_dirty_flag	f2fs.h	/^static inline void __mark_inode_dirty_flag(struct inode *inode,$/;"	f
__mark_sit_entry_dirty	segment.c	/^static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f	file:
__move_free_nid	node.c	/^static void __move_free_nid(struct f2fs_sb_info *sbi, struct free_nid *i,$/;"	f	file:
__need_flush_quota	checkpoint.c	/^static bool __need_flush_quota(struct f2fs_sb_info *sbi)$/;"	f	file:
__next_free_blkoff	segment.c	/^static void __next_free_blkoff(struct f2fs_sb_info *sbi,$/;"	f	file:
__packed	f2fs.h	/^	} __packed;$/;"	m	struct:rb_entry	typeref:union:rb_entry::__anon21
__prepare_cp_block	checkpoint.c	/^static void __prepare_cp_block(struct f2fs_sb_info *sbi)$/;"	f	file:
__print_last_io	trace.c	/^static inline void __print_last_io(void)$/;"	f	file:
__punch_discard_cmd	segment.c	/^static void __punch_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__queue_discard_cmd	segment.c	/^static int __queue_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__read_end_io	data.c	/^static void __read_end_io(struct bio *bio, bool compr, bool verity)$/;"	f	file:
__read_io_type	data.c	/^static enum count_type __read_io_type(struct page *page)$/;"	f	file:
__read_out_blkaddrs	file.c	/^static int __read_out_blkaddrs(struct inode *inode, block_t *blkaddr,$/;"	f	file:
__recover_dot_dentries	namei.c	/^static int __recover_dot_dentries(struct inode *dir, nid_t pino)$/;"	f	file:
__recover_inline_status	inode.c	/^static void __recover_inline_status(struct inode *inode, struct page *ipage)$/;"	f	file:
__refresh_next_blkoff	segment.c	/^static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,$/;"	f	file:
__release_extent_node	extent_cache.c	/^static void __release_extent_node(struct f2fs_sb_info *sbi,$/;"	f	file:
__relocate_discard_cmd	segment.c	/^static void __relocate_discard_cmd(struct discard_cmd_control *dcc,$/;"	f	file:
__remain_node_summaries	f2fs.h	/^static inline bool __remain_node_summaries(int reason)$/;"	f
__remove_dirty_inode	checkpoint.c	/^static void __remove_dirty_inode(struct inode *inode, enum inode_type type)$/;"	f	file:
__remove_dirty_segment	segment.c	/^static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,$/;"	f	file:
__remove_discard_cmd	segment.c	/^static void __remove_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__remove_dynamic_discard_map	segment.c	/^static void __remove_dynamic_discard_map(struct f2fs_sb_info *sbi, struct dynamic_discard_map *ddm)$/;"	f	file:
__remove_free_nid	node.c	/^static void __remove_free_nid(struct f2fs_sb_info *sbi,$/;"	f	file:
__remove_ino_entry	checkpoint.c	/^static void __remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)$/;"	f	file:
__reverse_ffs	segment.c	/^static inline unsigned long __reverse_ffs(unsigned long word)$/;"	f	file:
__reverse_ffz	segment.c	25;"	d	file:
__reverse_ulong	segment.c	/^static unsigned long __reverse_ulong(unsigned char *str)$/;"	f	file:
__revoke_inmem_pages	segment.c	/^static int __revoke_inmem_pages(struct inode *inode,$/;"	f	file:
__roll_back_blkaddrs	file.c	/^static int __roll_back_blkaddrs(struct inode *inode, block_t *blkaddr,$/;"	f	file:
__same_bdev	data.c	/^static bool __same_bdev(struct f2fs_sb_info *sbi,$/;"	f	file:
__sbi_store	sysfs.c	/^static ssize_t __sbi_store(struct f2fs_attr *a,$/;"	f	file:
__seg_info_to_raw_sit	segment.h	/^static inline void __seg_info_to_raw_sit(struct seg_entry *se,$/;"	f
__set_ckpt_flags	f2fs.h	/^static inline void __set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)$/;"	f
__set_cp_next_pack	f2fs.h	/^static inline void __set_cp_next_pack(struct f2fs_sb_info *sbi)$/;"	f
__set_data_blkaddr	data.c	/^static void __set_data_blkaddr(struct dnode_of_data *dn)$/;"	f	file:
__set_free	segment.h	/^static inline void __set_free(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f
__set_inode_rdev	inode.c	/^static void __set_inode_rdev(struct inode *inode, struct f2fs_inode *ri)$/;"	f	file:
__set_inuse	segment.h	/^static inline void __set_inuse(struct f2fs_sb_info *sbi,$/;"	f
__set_nat_cache_dirty	node.c	/^static void __set_nat_cache_dirty(struct f2fs_nm_info *nm_i,$/;"	f	file:
__set_sit_entry_type	segment.c	/^static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,$/;"	f	file:
__set_test_and_free	segment.h	/^static inline void __set_test_and_free(struct f2fs_sb_info *sbi,$/;"	f
__set_test_and_inuse	segment.h	/^static inline void __set_test_and_inuse(struct f2fs_sb_info *sbi,$/;"	f
__setattr_copy	file.c	/^static void __setattr_copy(struct inode *inode, const struct iattr *attr)$/;"	f	file:
__setattr_copy	file.c	860;"	d	file:
__should_serialize_io	data.c	/^static inline bool __should_serialize_io(struct inode *inode,$/;"	f	file:
__start_cp_addr	f2fs.h	/^static inline block_t __start_cp_addr(struct f2fs_sb_info *sbi)$/;"	f
__start_cp_next_addr	f2fs.h	/^static inline block_t __start_cp_next_addr(struct f2fs_sb_info *sbi)$/;"	f
__start_sum_addr	f2fs.h	/^static inline block_t __start_sum_addr(struct f2fs_sb_info *sbi)$/;"	f
__struct_ptr	sysfs.c	/^static unsigned char *__struct_ptr(struct f2fs_sb_info *sbi, int struct_type)$/;"	f	file:
__submit_bio	data.c	/^static inline void __submit_bio(struct f2fs_sb_info *sbi,$/;"	f	file:
__submit_discard_cmd	segment.c	/^static int __submit_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__submit_flush_wait	segment.c	/^static int __submit_flush_wait(struct f2fs_sb_info *sbi,$/;"	f	file:
__submit_merged_bio	data.c	/^static void __submit_merged_bio(struct f2fs_bio_info *io)$/;"	f	file:
__submit_merged_write_cond	data.c	/^static void __submit_merged_write_cond(struct f2fs_sb_info *sbi,$/;"	f	file:
__try_merge_extent_node	extent_cache.c	/^static struct extent_node *__try_merge_extent_node(struct f2fs_sb_info *sbi,$/;"	f	file:
__try_update_largest_extent	f2fs.h	/^static inline void __try_update_largest_extent(struct extent_tree *et,$/;"	f
__update_discard_tree_range	segment.c	/^static void __update_discard_tree_range(struct f2fs_sb_info *sbi,$/;"	f	file:
__update_nat_bits	node.c	/^static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,$/;"	f	file:
__wait_all_discard_cmd	segment.c	/^static unsigned int __wait_all_discard_cmd(struct f2fs_sb_info *sbi,$/;"	f	file:
__wait_discard_cmd_range	segment.c	/^static unsigned int __wait_discard_cmd_range(struct f2fs_sb_info *sbi,$/;"	f	file:
__wait_one_discard_bio	segment.c	/^static unsigned int __wait_one_discard_bio(struct f2fs_sb_info *sbi,$/;"	f	file:
__write_node_page	node.c	/^static int __write_node_page(struct page *page, bool atomic, bool *submitted,$/;"	f	file:
__written_first_block	inode.c	/^static int __written_first_block(struct f2fs_sb_info *sbi,$/;"	f	file:
a_version	acl.h	/^	__le32 a_version;$/;"	m	struct:f2fs_acl_header
active_logs	f2fs.h	/^	int active_logs;		\/* # of active logs *\/$/;"	m	struct:f2fs_mount_info
add_bio_entry	data.c	/^static void add_bio_entry(struct f2fs_sb_info *sbi, struct bio *bio,$/;"	f	file:
add_discard_addrs	segment.c	/^static bool add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc,$/;"	f	file:
add_discard_journal	segment.c	/^static bool add_discard_journal(struct f2fs_sb_info *sbi, struct discard_journal_bitmap *dj_map)$/;"	f	file:
add_discard_range_journal	segment.c	/^static void add_discard_range_journal(struct f2fs_sb_info *sbi, block_t lstart, block_t len, struct dynamic_discard_map *ddm)$/;"	f	file:
add_free_nid	node.c	/^static bool add_free_nid(struct f2fs_sb_info *sbi,$/;"	f	file:
add_fsync_inode	recovery.c	/^static struct fsync_inode_entry *add_fsync_inode(struct f2fs_sb_info *sbi,$/;"	f	file:
add_gc_inode	gc.c	/^static void add_gc_inode(struct gc_inode_list *gc_list, struct inode *inode)$/;"	f	file:
add_ipu_page	data.c	/^static int add_ipu_page(struct f2fs_io_info *fio, struct bio **bio,$/;"	f	file:
add_sit_entry	segment.c	/^static void add_sit_entry(unsigned int segno, struct list_head *head)$/;"	f	file:
add_sits_in_set	segment.c	/^static void add_sits_in_set(struct f2fs_sb_info *sbi)$/;"	f	file:
add_victim_entry	gc.c	/^static void add_victim_entry(struct f2fs_sb_info *sbi,$/;"	f	file:
addrs_per_block	f2fs.h	/^static inline unsigned int addrs_per_block(struct inode *inode)$/;"	f
addrs_per_inode	f2fs.h	/^static inline unsigned int addrs_per_inode(struct inode *inode)$/;"	f
adjust_sit_entry_set	segment.c	/^static void adjust_sit_entry_set(struct sit_entry_set *ses,$/;"	f	file:
adjust_unusable_cap_perc	super.c	/^static inline void adjust_unusable_cap_perc(struct f2fs_sb_info *sbi)$/;"	f	file:
age	segment.h	/^	unsigned long long age;		\/* mtime of GCed section*\/$/;"	m	struct:victim_sel_policy
age_threshold	f2fs.h	/^	unsigned long long age_threshold;	\/* age threshold *\/$/;"	m	struct:atgc_management
age_threshold	segment.h	/^	unsigned long long age_threshold;\/* age threshold *\/$/;"	m	struct:victim_sel_policy
age_weight	f2fs.h	/^	unsigned int age_weight;		\/* age weight, vblock_weight = 100 - age_weight *\/$/;"	m	struct:atgc_management
all_area_segs	f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
alloc_mode	f2fs.h	/^	int alloc_mode;			\/* segment allocation policy *\/$/;"	m	struct:f2fs_mount_info
alloc_mode	segment.h	/^	int alloc_mode;			\/* LFS or SSR *\/$/;"	m	struct:victim_sel_policy
alloc_nids	f2fs.h	/^	int free_nids, avail_nids, alloc_nids;$/;"	m	struct:f2fs_stat_info
alloc_type	segment.h	/^	unsigned char alloc_type;		\/* current allocation type *\/$/;"	m	struct:curseg_info
alloc_valid_block_count	f2fs.h	/^	struct percpu_counter alloc_valid_block_count;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::percpu_counter
allocate_segment	segment.h	/^	void (*allocate_segment)(struct f2fs_sb_info *, int, bool);$/;"	m	struct:segment_allocation
allocate_segment_by_default	segment.c	/^static void allocate_segment_by_default(struct f2fs_sb_info *sbi,$/;"	f	file:
allow_outplace_dio	f2fs.h	/^static inline int allow_outplace_dio(struct inode *inode,$/;"	f
am	f2fs.h	/^	struct atgc_management am;		\/* atgc management *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::atgc_management
append	f2fs.h	/^	int inline_xattr, inline_inode, inline_dir, append, update, orphans;$/;"	m	struct:f2fs_stat_info
append_only_allocate_segment	segment.c	/^static void append_only_allocate_segment(struct f2fs_sb_info *sbi,$/;"	f	file:
atgc_enabled	f2fs.h	/^	bool atgc_enabled;			\/* ATGC is enabled or not *\/$/;"	m	struct:atgc_management
atgc_lookup_victim	gc.c	/^static void atgc_lookup_victim(struct f2fs_sb_info *sbi,$/;"	f	file:
atgc_management	f2fs.h	/^struct atgc_management {$/;"	s
atomic_files	f2fs.h	/^	unsigned int atomic_files;		\/* # of opened atomic file *\/$/;"	m	struct:f2fs_sb_info
atssr_lookup_victim	gc.c	/^static void atssr_lookup_victim(struct f2fs_sb_info *sbi,$/;"	f	file:
attach_victim_entry	gc.c	/^static struct victim_entry *attach_victim_entry(struct f2fs_sb_info *sbi,$/;"	f	file:
attr	sysfs.c	/^	struct attribute attr;$/;"	m	struct:f2fs_attr	typeref:struct:f2fs_attr::attribute	file:
avail_nids	f2fs.h	/^	int free_nids, avail_nids, alloc_nids;$/;"	m	struct:f2fs_stat_info
available_nids	f2fs.h	/^	nid_t available_nids;		\/* # of available node ids *\/$/;"	m	struct:f2fs_nm_info
avg_vblocks	f2fs.h	/^	unsigned int bimodal, avg_vblocks;$/;"	m	struct:f2fs_stat_info
avg_vblocks	sysfs.c	/^F2FS_GENERAL_RO_ATTR(avg_vblocks);$/;"	v
avg_vblocks_show	sysfs.c	/^static ssize_t avg_vblocks_show(struct f2fs_attr *a,$/;"	f	file:
aw_cnt	f2fs.h	/^	int aw_cnt, max_aw_cnt, vw_cnt, max_vw_cnt;$/;"	m	struct:f2fs_stat_info
base_mem	f2fs.h	/^	unsigned long long base_mem, cache_mem, page_mem;$/;"	m	struct:f2fs_stat_info
bdev	f2fs.h	/^	struct block_device *bdev;	\/* bdev *\/$/;"	m	struct:discard_cmd	typeref:struct:discard_cmd::block_device
bdev	f2fs.h	/^	struct block_device *bdev;$/;"	m	struct:f2fs_dev_info	typeref:struct:f2fs_dev_info::block_device
bg_cp_count	f2fs.h	/^	int prefree_count, call_count, cp_count, bg_cp_count;$/;"	m	struct:f2fs_stat_info
bg_data_blks	f2fs.h	/^	int bg_data_blks, bg_node_blks;$/;"	m	struct:f2fs_stat_info
bg_data_segs	f2fs.h	/^	int bg_node_segs, bg_data_segs;$/;"	m	struct:f2fs_stat_info
bg_gc	f2fs.h	/^	int bg_gc, nr_wb_cp_data, nr_wb_data;$/;"	m	struct:f2fs_stat_info
bg_node_blks	f2fs.h	/^	int bg_data_blks, bg_node_blks;$/;"	m	struct:f2fs_stat_info
bg_node_segs	f2fs.h	/^	int bg_node_segs, bg_data_segs;$/;"	m	struct:f2fs_stat_info
bggc_mode	f2fs.h	/^	int bggc_mode;			\/* bggc mode: off, on or sync *\/$/;"	m	struct:f2fs_mount_info
bimodal	f2fs.h	/^	unsigned int bimodal, avg_vblocks;$/;"	m	struct:f2fs_stat_info
bio	data.c	/^	struct bio *bio;$/;"	m	struct:bio_post_read_ctx	typeref:struct:bio_post_read_ctx::bio	file:
bio	f2fs.h	/^	struct bio **bio;		\/* bio for ipu *\/$/;"	m	struct:f2fs_io_info	typeref:struct:f2fs_io_info::bio
bio	f2fs.h	/^	struct bio *bio;		\/* bios to merge *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::bio
bio	f2fs.h	/^	struct bio *bio;$/;"	m	struct:bio_entry	typeref:struct:bio_entry::bio
bio_entry	f2fs.h	/^struct bio_entry {$/;"	s
bio_entry_slab	data.c	/^static struct kmem_cache *bio_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
bio_list	f2fs.h	/^	struct list_head bio_list;	\/* bio entry list head *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::list_head
bio_list_lock	f2fs.h	/^	struct rw_semaphore bio_list_lock;	\/* lock to protect bio entry list *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::rw_semaphore
bio_post_read_ctx	data.c	/^struct bio_post_read_ctx {$/;"	s	file:
bio_post_read_ctx_cache	data.c	/^static struct kmem_cache *bio_post_read_ctx_cache;$/;"	v	typeref:struct:kmem_cache	file:
bio_post_read_ctx_pool	data.c	/^static mempool_t *bio_post_read_ctx_pool;$/;"	v	file:
bio_post_read_processing	data.c	/^static void bio_post_read_processing(struct bio_post_read_ctx *ctx)$/;"	f	file:
bio_post_read_step	data.c	/^enum bio_post_read_step {$/;"	g	file:
bio_ref	f2fs.h	/^	unsigned short bio_ref;		\/* bio reference count *\/$/;"	m	struct:discard_cmd
bitmap	f2fs.h	/^	void *bitmap;$/;"	m	struct:f2fs_dentry_ptr
bitmap	segment.h	/^	char *bitmap;			\/* all bitmaps pointer *\/$/;"	m	struct:sit_info
bitmap_size	f2fs.h	/^	int bitmap_size;		\/* bitmap size *\/$/;"	m	struct:f2fs_nm_info
bitmap_size	segment.h	/^	unsigned int bitmap_size;	\/* SIT bitmap size *\/$/;"	m	struct:sit_info
blk	f2fs.h	/^	u32 blk;			\/* start block address of the extent *\/$/;"	m	struct:extent_info
blk_addr	node.h	/^	block_t	blk_addr;	\/* block address of the node *\/$/;"	m	struct:node_info
blk_cnt	f2fs.h	/^	atomic_t blk_cnt;$/;"	m	struct:dynamic_discard_map_control
blkaddr	f2fs.h	/^	block_t blkaddr;	\/* block address locating the last fsync *\/$/;"	m	struct:fsync_inode_entry
blkaddr_in_node	f2fs.h	/^static inline __le32 *blkaddr_in_node(struct f2fs_node *node)$/;"	f
blks_to_bytes	data.c	/^static inline u64 blks_to_bytes(struct inode *inode, u64 blks)$/;"	f	file:
blkz_seq	f2fs.h	/^	unsigned long *blkz_seq;	\/* Bitmap indicating sequential zones *\/$/;"	m	struct:f2fs_dev_info
block_count	f2fs.h	/^	unsigned int block_count[2];		\/* # of allocated blocks *\/$/;"	m	struct:f2fs_sb_info
block_count	f2fs.h	/^	unsigned int block_count[2];$/;"	m	struct:f2fs_stat_info
block_operations	checkpoint.c	/^static int block_operations(struct f2fs_sb_info *sbi)\/\/, int* nid7_syn)$/;"	f	file:
block_t	f2fs.h	/^typedef u32 block_t;	\/*$/;"	t
block_unaligned_IO	f2fs.h	/^static inline int block_unaligned_IO(struct inode *inode,$/;"	f
blocks_per_blkz	f2fs.h	/^	unsigned int blocks_per_blkz;		\/* F2FS blocks per zone *\/$/;"	m	struct:f2fs_sb_info
blocks_per_seg	f2fs.h	/^	unsigned int blocks_per_seg;		\/* blocks per segment *\/$/;"	m	struct:f2fs_sb_info
blocksize	f2fs.h	/^	unsigned int blocksize;			\/* block size *\/$/;"	m	struct:f2fs_sb_info
bucket_blocks	dir.c	/^static unsigned int bucket_blocks(unsigned int level)$/;"	f	file:
build_curseg	segment.c	/^static int build_curseg(struct f2fs_sb_info *sbi)               $/;"	f	file:
build_dirty_segmap	segment.c	/^static int build_dirty_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
build_free_segmap	segment.c	/^static int build_free_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
build_lock	f2fs.h	/^	struct mutex build_lock;	\/* lock for build free nids *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::mutex
build_sit_entries	segment.c	/^static int build_sit_entries(struct f2fs_sb_info *sbi)$/;"	f	file:
build_sit_info	segment.c	/^static int build_sit_info(struct f2fs_sb_info *sbi)$/;"	f	file:
bytes_to_blks	data.c	/^static inline u64 bytes_to_blks(struct inode *inode, u64 bytes)$/;"	f	file:
cache_mem	f2fs.h	/^	unsigned long long base_mem, cache_mem, page_mem;$/;"	m	struct:f2fs_stat_info
cache_nat_entry	node.c	/^static void cache_nat_entry(struct f2fs_sb_info *sbi, nid_t nid,$/;"	f	file:
cached_en	f2fs.h	/^	struct extent_node *cached_en;	\/* recently accessed extent node *\/$/;"	m	struct:extent_tree	typeref:struct:extent_tree::extent_node
call_count	f2fs.h	/^	int prefree_count, call_count, cp_count, bg_cp_count;$/;"	m	struct:f2fs_stat_info
candidate_ratio	f2fs.h	/^	unsigned int candidate_ratio;		\/* candidate ratio *\/$/;"	m	struct:atgc_management
cbuf	f2fs.h	/^	struct compress_data *cbuf;	\/* virtual mapped address on cpages *\/$/;"	m	struct:compress_ctx	typeref:struct:compress_ctx::compress_data
cbuf	f2fs.h	/^	struct compress_data *cbuf;	\/* virtual mapped address on cpages *\/$/;"	m	struct:decompress_io_ctx	typeref:struct:decompress_io_ctx::compress_data
cdata	f2fs.h	/^	u8 cdata[];			\/* compressed data *\/$/;"	m	struct:compress_data
cf_name	f2fs.h	/^	struct fscrypt_str cf_name;$/;"	m	struct:f2fs_filename	typeref:struct:f2fs_filename::fscrypt_str
change_curseg	segment.c	/^static void change_curseg(struct f2fs_sb_info *sbi, int type, bool flush)$/;"	f	file:
chash	f2fs.h	/^	f2fs_hash_t chash;		\/* hash value of given file name *\/$/;"	m	struct:f2fs_inode_info
check_bg_victims	gc.c	/^static unsigned int check_bg_victims(struct f2fs_sb_info *sbi)$/;"	f	file:
check_block_count	segment.h	/^static inline int check_block_count(struct f2fs_sb_info *sbi,$/;"	f
check_ddm_sanity	segment.c	/^static bool check_ddm_sanity(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f	file:
check_direct_IO	data.c	/^static int check_direct_IO(struct inode *inode, struct iov_iter *iter,$/;"	f	file:
check_discarded_addr	segment.c	/^static void check_discarded_addr(block_t start_baddr, int offs, block_t target_addr){$/;"	f	file:
check_index_in_prev_nodes	recovery.c	/^static int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,$/;"	f	file:
check_inplace_update_policy	data.c	/^static inline bool check_inplace_update_policy(struct inode *inode,$/;"	f	file:
check_seg_range	segment.h	/^static inline void check_seg_range(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f
check_swap_activate	data.c	/^static int check_swap_activate(struct swap_info_struct *sis,$/;"	f	file:
check_swap_activate_fast	data.c	/^static int check_swap_activate_fast(struct swap_info_struct *sis,$/;"	f	file:
check_valid_map	gc.c	/^static int check_valid_map(struct f2fs_sb_info *sbi,$/;"	f	file:
check_zone_write_pointer	segment.c	/^static int check_zone_write_pointer(struct f2fs_sb_info *sbi,$/;"	f	file:
check_zone_write_pointer_args	segment.c	/^struct check_zone_write_pointer_args {$/;"	s	file:
check_zone_write_pointer_cb	segment.c	/^static int check_zone_write_pointer_cb(struct blk_zone *zone, unsigned int idx,$/;"	f	file:
chksum	f2fs.h	/^	__le32 chksum;			\/* compressed data chksum *\/$/;"	m	struct:compress_data
cic_entry_slab	compress.c	/^static struct kmem_cache *cic_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
ckpt	f2fs.h	/^	struct f2fs_checkpoint *ckpt;		\/* raw checkpoint pointer *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_checkpoint
ckpt_valid_blocks	segment.h	/^	unsigned int ckpt_valid_blocks:10;	\/* # of valid blocks last cp *\/$/;"	m	struct:seg_entry
ckpt_valid_map	segment.h	/^	unsigned char *ckpt_valid_map;	\/* validity bitmap of blocks last cp *\/$/;"	m	struct:seg_entry
clear_ckpt_flags	f2fs.h	/^static inline void clear_ckpt_flags(struct f2fs_sb_info *sbi, unsigned int f)$/;"	f
clear_cold_data	node.h	/^static inline void clear_cold_data(struct page *page)$/;"	f
clear_ddm_bitmap	segment.c	/^static void clear_ddm_bitmap(struct f2fs_sb_info *sbi, struct dynamic_discard_map *ddm, $/;"	f	file:
clear_file	f2fs.h	/^static inline void clear_file(struct inode *inode, int type)$/;"	f
clear_inline_node	node.h	/^static inline void clear_inline_node(struct page *page)$/;"	f
clear_inode_flag	f2fs.h	/^static inline void clear_inode_flag(struct inode *inode, int flag)$/;"	f
clear_node_page_dirty	node.c	/^static void clear_node_page_dirty(struct page *page)$/;"	f	file:
clear_opt	f2fs.h	102;"	d
clear_sbi_flag	f2fs.h	/^static inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)$/;"	f
clen	f2fs.h	/^	__le32 clen;			\/* compressed data size *\/$/;"	m	struct:compress_data
clen	f2fs.h	/^	size_t clen;			\/* valid data length in cbuf *\/$/;"	m	struct:compress_ctx
clen	f2fs.h	/^	size_t clen;			\/* valid data length in cbuf *\/$/;"	m	struct:decompress_io_ctx
clevel	f2fs.h	/^	unsigned int clevel;		\/* maximum level of given file name *\/$/;"	m	struct:f2fs_inode_info
cluster_idx	compress.c	/^static pgoff_t cluster_idx(struct compress_ctx *cc, pgoff_t index)$/;"	f	file:
cluster_idx	f2fs.h	/^	pgoff_t cluster_idx;		\/* cluster index number *\/$/;"	m	struct:compress_ctx
cluster_idx	f2fs.h	/^	pgoff_t cluster_idx;		\/* cluster index number *\/$/;"	m	struct:decompress_io_ctx
cluster_may_compress	compress.c	/^static bool cluster_may_compress(struct compress_ctx *cc)$/;"	f	file:
cluster_size	f2fs.h	/^	unsigned int cluster_size;	\/* page count in cluster *\/$/;"	m	struct:compress_ctx
cluster_size	f2fs.h	/^	unsigned int cluster_size;	\/* page count in cluster *\/$/;"	m	struct:decompress_io_ctx
cmd_lock	f2fs.h	/^	struct mutex cmd_lock;$/;"	m	struct:discard_cmd_control	typeref:struct:discard_cmd_control::mutex
cnt	f2fs.h	/^	unsigned int cnt; 			\/* valid number of discard range *\/$/;"	m	struct:discard_range_entry
commit_checkpoint	checkpoint.c	/^static void commit_checkpoint(struct f2fs_sb_info *sbi,$/;"	f	file:
compat_f2fs_gc_range	file.c	/^struct compat_f2fs_gc_range {$/;"	s	file:
compat_f2fs_move_range	file.c	/^struct compat_f2fs_move_range {$/;"	s	file:
compr_blocks	f2fs.h	/^	atomic64_t compr_blocks;		\/* # of compressed blocks *\/$/;"	m	struct:f2fs_sb_info
compr_blocks	f2fs.h	/^	int compr_blocks;	\/* # of compressed block addresses *\/$/;"	m	struct:f2fs_io_info
compr_blocks	f2fs.h	/^	unsigned long long compr_blocks;$/;"	m	struct:f2fs_stat_info
compr_inode	f2fs.h	/^	atomic_t compr_inode;			\/* # of compressed inodes *\/$/;"	m	struct:f2fs_sb_info
compr_inode	f2fs.h	/^	int compr_inode;$/;"	m	struct:f2fs_stat_info
compress_algorithm	f2fs.h	/^	unsigned char compress_algorithm;	\/* algorithm type *\/$/;"	m	struct:f2fs_mount_info
compress_algorithm_type	f2fs.h	/^enum compress_algorithm_type {$/;"	g
compress_chksum	f2fs.h	/^	bool compress_chksum;			\/* compressed data chksum *\/$/;"	m	struct:f2fs_mount_info
compress_ctx	f2fs.h	/^struct compress_ctx {$/;"	s
compress_data	f2fs.h	/^struct compress_data {$/;"	s
compress_ext_cnt	f2fs.h	/^	unsigned char compress_ext_cnt;		\/* extension count *\/$/;"	m	struct:f2fs_mount_info
compress_flag	f2fs.h	/^enum compress_flag {$/;"	g
compress_io_ctx	f2fs.h	/^struct compress_io_ctx {$/;"	s
compress_log_size	f2fs.h	/^	unsigned char compress_log_size;	\/* cluster log size *\/$/;"	m	struct:f2fs_mount_info
compress_mode	f2fs.h	/^	int compress_mode;			\/* compression mode *\/$/;"	m	struct:f2fs_mount_info
compress_page_pool	compress.c	/^static mempool_t *compress_page_pool;$/;"	v	file:
compress_pages	compress.c	/^	int (*compress_pages)(struct compress_ctx *cc);$/;"	m	struct:f2fs_compress_ops	file:
compressed_page	f2fs.h	/^	struct page *compressed_page;	\/* compressed page *\/$/;"	m	struct:f2fs_io_info	typeref:struct:f2fs_io_info::page
construct_ddm_journals	segment.c	/^static int construct_ddm_journals(struct f2fs_sb_info *sbi, struct dynamic_discard_map *ddm,$/;"	f	file:
copy_node_footer	node.h	/^static inline void copy_node_footer(struct page *dst, struct page *src)$/;"	f
copy_node_info	node.h	/^static inline void copy_node_info(struct node_info *dst,$/;"	f
count_bits	gc.c	/^static unsigned int count_bits(const unsigned long *addr,$/;"	f	file:
count_type	f2fs.h	/^enum count_type {$/;"	g
cp_control	f2fs.h	/^struct cp_control {$/;"	s
cp_count	f2fs.h	/^	int prefree_count, call_count, cp_count, bg_cp_count;$/;"	m	struct:f2fs_stat_info
cp_global_sem	f2fs.h	/^	struct rw_semaphore cp_global_sem;	\/* checkpoint procedure lock *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
cp_lock	f2fs.h	/^	spinlock_t cp_lock;			\/* for flag in ckpt *\/$/;"	m	struct:f2fs_sb_info
cp_reason_type	f2fs.h	/^enum cp_reason_type {$/;"	g
cp_rwsem	f2fs.h	/^	struct rw_semaphore cp_rwsem;		\/* blocking FS operations *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
cp_task	f2fs.h	/^	struct task_struct *cp_task;	\/* separate cp\/wb IO stats*\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::task_struct
cp_wait	f2fs.h	/^	wait_queue_head_t cp_wait;$/;"	m	struct:f2fs_sb_info
cpages	f2fs.h	/^	struct page **cpages;		\/* pages store compressed data in cluster *\/$/;"	m	struct:compress_ctx	typeref:struct:compress_ctx::page
cpages	f2fs.h	/^	struct page **cpages;		\/* pages store compressed data in cluster *\/$/;"	m	struct:decompress_io_ctx	typeref:struct:decompress_io_ctx::page
cpver_of_node	node.h	/^static inline __u64 cpver_of_node(struct page *node_page)$/;"	f
create_discard_cmd_control	segment.c	/^static int create_discard_cmd_control(struct f2fs_sb_info *sbi)$/;"	f	file:
create_dynamic_discard_map_control	segment.c	/^static int create_dynamic_discard_map_control(struct f2fs_sb_info *sbi)$/;"	f	file:
crypto_buf	f2fs.h	/^	struct fscrypt_str crypto_buf;$/;"	m	struct:f2fs_filename	typeref:struct:f2fs_filename::fscrypt_str
cur_cp_crc	f2fs.h	/^static inline __u64 cur_cp_crc(struct f2fs_checkpoint *cp)$/;"	f
cur_cp_pack	f2fs.h	/^	int cur_cp_pack;			\/* remain current cp pack *\/$/;"	m	struct:f2fs_sb_info
cur_cp_version	f2fs.h	/^static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)$/;"	f
cur_level	f2fs.h	/^	char cur_level;			\/* level of hole node page *\/$/;"	m	struct:dnode_of_data
cur_valid_map	segment.h	/^	unsigned char *cur_valid_map;	\/* validity bitmap of blocks *\/$/;"	m	struct:seg_entry
cur_valid_map_mir	segment.h	/^	unsigned char *cur_valid_map_mir;	\/* mirror of current valid bitmap *\/$/;"	m	struct:seg_entry
cur_victim_sec	f2fs.h	/^	unsigned int cur_victim_sec;		\/* current victim section num *\/$/;"	m	struct:f2fs_sb_info
current_nat_addr	node.h	/^static inline pgoff_t current_nat_addr(struct f2fs_sb_info *sbi, nid_t start)$/;"	f
current_reserved_blocks	f2fs.h	/^	block_t current_reserved_blocks;	\/* current reserved blocks *\/$/;"	m	struct:f2fs_sb_info
current_reserved_blocks	sysfs.c	/^F2FS_GENERAL_RO_ATTR(current_reserved_blocks);$/;"	v
current_reserved_blocks_show	sysfs.c	/^static ssize_t current_reserved_blocks_show(struct f2fs_attr *a,$/;"	f	file:
current_sit_addr	segment.h	/^static inline pgoff_t current_sit_addr(struct f2fs_sb_info *sbi,$/;"	f
cursec	f2fs.h	/^	int cursec[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
curseg	f2fs.h	/^	int curseg[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
curseg_alloc_type	segment.h	/^static inline unsigned char curseg_alloc_type(struct f2fs_sb_info *sbi,$/;"	f
curseg_array	f2fs.h	/^	struct curseg_info *curseg_array;	\/* active segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::curseg_info
curseg_blkoff	segment.h	/^static inline unsigned short curseg_blkoff(struct f2fs_sb_info *sbi, int type)$/;"	f
curseg_info	segment.h	/^struct curseg_info {$/;"	s
curseg_lock	f2fs.h	/^	struct rw_semaphore curseg_lock;	\/* for preventing curseg change *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::rw_semaphore
curseg_mutex	segment.h	/^	struct mutex curseg_mutex;		\/* lock for consistency *\/$/;"	m	struct:curseg_info	typeref:struct:curseg_info::mutex
curseg_segno	segment.h	/^static inline unsigned int curseg_segno(struct f2fs_sb_info *sbi,$/;"	f
curseg_zone_lock	f2fs.h	/^	struct rw_semaphore curseg_zone_lock;$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::rw_semaphore
curzone	f2fs.h	/^	int curzone[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
data_blkaddr	f2fs.h	/^	block_t	data_blkaddr;		\/* block address of the node block *\/$/;"	m	struct:dnode_of_data
data_blkaddr	f2fs.h	/^static inline block_t data_blkaddr(struct inode *inode,$/;"	f
data_blks	f2fs.h	/^	int tot_blks, data_blks, node_blks;$/;"	m	struct:f2fs_stat_info
data_io_flag	f2fs.h	/^	unsigned int data_io_flag;$/;"	m	struct:f2fs_sb_info
data_segs	f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
dc_map	f2fs.h	/^	unsigned char *dc_map;$/;"	m	struct:dynamic_discard_map
dcc_info	f2fs.h	/^	struct discard_cmd_control *dcc_info;$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::discard_cmd_control
ddm_list	f2fs.h	/^	struct list_head ddm_list; 			$/;"	m	struct:discard_range_entry	typeref:struct:discard_range_entry::list_head
ddm_list	f2fs.h	/^	struct list_head ddm_list;$/;"	m	struct:discard_entry	typeref:struct:discard_entry::list_head
ddm_lock	f2fs.h	/^	struct mutex ddm_lock;$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::mutex
ddmc_info	f2fs.h	/^	struct dynamic_discard_map_control *ddmc_info;$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::dynamic_discard_map_control
dec_page_count	f2fs.h	/^static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)$/;"	f
dec_valid_block_count	f2fs.h	/^static inline void dec_valid_block_count(struct f2fs_sb_info *sbi,$/;"	f
dec_valid_inode_count	f2fs.h	/^static inline void dec_valid_inode_count(struct f2fs_sb_info *sbi)$/;"	f
dec_valid_node_count	f2fs.h	/^static inline void dec_valid_node_count(struct f2fs_sb_info *sbi,$/;"	f
decompress_io_ctx	f2fs.h	/^struct decompress_io_ctx {$/;"	s
decompress_pages	compress.c	/^	int (*decompress_pages)(struct decompress_io_ctx *dic);$/;"	m	struct:f2fs_compress_ops	file:
decrease_sleep_time	gc.h	/^static inline void decrease_sleep_time(struct f2fs_gc_kthread *gc_th,$/;"	f
default_options	super.c	/^static void default_options(struct f2fs_sb_info *sbi)$/;"	f	file:
default_salloc_ops	segment.c	/^static const struct segment_allocation default_salloc_ops = {$/;"	v	typeref:struct:segment_allocation	file:
default_v_ops	gc.c	/^static const struct victim_selection default_v_ops = {$/;"	v	typeref:struct:victim_selection	file:
del_bio_entry	data.c	/^static void del_bio_entry(struct bio_entry *be)$/;"	f	file:
del_fsync_inode	recovery.c	/^static void del_fsync_inode(struct fsync_inode_entry *entry, int drop)$/;"	f	file:
dentry	f2fs.h	/^	struct f2fs_dir_entry *dentry;$/;"	m	struct:f2fs_dentry_ptr	typeref:struct:f2fs_dentry_ptr::f2fs_dir_entry
destroy_compress_ctx	compress.c	/^	void (*destroy_compress_ctx)(struct compress_ctx *cc);$/;"	m	struct:f2fs_compress_ops	file:
destroy_curseg	segment.c	/^static void destroy_curseg(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_decompress_ctx	compress.c	/^	void (*destroy_decompress_ctx)(struct decompress_io_ctx *dic);$/;"	m	struct:f2fs_compress_ops	file:
destroy_device_list	super.c	/^static void destroy_device_list(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_discard_cmd_control	segment.c	/^static void destroy_discard_cmd_control(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_dynamic_discard_map_control	segment.c	/^static void destroy_dynamic_discard_map_control(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_free_segmap	segment.c	/^static void destroy_free_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_fsync_dnodes	recovery.c	/^static void destroy_fsync_dnodes(struct list_head *head, int drop)$/;"	f	file:
destroy_inodecache	super.c	/^static void destroy_inodecache(void)$/;"	f	file:
destroy_percpu_info	super.c	/^static void destroy_percpu_info(struct f2fs_sb_info *sbi)$/;"	f	file:
destroy_sit_info	segment.c	/^static void destroy_sit_info(struct f2fs_sb_info *sbi)$/;"	f	file:
dev	super.c	/^	struct f2fs_dev_info *dev;$/;"	m	struct:f2fs_report_zones_args	typeref:struct:f2fs_report_zones_args::f2fs_dev_info	file:
dev_lock	f2fs.h	/^	spinlock_t dev_lock;			\/* protect dirty_device *\/$/;"	m	struct:f2fs_sb_info
devs	f2fs.h	/^	struct f2fs_dev_info *devs;		\/* for device list *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_dev_info
di	f2fs.h	/^		struct discard_info di;	\/* discard info *\/$/;"	m	union:discard_cmd::__anon17	typeref:struct:discard_cmd::__anon17::discard_info
dic_entry_slab	compress.c	/^static struct kmem_cache *dic_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
dir_block_index	dir.c	/^static unsigned long dir_block_index(unsigned int level,$/;"	f	file:
dir_blocks	dir.c	/^static unsigned long dir_blocks(struct inode *inode)$/;"	f	file:
dir_buckets	dir.c	/^static unsigned int dir_buckets(unsigned int level, int dir_level)$/;"	f	file:
dir_level	f2fs.h	/^	int dir_level;				\/* directory level *\/$/;"	m	struct:f2fs_sb_info
dirty_bitmap	segment.h	/^	unsigned long *dirty_bitmap;	\/* dirty segment\/section bitmap *\/$/;"	m	struct:victim_sel_policy
dirty_count	f2fs.h	/^	int dirty_count, node_pages, meta_pages;$/;"	m	struct:f2fs_stat_info
dirty_device	f2fs.h	/^	unsigned int dirty_device;		\/* for checkpoint data flush *\/$/;"	m	struct:f2fs_sb_info
dirty_device	f2fs.h	/^	unsigned int dirty_device;	\/* dirty device bitmap *\/$/;"	m	struct:ino_entry
dirty_head	f2fs.h	/^	struct list_head dirty_head;			\/* To save updated ddm. *\/$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::list_head
dirty_info	f2fs.h	/^	struct dirty_seglist_info *dirty_info;	\/* dirty segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::dirty_seglist_info
dirty_list	f2fs.h	/^	struct list_head dirty_list;	\/* dirty list for dirs and files *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::list_head
dirty_list	f2fs.h	/^	struct list_head dirty_list; 	\/* dirty list*\/$/;"	m	struct:dynamic_discard_map	typeref:struct:dynamic_discard_map::list_head
dirty_max_mtime	segment.h	/^	unsigned long long dirty_max_mtime;	\/* rerange candidates in GC_AT *\/$/;"	m	struct:sit_info
dirty_min_mtime	segment.h	/^	unsigned long long dirty_min_mtime;	\/* rerange candidates in GC_AT *\/$/;"	m	struct:sit_info
dirty_nats	f2fs.h	/^	int nats, dirty_nats, sits, dirty_sits;$/;"	m	struct:f2fs_stat_info
dirty_nats_ratio	f2fs.h	/^	unsigned int dirty_nats_ratio;	\/* control dirty nats ratio threshold *\/$/;"	m	struct:f2fs_nm_info
dirty_pages	f2fs.h	/^	atomic_t dirty_pages;		\/* # of dirty pages *\/$/;"	m	struct:f2fs_inode_info
dirty_secmap	segment.h	/^	unsigned long *dirty_secmap;$/;"	m	struct:dirty_seglist_info
dirty_seg	f2fs.h	/^	unsigned int dirty_seg[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
dirty_seglist_info	segment.h	/^struct dirty_seglist_info {$/;"	s
dirty_segmap	segment.h	/^	unsigned long *dirty_segmap[NR_DIRTY_TYPE];$/;"	m	struct:dirty_seglist_info
dirty_segments	segment.h	/^static inline unsigned int dirty_segments(struct f2fs_sb_info *sbi)$/;"	f
dirty_segments	sysfs.c	/^F2FS_GENERAL_RO_ATTR(dirty_segments);$/;"	v
dirty_segments_show	sysfs.c	/^static ssize_t dirty_segments_show(struct f2fs_attr *a,$/;"	f	file:
dirty_sentries	segment.h	/^	unsigned int dirty_sentries;		\/* # of dirty sentries *\/$/;"	m	struct:sit_info
dirty_sentries_bitmap	segment.h	/^	unsigned long *dirty_sentries_bitmap;	\/* bitmap for dirty sentries *\/$/;"	m	struct:sit_info
dirty_sits	f2fs.h	/^	int nats, dirty_nats, sits, dirty_sits;$/;"	m	struct:f2fs_stat_info
dirty_type	segment.h	/^enum dirty_type {$/;"	g
disable_nat_bits	f2fs.h	/^static inline void disable_nat_bits(struct f2fs_sb_info *sbi, bool lock)$/;"	f
discard_blks	f2fs.h	/^	block_t discard_blks;			\/* discard command candidats *\/$/;"	m	struct:f2fs_sb_info
discard_blks	f2fs.h	/^	unsigned int valid_count, valid_node_count, valid_inode_count, discard_blks;$/;"	m	struct:f2fs_stat_info
discard_blocks	f2fs.h	/^static inline block_t discard_blocks(struct f2fs_sb_info *sbi)$/;"	f
discard_cmd	f2fs.h	/^struct discard_cmd {$/;"	s
discard_cmd_cnt	f2fs.h	/^	atomic_t discard_cmd_cnt;		\/* # of cached cmd count *\/$/;"	m	struct:discard_cmd_control
discard_cmd_control	f2fs.h	/^struct discard_cmd_control {$/;"	s
discard_cmd_slab	segment.c	/^static struct kmem_cache *discard_cmd_slab;$/;"	v	typeref:struct:kmem_cache	file:
discard_entry	f2fs.h	/^struct discard_entry {$/;"	s
discard_entry_slab	segment.c	/^static struct kmem_cache *discard_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
discard_granularity	f2fs.h	/^	unsigned int discard_granularity;	\/* discard granularity *\/$/;"	m	struct:discard_cmd_control
discard_info	f2fs.h	/^struct discard_info {$/;"	s
discard_map	f2fs.h	/^	unsigned char discard_map[SIT_VBLOCK_MAP_SIZE];	\/* segment discard bitmap *\/$/;"	m	struct:discard_entry
discard_map	segment.h	/^	unsigned char *discard_map;$/;"	m	struct:seg_entry
discard_map_head	f2fs.h	/^	struct list_head discard_map_head;		\/* small discard journal list *\/$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::list_head
discard_map_slab	segment.c	/^static struct kmem_cache *discard_map_slab;$/;"	v	typeref:struct:kmem_cache	file:
discard_policy	f2fs.h	/^struct discard_policy {$/;"	s
discard_range	f2fs.h	/^struct discard_range{$/;"	s
discard_range_array	f2fs.h	/^	struct discard_range discard_range_array[DISCARD_RANGE_MAX_NUM];$/;"	m	struct:discard_range_entry	typeref:struct:discard_range_entry::discard_range
discard_range_entry	f2fs.h	/^struct discard_range_entry {$/;"	s
discard_range_head	f2fs.h	/^	struct list_head discard_range_head;		\/* long discard journal list *\/$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::list_head
discard_range_slab	segment.c	/^static struct kmem_cache *discard_range_slab;$/;"	v	typeref:struct:kmem_cache	file:
discard_wait_queue	f2fs.h	/^	wait_queue_head_t discard_wait_queue;	\/* waiting queue for wake-up *\/$/;"	m	struct:discard_cmd_control
discard_wake	f2fs.h	/^	unsigned int discard_wake;		\/* to wake up discard thread *\/$/;"	m	struct:discard_cmd_control
disk_name	f2fs.h	/^	struct fscrypt_str disk_name;$/;"	m	struct:f2fs_filename	typeref:struct:f2fs_filename::fscrypt_str
dispatch_list	f2fs.h	/^	struct llist_node *dispatch_list;	\/* list for command dispatch *\/$/;"	m	struct:flush_cmd_control	typeref:struct:flush_cmd_control::llist_node
dj_range_cnt	f2fs.h	/^	atomic_t dj_range_cnt;			\/* number of discard journal range *\/$/;"	m	struct:dynamic_discard_map_control
dj_seg_cnt	f2fs.h	/^	atomic_t dj_seg_cnt;			\/* number of segments for discard journal bitmap *\/$/;"	m	struct:dynamic_discard_map_control
dmap_journal_list	f2fs.h	/^	struct list_head dmap_journal_list;	\/* holding this ddm's discard bitmap journal *\/$/;"	m	struct:dynamic_discard_map	typeref:struct:dynamic_discard_map::list_head
dnode_of_data	f2fs.h	/^struct dnode_of_data {$/;"	s
do_checkpoint	checkpoint.c	/^static int do_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f	file:
do_convert_inline_dir	inline.c	/^static int do_convert_inline_dir(struct inode *dir, struct page *ipage,$/;"	f	file:
do_garbage_collect	gc.c	/^static int do_garbage_collect(struct f2fs_sb_info *sbi,$/;"	f	file:
do_read_inode	inode.c	/^static int do_read_inode(struct inode *inode)$/;"	f	file:
do_recover_data	recovery.c	/^static int do_recover_data(struct f2fs_sb_info *sbi, struct inode *inode,$/;"	f	file:
do_write_page	segment.c	/^static void do_write_page(struct f2fs_summary *sum, struct f2fs_io_info *fio)$/;"	f	file:
drange_entry_cnt	f2fs.h	/^	atomic_t drange_entry_cnt;$/;"	m	struct:dynamic_discard_map_control
drange_journal_list	f2fs.h	/^	struct list_head drange_journal_list; 	\/* holding this ddm's discard range journal*\/$/;"	m	struct:dynamic_discard_map	typeref:struct:dynamic_discard_map::list_head
dst_fd	file.c	/^	u32 dst_fd;$/;"	m	struct:compat_f2fs_move_range	file:
dummy_enc_policy	f2fs.h	/^	struct fscrypt_dummy_policy dummy_enc_policy; \/* test dummy encryption *\/$/;"	m	struct:f2fs_mount_info	typeref:struct:f2fs_mount_info::fscrypt_dummy_policy
dynamic_discard_map	f2fs.h	/^struct dynamic_discard_map {$/;"	s
dynamic_discard_map	f2fs.h	610;"	d
dynamic_discard_map_control	f2fs.h	/^struct dynamic_discard_map_control {$/;"	s
e_id	acl.h	/^	__le32 e_id;$/;"	m	struct:f2fs_acl_entry
e_name	xattr.h	/^	char    e_name[];      \/* attribute name *\/$/;"	m	struct:f2fs_xattr_entry
e_name_index	xattr.h	/^	__u8    e_name_index;$/;"	m	struct:f2fs_xattr_entry
e_name_len	xattr.h	/^	__u8    e_name_len;$/;"	m	struct:f2fs_xattr_entry
e_perm	acl.h	/^	__le16 e_perm;$/;"	m	struct:f2fs_acl_entry
e_perm	acl.h	/^	__le16 e_perm;$/;"	m	struct:f2fs_acl_entry_short
e_tag	acl.h	/^	__le16 e_tag;$/;"	m	struct:f2fs_acl_entry
e_tag	acl.h	/^	__le16 e_tag;$/;"	m	struct:f2fs_acl_entry_short
e_value_size	xattr.h	/^	__le16  e_value_size;   \/* size of attribute value *\/$/;"	m	struct:f2fs_xattr_entry
ei	f2fs.h	/^	struct extent_info ei;		\/* extent info *\/$/;"	m	struct:extent_node	typeref:struct:extent_node::extent_info
elapsed_time	segment.h	/^	unsigned long long elapsed_time;	\/* elapsed time after mount *\/$/;"	m	struct:sit_info
empty_nat_bits	f2fs.h	/^	unsigned char *empty_nat_bits;	\/* empty NAT pages *\/$/;"	m	struct:f2fs_nm_info
enabled_nat_bits	f2fs.h	/^static inline bool enabled_nat_bits(struct f2fs_sb_info *sbi,$/;"	f
enabled_steps	data.c	/^	unsigned int enabled_steps;$/;"	m	struct:bio_post_read_ctx	file:
encoding	sysfs.c	/^F2FS_GENERAL_RO_ATTR(encoding);$/;"	v
encoding_show	sysfs.c	/^static ssize_t encoding_show(struct f2fs_attr *a,$/;"	f	file:
encrypted	f2fs.h	/^	bool encrypted;		\/* indicate file is encrypted *\/$/;"	m	struct:f2fs_io_info
encrypted_page	f2fs.h	/^	struct page *encrypted_page;	\/* encrypted page *\/$/;"	m	struct:f2fs_io_info	typeref:struct:f2fs_io_info::page
end_blk	f2fs.h	/^	block_t end_blk;$/;"	m	struct:f2fs_dev_info
entry_cnt	node.h	/^	unsigned int entry_cnt;		\/* the # of nat entries in set *\/$/;"	m	struct:nat_entry_set
entry_cnt	segment.h	/^	unsigned int entry_cnt;		\/* the # of sit entries in set *\/$/;"	m	struct:sit_entry_set
entry_list	f2fs.h	/^	struct list_head entry_list;		\/* 4KB discard entry list *\/$/;"	m	struct:discard_cmd_control	typeref:struct:discard_cmd_control::list_head
entry_list	node.h	/^	struct list_head entry_list;	\/* link with dirty nat entries *\/$/;"	m	struct:nat_entry_set	typeref:struct:nat_entry_set::list_head
error	f2fs.h	/^	int error;			\/* bio error *\/$/;"	m	struct:discard_cmd
et	f2fs.h	/^	struct extent_tree *et;		\/* extent tree pointer *\/$/;"	m	struct:extent_node	typeref:struct:extent_node::extent_tree
excess_cached_nats	node.h	/^static inline bool excess_cached_nats(struct f2fs_sb_info *sbi)$/;"	f
excess_dirty_nats	node.h	/^static inline bool excess_dirty_nats(struct f2fs_sb_info *sbi)$/;"	f
excess_dirty_nodes	node.h	/^static inline bool excess_dirty_nodes(struct f2fs_sb_info *sbi)$/;"	f
excess_prefree_segs	segment.h	/^static inline bool excess_prefree_segs(struct f2fs_sb_info *sbi)$/;"	f
exit_f2fs_fs	super.c	/^static void __exit exit_f2fs_fs(void)$/;"	f	file:
expand_inode_data	file.c	/^static int expand_inode_data(struct inode *inode, loff_t offset,$/;"	f	file:
ext_node	f2fs.h	/^	int ext_tree, zombie_tree, ext_node;$/;"	m	struct:f2fs_stat_info
ext_tree	f2fs.h	/^	int ext_tree, zombie_tree, ext_node;$/;"	m	struct:f2fs_stat_info
extensions	f2fs.h	/^	unsigned char extensions[COMPRESS_EXT_NUM][F2FS_EXTENSION_LEN];	\/* extensions *\/$/;"	m	struct:f2fs_mount_info
extent_info	f2fs.h	/^struct extent_info {$/;"	s
extent_list	f2fs.h	/^	struct list_head extent_list;		\/* lru list for shrinker *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::list_head
extent_lock	f2fs.h	/^	spinlock_t extent_lock;			\/* locking extent lru list *\/$/;"	m	struct:f2fs_sb_info
extent_node	f2fs.h	/^struct extent_node {$/;"	s
extent_node_slab	extent_cache.c	/^static struct kmem_cache *extent_node_slab;$/;"	v	typeref:struct:kmem_cache	file:
extent_tree	f2fs.h	/^	struct extent_tree *extent_tree;	\/* cached extent_tree entry *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::extent_tree
extent_tree	f2fs.h	/^struct extent_tree {$/;"	s
extent_tree_lock	f2fs.h	/^	struct mutex extent_tree_lock;	\/* locking extent radix tree *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::mutex
extent_tree_root	f2fs.h	/^	struct radix_tree_root extent_tree_root;\/* cache extent cache entries *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::radix_tree_root
extent_tree_slab	extent_cache.c	/^static struct kmem_cache *extent_tree_slab;$/;"	v	typeref:struct:kmem_cache	file:
f2fs	sysfs.c	/^ATTRIBUTE_GROUPS(f2fs);$/;"	v
f2fs-y	Makefile	/^f2fs-y		:= dir.o file.o inode.o namei.o hash.o super.o inline.o$/;"	m
f2fs_acl_clone	acl.c	/^static struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,$/;"	f	file:
f2fs_acl_count	acl.c	/^static inline int f2fs_acl_count(size_t size)$/;"	f	file:
f2fs_acl_create	acl.c	/^static int f2fs_acl_create(struct inode *dir, umode_t *mode,$/;"	f	file:
f2fs_acl_create_masq	acl.c	/^static int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)$/;"	f	file:
f2fs_acl_entry	acl.h	/^struct f2fs_acl_entry {$/;"	s
f2fs_acl_entry_short	acl.h	/^struct f2fs_acl_entry_short {$/;"	s
f2fs_acl_from_disk	acl.c	/^static struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)$/;"	f	file:
f2fs_acl_header	acl.h	/^struct f2fs_acl_header {$/;"	s
f2fs_acl_size	acl.c	/^static inline size_t f2fs_acl_size(int count)$/;"	f	file:
f2fs_acl_to_disk	acl.c	/^static void *f2fs_acl_to_disk(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_acquire_orphan_inode	checkpoint.c	/^int f2fs_acquire_orphan_inode(struct f2fs_sb_info *sbi)$/;"	f
f2fs_add_dentry	dir.c	/^int f2fs_add_dentry(struct inode *dir, const struct f2fs_filename *fname,$/;"	f
f2fs_add_fsync_node_entry	node.c	/^static unsigned int f2fs_add_fsync_node_entry(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_add_inline_entries	inline.c	/^static int f2fs_add_inline_entries(struct inode *dir, void *inline_dentry)$/;"	f	file:
f2fs_add_inline_entry	inline.c	/^int f2fs_add_inline_entry(struct inode *dir, const struct f2fs_filename *fname,$/;"	f
f2fs_add_ino_entry	checkpoint.c	/^void f2fs_add_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)$/;"	f
f2fs_add_link	f2fs.h	/^static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)$/;"	f
f2fs_add_orphan_inode	checkpoint.c	/^void f2fs_add_orphan_inode(struct inode *inode)$/;"	f
f2fs_add_regular_entry	dir.c	/^int f2fs_add_regular_entry(struct inode *dir, const struct f2fs_filename *fname,$/;"	f
f2fs_alloc_dic	compress.c	/^struct decompress_io_ctx *f2fs_alloc_dic(struct compress_ctx *cc)$/;"	f
f2fs_alloc_inode	super.c	/^static struct inode *f2fs_alloc_inode(struct super_block *sb)$/;"	f	file:
f2fs_alloc_nid	node.c	/^bool f2fs_alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid)$/;"	f
f2fs_alloc_nid_done	node.c	/^void f2fs_alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
f2fs_alloc_nid_failed	node.c	/^void f2fs_alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
f2fs_allocate_data_block	segment.c	/^void f2fs_allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,$/;"	f
f2fs_allocate_new_segment	segment.c	/^void f2fs_allocate_new_segment(struct f2fs_sb_info *sbi, int type)$/;"	f
f2fs_allocate_new_segments	segment.c	/^void f2fs_allocate_new_segments(struct f2fs_sb_info *sbi)$/;"	f
f2fs_allocate_segment_for_resize	segment.c	/^void f2fs_allocate_segment_for_resize(struct f2fs_sb_info *sbi, int type,$/;"	f
f2fs_attr	sysfs.c	/^struct f2fs_attr {$/;"	s	file:
f2fs_attr_ops	sysfs.c	/^static const struct sysfs_ops f2fs_attr_ops = {$/;"	v	typeref:struct:sysfs_ops	file:
f2fs_attr_show	sysfs.c	/^static ssize_t f2fs_attr_show(struct kobject *kobj,$/;"	f	file:
f2fs_attr_store	sysfs.c	/^static ssize_t f2fs_attr_store(struct kobject *kobj, struct attribute *attr,$/;"	f	file:
f2fs_attrs	sysfs.c	/^static struct attribute *f2fs_attrs[] = {$/;"	v	typeref:struct:attribute	file:
f2fs_available_free_memory	node.c	/^bool f2fs_available_free_memory(struct f2fs_sb_info *sbi, int type)$/;"	f
f2fs_balance_fs	segment.c	/^void f2fs_balance_fs(struct f2fs_sb_info *sbi, bool need)$/;"	f
f2fs_balance_fs_bg	segment.c	/^void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi, bool from_bg)$/;"	f
f2fs_bdev_support_discard	f2fs.h	/^static inline bool f2fs_bdev_support_discard(struct block_device *bdev)$/;"	f
f2fs_begin_enable_verity	verity.c	/^static int f2fs_begin_enable_verity(struct file *filp)$/;"	f	file:
f2fs_bio_alloc	data.c	/^struct bio *f2fs_bio_alloc(struct f2fs_sb_info *sbi, int npages, bool noio)$/;"	f
f2fs_bio_info	f2fs.h	/^struct f2fs_bio_info {$/;"	s
f2fs_bio_post_read_required	data.c	/^static bool f2fs_bio_post_read_required(struct bio *bio)$/;"	f	file:
f2fs_bioset	data.c	/^static struct bio_set f2fs_bioset;$/;"	v	typeref:struct:bio_set	file:
f2fs_bitmap_size	segment.h	141;"	d
f2fs_blkz_is_seq	f2fs.h	/^static inline bool f2fs_blkz_is_seq(struct f2fs_sb_info *sbi, int devi,$/;"	f
f2fs_bmap	data.c	/^static sector_t f2fs_bmap(struct address_space *mapping, sector_t block)$/;"	f	file:
f2fs_bmap_compress	data.c	/^static sector_t f2fs_bmap_compress(struct inode *inode, sector_t block)$/;"	f	file:
f2fs_bug_on	f2fs.h	32;"	d
f2fs_bug_on	f2fs.h	34;"	d
f2fs_build_fault_attr	f2fs.h	4218;"	d
f2fs_build_fault_attr	super.c	/^void f2fs_build_fault_attr(struct f2fs_sb_info *sbi, unsigned int rate,$/;"	f
f2fs_build_free_nids	node.c	/^int f2fs_build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)$/;"	f
f2fs_build_gc_manager	gc.c	/^void f2fs_build_gc_manager(struct f2fs_sb_info *sbi)$/;"	f
f2fs_build_node_manager	node.c	/^int f2fs_build_node_manager(struct f2fs_sb_info *sbi)$/;"	f
f2fs_build_segment_manager	segment.c	/^int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)$/;"	f
f2fs_build_stats	debug.c	/^int f2fs_build_stats(struct f2fs_sb_info *sbi)$/;"	f
f2fs_build_stats	f2fs.h	/^static inline int f2fs_build_stats(struct f2fs_sb_info *sbi) { return 0; }$/;"	f
f2fs_build_trace_ios	trace.c	/^void f2fs_build_trace_ios(void)$/;"	f
f2fs_build_trace_ios	trace.h	39;"	d
f2fs_change_bit	f2fs.h	/^static inline void f2fs_change_bit(unsigned int nr, char *addr)$/;"	f
f2fs_check_nid_range	node.c	/^int f2fs_check_nid_range(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
f2fs_check_quota_options	super.c	/^static int f2fs_check_quota_options(struct f2fs_sb_info *sbi)$/;"	f	file:
f2fs_check_rb_tree_consistence	extent_cache.c	/^bool f2fs_check_rb_tree_consistence(struct f2fs_sb_info *sbi,$/;"	f
f2fs_check_write_pointer	segment.c	/^int f2fs_check_write_pointer(struct f2fs_sb_info *sbi)$/;"	f
f2fs_checkpoint_chksum	checkpoint.c	/^static __u32 f2fs_checkpoint_chksum(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_chksum	f2fs.h	/^static inline u32 f2fs_chksum(struct f2fs_sb_info *sbi, u32 crc,$/;"	f
f2fs_clear_bit	f2fs.h	/^static inline void f2fs_clear_bit(unsigned int nr, char *addr)$/;"	f
f2fs_clear_page_cache_dirty_tag	data.c	/^void f2fs_clear_page_cache_dirty_tag(struct page *page)$/;"	f
f2fs_clear_page_private	f2fs.h	/^static inline void f2fs_clear_page_private(struct page *page)$/;"	f
f2fs_clear_prefree_segments	segment.c	/^void f2fs_clear_prefree_segments(struct f2fs_sb_info *sbi,$/;"	f
f2fs_clear_qf_name	super.c	/^static int f2fs_clear_qf_name(struct super_block *sb, int qtype)$/;"	f	file:
f2fs_cluster_blocks	compress.c	/^static int f2fs_cluster_blocks(struct compress_ctx *cc)$/;"	f	file:
f2fs_cluster_can_merge_page	compress.c	/^bool f2fs_cluster_can_merge_page(struct compress_ctx *cc, pgoff_t index)$/;"	f
f2fs_cluster_is_empty	compress.c	/^bool f2fs_cluster_is_empty(struct compress_ctx *cc)$/;"	f
f2fs_cluster_is_full	compress.c	/^static bool f2fs_cluster_is_full(struct compress_ctx *cc)$/;"	f	file:
f2fs_collapse_range	file.c	/^static int f2fs_collapse_range(struct inode *inode, loff_t offset, loff_t len)$/;"	f	file:
f2fs_commit_inmem_pages	segment.c	/^int f2fs_commit_inmem_pages(struct inode *inode)$/;"	f
f2fs_commit_super	super.c	/^int f2fs_commit_super(struct f2fs_sb_info *sbi, bool recover)$/;"	f
f2fs_compat_ioc_gc_range	file.c	/^static int f2fs_compat_ioc_gc_range(struct file *file, unsigned long arg)$/;"	f	file:
f2fs_compat_ioc_move_range	file.c	/^static int f2fs_compat_ioc_move_range(struct file *file, unsigned long arg)$/;"	f	file:
f2fs_compat_ioctl	file.c	/^long f2fs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)$/;"	f
f2fs_compress_alloc_page	compress.c	/^static struct page *f2fs_compress_alloc_page(void)$/;"	f	file:
f2fs_compress_control_page	compress.c	/^struct page *f2fs_compress_control_page(struct page *page)$/;"	f
f2fs_compress_control_page	f2fs.h	/^static inline struct page *f2fs_compress_control_page(struct page *page)$/;"	f
f2fs_compress_ctx_add_page	compress.c	/^void f2fs_compress_ctx_add_page(struct compress_ctx *cc, struct page *page)$/;"	f
f2fs_compress_free_page	compress.c	/^static void f2fs_compress_free_page(struct page *page)$/;"	f	file:
f2fs_compress_ops	compress.c	/^struct f2fs_compress_ops {$/;"	s	file:
f2fs_compress_pages	compress.c	/^static int f2fs_compress_pages(struct compress_ctx *cc)$/;"	f	file:
f2fs_compress_write_end	compress.c	/^bool f2fs_compress_write_end(struct inode *inode, void *fsdata,$/;"	f
f2fs_compress_write_end_io	compress.c	/^void f2fs_compress_write_end_io(struct bio *bio, struct page *page)$/;"	f
f2fs_compressed_blocks	compress.c	/^static int f2fs_compressed_blocks(struct compress_ctx *cc)$/;"	f	file:
f2fs_compressed_file	f2fs.h	/^static inline int f2fs_compressed_file(struct inode *inode)$/;"	f
f2fs_convert_inline_inode	inline.c	/^int f2fs_convert_inline_inode(struct inode *inode)$/;"	f
f2fs_convert_inline_page	inline.c	/^int f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)$/;"	f
f2fs_cops	compress.c	/^static const struct f2fs_compress_ops *f2fs_cops[COMPRESS_MAX] = {$/;"	v	typeref:struct:f2fs_compress_ops	file:
f2fs_copy_page	f2fs.h	/^static inline void f2fs_copy_page(struct page *src, struct page *dst)$/;"	f
f2fs_cp_error	f2fs.h	/^static inline bool f2fs_cp_error(struct f2fs_sb_info *sbi)$/;"	f
f2fs_crc32	f2fs.h	/^static inline u32 f2fs_crc32(struct f2fs_sb_info *sbi, const void *address,$/;"	f
f2fs_crc_valid	f2fs.h	/^static inline bool f2fs_crc_valid(struct f2fs_sb_info *sbi, __u32 blk_crc,$/;"	f
f2fs_create	namei.c	/^static int f2fs_create(struct inode *dir, struct dentry *dentry, umode_t mode,$/;"	f	file:
f2fs_create_checkpoint_caches	checkpoint.c	/^int __init f2fs_create_checkpoint_caches(void)$/;"	f
f2fs_create_extent_cache	extent_cache.c	/^int __init f2fs_create_extent_cache(void)$/;"	f
f2fs_create_flush_cmd_control	segment.c	/^int f2fs_create_flush_cmd_control(struct f2fs_sb_info *sbi)$/;"	f
f2fs_create_garbage_collection_cache	gc.c	/^int __init f2fs_create_garbage_collection_cache(void)$/;"	f
f2fs_create_node_manager_caches	node.c	/^int __init f2fs_create_node_manager_caches(void)$/;"	f
f2fs_create_root_stats	debug.c	/^void __init f2fs_create_root_stats(void)$/;"	f
f2fs_create_root_stats	f2fs.h	/^static inline void __init f2fs_create_root_stats(void) { }$/;"	f
f2fs_create_segment_manager_caches	segment.c	/^int __init f2fs_create_segment_manager_caches(void)$/;"	f
f2fs_create_whiteout	namei.c	/^static int f2fs_create_whiteout(struct inode *dir, struct inode **whiteout)$/;"	f	file:
f2fs_cross_rename	namei.c	/^static int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,$/;"	f	file:
f2fs_crypt_mergeable_bio	data.c	/^static bool f2fs_crypt_mergeable_bio(struct bio *bio, const struct inode *inode,$/;"	f	file:
f2fs_cryptops	super.c	/^static const struct fscrypt_operations f2fs_cryptops = {$/;"	v	typeref:struct:fscrypt_operations	file:
f2fs_data_blkaddr	f2fs.h	/^static inline block_t f2fs_data_blkaddr(struct dnode_of_data *dn)$/;"	f
f2fs_dblock_aops	data.c	/^const struct address_space_operations f2fs_dblock_aops = {$/;"	v	typeref:struct:address_space_operations
f2fs_debug	f2fs.h	2128;"	d
f2fs_debugfs_root	debug.c	/^static struct dentry *f2fs_debugfs_root;$/;"	v	typeref:struct:dentry	file:
f2fs_decompress_bio	data.c	/^static void f2fs_decompress_bio(struct bio *bio, bool verity)$/;"	f	file:
f2fs_decompress_end_io	compress.c	/^void f2fs_decompress_end_io(struct page **rpages,$/;"	f
f2fs_decompress_pages	compress.c	/^void f2fs_decompress_pages(struct bio *bio, struct page *page, bool verity)$/;"	f
f2fs_decompress_work	data.c	/^static void f2fs_decompress_work(struct bio_post_read_ctx *ctx)$/;"	f	file:
f2fs_decrypt_work	data.c	/^static void f2fs_decrypt_work(struct bio_post_read_ctx *ctx)$/;"	f	file:
f2fs_defragment_range	file.c	/^static int f2fs_defragment_range(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_del_fsync_node_entry	node.c	/^void f2fs_del_fsync_node_entry(struct f2fs_sb_info *sbi, struct page *page)$/;"	f
f2fs_delete_entry	dir.c	/^void f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,$/;"	f
f2fs_delete_inline_entry	inline.c	/^void f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry, struct page *page,$/;"	f
f2fs_dentry_ptr	f2fs.h	/^struct f2fs_dentry_ptr {$/;"	s
f2fs_destroy_bio_entry_cache	data.c	/^void f2fs_destroy_bio_entry_cache(void)$/;"	f
f2fs_destroy_bioset	data.c	/^void f2fs_destroy_bioset(void)$/;"	f
f2fs_destroy_checkpoint_caches	checkpoint.c	/^void f2fs_destroy_checkpoint_caches(void)$/;"	f
f2fs_destroy_cic_cache	compress.c	/^static void f2fs_destroy_cic_cache(void)$/;"	f	file:
f2fs_destroy_compress_cache	compress.c	/^void f2fs_destroy_compress_cache(void)$/;"	f
f2fs_destroy_compress_cache	f2fs.h	/^static inline void f2fs_destroy_compress_cache(void) { }$/;"	f
f2fs_destroy_compress_ctx	compress.c	/^void f2fs_destroy_compress_ctx(struct compress_ctx *cc)$/;"	f
f2fs_destroy_compress_mempool	compress.c	/^void f2fs_destroy_compress_mempool(void)$/;"	f
f2fs_destroy_compress_mempool	f2fs.h	/^static inline void f2fs_destroy_compress_mempool(void) { }$/;"	f
f2fs_destroy_dic_cache	compress.c	/^static void f2fs_destroy_dic_cache(void)$/;"	f	file:
f2fs_destroy_extent_cache	extent_cache.c	/^void f2fs_destroy_extent_cache(void)$/;"	f
f2fs_destroy_extent_node	extent_cache.c	/^unsigned int f2fs_destroy_extent_node(struct inode *inode)$/;"	f
f2fs_destroy_extent_tree	extent_cache.c	/^void f2fs_destroy_extent_tree(struct inode *inode)$/;"	f
f2fs_destroy_flush_cmd_control	segment.c	/^void f2fs_destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free)$/;"	f
f2fs_destroy_garbage_collection_cache	gc.c	/^void f2fs_destroy_garbage_collection_cache(void)$/;"	f
f2fs_destroy_node_manager	node.c	/^void f2fs_destroy_node_manager(struct f2fs_sb_info *sbi)$/;"	f
f2fs_destroy_node_manager_caches	node.c	/^void f2fs_destroy_node_manager_caches(void)$/;"	f
f2fs_destroy_page_array_cache	compress.c	/^void f2fs_destroy_page_array_cache(struct f2fs_sb_info *sbi)$/;"	f
f2fs_destroy_page_array_cache	f2fs.h	/^static inline void f2fs_destroy_page_array_cache(struct f2fs_sb_info *sbi) { }$/;"	f
f2fs_destroy_post_read_processing	data.c	/^void f2fs_destroy_post_read_processing(void)$/;"	f
f2fs_destroy_post_read_wq	data.c	/^void f2fs_destroy_post_read_wq(struct f2fs_sb_info *sbi)$/;"	f
f2fs_destroy_root_stats	debug.c	/^void f2fs_destroy_root_stats(void)$/;"	f
f2fs_destroy_root_stats	f2fs.h	/^static inline void f2fs_destroy_root_stats(void) { }$/;"	f
f2fs_destroy_segment_manager	segment.c	/^void f2fs_destroy_segment_manager(struct f2fs_sb_info *sbi)$/;"	f
f2fs_destroy_segment_manager_caches	segment.c	/^void f2fs_destroy_segment_manager_caches(void)$/;"	f
f2fs_destroy_stats	debug.c	/^void f2fs_destroy_stats(struct f2fs_sb_info *sbi)$/;"	f
f2fs_destroy_stats	f2fs.h	/^static inline void f2fs_destroy_stats(struct f2fs_sb_info *sbi) { }$/;"	f
f2fs_destroy_trace_ios	trace.c	/^void f2fs_destroy_trace_ios(void)$/;"	f
f2fs_destroy_trace_ios	trace.h	40;"	d
f2fs_destroy_xattr_caches	xattr.c	/^void f2fs_destroy_xattr_caches(struct f2fs_sb_info *sbi)$/;"	f
f2fs_destroy_xattr_caches	xattr.h	/^static inline void f2fs_destroy_xattr_caches(struct f2fs_sb_info *sbi) { }$/;"	f
f2fs_dev_info	f2fs.h	/^struct f2fs_dev_info {$/;"	s
f2fs_dio_end_io	data.c	/^static void f2fs_dio_end_io(struct bio *bio)$/;"	f	file:
f2fs_dio_submit_bio	data.c	/^static void f2fs_dio_submit_bio(struct bio *bio, struct inode *inode,$/;"	f	file:
f2fs_dir_inode_operations	namei.c	/^const struct inode_operations f2fs_dir_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_dir_operations	dir.c	/^const struct file_operations f2fs_dir_operations = {$/;"	v	typeref:struct:file_operations
f2fs_direct_IO	data.c	/^static ssize_t f2fs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)$/;"	f	file:
f2fs_dirty_inode	super.c	/^static void f2fs_dirty_inode(struct inode *inode, int flags)$/;"	f	file:
f2fs_dirty_to_prefree	segment.c	/^void f2fs_dirty_to_prefree(struct f2fs_sb_info *sbi)$/;"	f
f2fs_disable_checkpoint	super.c	/^static int f2fs_disable_checkpoint(struct f2fs_sb_info *sbi)$/;"	f	file:
f2fs_disable_compressed_file	f2fs.h	/^static inline bool f2fs_disable_compressed_file(struct inode *inode)$/;"	f
f2fs_disable_cp_again	segment.c	/^int f2fs_disable_cp_again(struct f2fs_sb_info *sbi, block_t unusable)$/;"	f
f2fs_do_add_link	dir.c	/^int f2fs_do_add_link(struct inode *dir, const struct qstr *name,$/;"	f
f2fs_do_collapse	file.c	/^static int f2fs_do_collapse(struct inode *inode, loff_t offset, loff_t len)$/;"	f	file:
f2fs_do_make_empty_dir	dir.c	/^void f2fs_do_make_empty_dir(struct inode *inode, struct inode *parent,$/;"	f
f2fs_do_map_lock	data.c	/^void f2fs_do_map_lock(struct f2fs_sb_info *sbi, int flag, bool lock)$/;"	f
f2fs_do_read_inline_data	inline.c	/^void f2fs_do_read_inline_data(struct page *page, struct page *ipage)$/;"	f
f2fs_do_replace_block	segment.c	/^void f2fs_do_replace_block(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,$/;"	f
f2fs_do_sync_file	file.c	/^static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,$/;"	f	file:
f2fs_do_tmpfile	dir.c	/^int f2fs_do_tmpfile(struct inode *inode, struct inode *dir)$/;"	f
f2fs_do_truncate_blocks	file.c	/^int f2fs_do_truncate_blocks(struct inode *inode, u64 from, bool lock)$/;"	f
f2fs_do_write_data_page	data.c	/^int f2fs_do_write_data_page(struct f2fs_io_info *fio)$/;"	f
f2fs_do_write_meta_page	segment.c	/^void f2fs_do_write_meta_page(struct f2fs_sb_info *sbi, struct page *page,$/;"	f
f2fs_do_write_node_page	segment.c	/^void f2fs_do_write_node_page(unsigned int nid, struct f2fs_io_info *fio)$/;"	f
f2fs_do_zero_range	file.c	/^static int f2fs_do_zero_range(struct dnode_of_data *dn, pgoff_t start,$/;"	f	file:
f2fs_dquot_acquire	super.c	/^static int f2fs_dquot_acquire(struct dquot *dquot)$/;"	f	file:
f2fs_dquot_commit	super.c	/^static int f2fs_dquot_commit(struct dquot *dquot)$/;"	f	file:
f2fs_dquot_commit_info	super.c	/^static int f2fs_dquot_commit_info(struct super_block *sb, int type)$/;"	f	file:
f2fs_dquot_mark_dquot_dirty	super.c	/^static int f2fs_dquot_mark_dquot_dirty(struct dquot *dquot)$/;"	f	file:
f2fs_dquot_release	super.c	/^static int f2fs_dquot_release(struct dquot *dquot)$/;"	f	file:
f2fs_drop_discard_cmd	segment.c	/^void f2fs_drop_discard_cmd(struct f2fs_sb_info *sbi)$/;"	f
f2fs_drop_extent_tree	extent_cache.c	/^void f2fs_drop_extent_tree(struct inode *inode)$/;"	f
f2fs_drop_inmem_page	segment.c	/^void f2fs_drop_inmem_page(struct inode *inode, struct page *page)$/;"	f
f2fs_drop_inmem_pages	segment.c	/^void f2fs_drop_inmem_pages(struct inode *inode)$/;"	f
f2fs_drop_inmem_pages_all	segment.c	/^void f2fs_drop_inmem_pages_all(struct f2fs_sb_info *sbi, bool gc_failure)$/;"	f
f2fs_drop_inode	super.c	/^static int f2fs_drop_inode(struct inode *inode)$/;"	f	file:
f2fs_drop_nlink	dir.c	/^void f2fs_drop_nlink(struct inode *dir, struct inode *inode)$/;"	f
f2fs_drop_rpages	compress.c	/^static void f2fs_drop_rpages(struct compress_ctx *cc, int len, bool unlock)$/;"	f	file:
f2fs_empty_dir	dir.c	/^bool f2fs_empty_dir(struct inode *dir)$/;"	f
f2fs_empty_inline_dir	inline.c	/^bool f2fs_empty_inline_dir(struct inode *dir)$/;"	f
f2fs_enable_checkpoint	super.c	/^static void f2fs_enable_checkpoint(struct f2fs_sb_info *sbi)$/;"	f	file:
f2fs_enable_inode_chksum	inode.c	/^static bool f2fs_enable_inode_chksum(struct f2fs_sb_info *sbi, struct page *page)$/;"	f	file:
f2fs_enable_quota_files	super.c	/^int f2fs_enable_quota_files(struct f2fs_sb_info *sbi, bool rdonly)$/;"	f
f2fs_enable_quotas	super.c	/^static int f2fs_enable_quotas(struct super_block *sb)$/;"	f	file:
f2fs_encrypt_one_page	data.c	/^int f2fs_encrypt_one_page(struct f2fs_io_info *fio)$/;"	f
f2fs_encrypted_file	f2fs.h	/^static inline bool f2fs_encrypted_file(struct inode *inode)$/;"	f
f2fs_encrypted_get_link	namei.c	/^static const char *f2fs_encrypted_get_link(struct dentry *dentry,$/;"	f	file:
f2fs_encrypted_symlink_inode_operations	namei.c	/^const struct inode_operations f2fs_encrypted_symlink_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_end_enable_verity	verity.c	/^static int f2fs_end_enable_verity(struct file *filp, const void *desc,$/;"	f	file:
f2fs_enqueue_post_read_work	data.c	/^static void f2fs_enqueue_post_read_work(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_err	f2fs.h	2120;"	d
f2fs_evict_inode	inode.c	/^void f2fs_evict_inode(struct inode *inode)$/;"	f
f2fs_exist_data	f2fs.h	/^static inline int f2fs_exist_data(struct inode *inode)$/;"	f
f2fs_exist_trim_candidates	segment.c	/^bool f2fs_exist_trim_candidates(struct f2fs_sb_info *sbi,$/;"	f
f2fs_exist_written_data	checkpoint.c	/^bool f2fs_exist_written_data(struct f2fs_sb_info *sbi, nid_t ino, int mode)$/;"	f
f2fs_exit_sysfs	sysfs.c	/^void f2fs_exit_sysfs(void)$/;"	f
f2fs_export_ops	super.c	/^static const struct export_operations f2fs_export_ops = {$/;"	v	typeref:struct:export_operations	file:
f2fs_fallocate	file.c	/^static long f2fs_fallocate(struct file *file, int mode,$/;"	f	file:
f2fs_fault_info	f2fs.h	/^struct f2fs_fault_info {$/;"	s
f2fs_fault_name	super.c	/^const char *f2fs_fault_name[FAULT_MAX] = {$/;"	v
f2fs_feat	sysfs.c	/^ATTRIBUTE_GROUPS(f2fs_feat);$/;"	v
f2fs_feat	sysfs.c	/^static struct kobject f2fs_feat = {$/;"	v	typeref:struct:kobject	file:
f2fs_feat_attrs	sysfs.c	/^static struct attribute *f2fs_feat_attrs[] = {$/;"	v	typeref:struct:attribute	file:
f2fs_feat_ktype	sysfs.c	/^static struct kobj_type f2fs_feat_ktype = {$/;"	v	typeref:struct:kobj_type	file:
f2fs_feature_show	sysfs.c	/^static ssize_t f2fs_feature_show(struct f2fs_attr *a,$/;"	f	file:
f2fs_fh_to_dentry	super.c	/^static struct dentry *f2fs_fh_to_dentry(struct super_block *sb, struct fid *fid,$/;"	f	file:
f2fs_fh_to_parent	super.c	/^static struct dentry *f2fs_fh_to_parent(struct super_block *sb, struct fid *fid,$/;"	f	file:
f2fs_fiemap	data.c	/^int f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,$/;"	f
f2fs_file_flush	file.c	/^static int f2fs_file_flush(struct file *file, fl_owner_t id)$/;"	f	file:
f2fs_file_inode_operations	file.c	/^const struct inode_operations f2fs_file_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_file_mmap	file.c	/^static int f2fs_file_mmap(struct file *file, struct vm_area_struct *vma)$/;"	f	file:
f2fs_file_open	file.c	/^static int f2fs_file_open(struct inode *inode, struct file *filp)$/;"	f	file:
f2fs_file_operations	file.c	/^const struct file_operations f2fs_file_operations = {$/;"	v	typeref:struct:file_operations
f2fs_file_read_iter	file.c	/^static ssize_t f2fs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)$/;"	f	file:
f2fs_file_vm_ops	file.c	/^static const struct vm_operations_struct f2fs_file_vm_ops = {$/;"	v	typeref:struct:vm_operations_struct	file:
f2fs_file_write_iter	file.c	/^static ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)$/;"	f	file:
f2fs_filemap_fault	file.c	/^static vm_fault_t f2fs_filemap_fault(struct vm_fault *vmf)$/;"	f	file:
f2fs_filename	f2fs.h	/^struct f2fs_filename {$/;"	s
f2fs_filetype_table	dir.c	/^static unsigned char f2fs_filetype_table[F2FS_FT_MAX] = {$/;"	v	file:
f2fs_fill_dentries	dir.c	/^int f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,$/;"	f
f2fs_fill_fsxattr	file.c	/^static void f2fs_fill_fsxattr(struct inode *inode, struct fsxattr *fa)$/;"	f	file:
f2fs_fill_super	super.c	/^static int f2fs_fill_super(struct super_block *sb, void *data, int silent)$/;"	f	file:
f2fs_find_data_page	data.c	/^struct page *f2fs_find_data_page(struct inode *inode, pgoff_t index)$/;"	f
f2fs_find_entry	dir.c	/^struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,$/;"	f
f2fs_find_in_inline_dir	inline.c	/^struct f2fs_dir_entry *f2fs_find_in_inline_dir(struct inode *dir,$/;"	f
f2fs_find_target_dentry	dir.c	/^struct f2fs_dir_entry *f2fs_find_target_dentry(const struct f2fs_dentry_ptr *d,$/;"	f
f2fs_fix_curseg_write_pointer	segment.c	/^int f2fs_fix_curseg_write_pointer(struct f2fs_sb_info *sbi)$/;"	f
f2fs_flush_device_cache	segment.c	/^int f2fs_flush_device_cache(struct f2fs_sb_info *sbi)$/;"	f
f2fs_flush_inline_data	node.c	/^void f2fs_flush_inline_data(struct f2fs_sb_info *sbi)$/;"	f
f2fs_flush_merged_writes	data.c	/^void f2fs_flush_merged_writes(struct f2fs_sb_info *sbi)$/;"	f
f2fs_flush_nat_entries	node.c	/^int f2fs_flush_nat_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f
f2fs_flush_sit_entries	segment.c	/^void f2fs_flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f
f2fs_force_buffered_io	f2fs.h	/^static inline bool f2fs_force_buffered_io(struct inode *inode,$/;"	f
f2fs_free_dic	compress.c	/^void f2fs_free_dic(struct decompress_io_ctx *dic)$/;"	f
f2fs_free_filename	dir.c	/^void f2fs_free_filename(struct f2fs_filename *fname)$/;"	f
f2fs_free_inode	super.c	/^static void f2fs_free_inode(struct inode *inode)$/;"	f	file:
f2fs_freeze	super.c	/^static int f2fs_freeze(struct super_block *sb)$/;"	f	file:
f2fs_fs_type	super.c	/^static struct file_system_type f2fs_fs_type = {$/;"	v	typeref:struct:file_system_type	file:
f2fs_fsflags_map	file.c	/^} f2fs_fsflags_map[] = {$/;"	v	typeref:struct:__anon1	file:
f2fs_fsflags_to_iflags	file.c	/^static inline u32 f2fs_fsflags_to_iflags(u32 fsflags)$/;"	f	file:
f2fs_fsync_node_pages	node.c	/^int f2fs_fsync_node_pages(struct f2fs_sb_info *sbi, struct inode *inode,$/;"	f
f2fs_gc	gc.c	/^int f2fs_gc(struct f2fs_sb_info *sbi, bool sync,$/;"	f
f2fs_gc_kthread	gc.h	/^struct f2fs_gc_kthread {$/;"	s
f2fs_gc_task	gc.h	/^	struct task_struct *f2fs_gc_task;$/;"	m	struct:f2fs_gc_kthread	typeref:struct:f2fs_gc_kthread::task_struct
f2fs_get_acl	acl.c	/^struct posix_acl *f2fs_get_acl(struct inode *inode, int type)$/;"	f
f2fs_get_acl	acl.h	41;"	d
f2fs_get_block	data.c	/^int f2fs_get_block(struct dnode_of_data *dn, pgoff_t index)$/;"	f
f2fs_get_compress_blocks	file.c	/^static int f2fs_get_compress_blocks(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_get_context	super.c	/^static int f2fs_get_context(struct inode *inode, void *ctx, size_t len)$/;"	f	file:
f2fs_get_de_type	dir.c	/^unsigned char f2fs_get_de_type(struct f2fs_dir_entry *de)$/;"	f
f2fs_get_devices	super.c	/^static void f2fs_get_devices(struct super_block *sb,$/;"	f	file:
f2fs_get_dnode_of_data	node.c	/^int f2fs_get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)$/;"	f
f2fs_get_dquots	super.c	/^static struct dquot **f2fs_get_dquots(struct inode *inode)$/;"	f	file:
f2fs_get_dummy_policy	super.c	/^static const union fscrypt_policy *f2fs_get_dummy_policy(struct super_block *sb)$/;"	f	file:
f2fs_get_ino_and_lblk_bits	super.c	/^static void f2fs_get_ino_and_lblk_bits(struct super_block *sb,$/;"	f	file:
f2fs_get_inode_mode	f2fs.h	3118;"	d
f2fs_get_link	namei.c	/^static const char *f2fs_get_link(struct dentry *dentry,$/;"	f	file:
f2fs_get_lock_data_page	data.c	/^struct page *f2fs_get_lock_data_page(struct inode *inode, pgoff_t index,$/;"	f
f2fs_get_meta_page	checkpoint.c	/^struct page *f2fs_get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
f2fs_get_meta_page_retry	checkpoint.c	/^struct page *f2fs_get_meta_page_retry(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
f2fs_get_new_data_page	data.c	/^struct page *f2fs_get_new_data_page(struct inode *inode,$/;"	f
f2fs_get_next_page_offset	node.c	/^pgoff_t f2fs_get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs)$/;"	f
f2fs_get_node_info	node.c	/^int f2fs_get_node_info(struct f2fs_sb_info *sbi, nid_t nid,$/;"	f
f2fs_get_node_page	node.c	/^struct page *f2fs_get_node_page(struct f2fs_sb_info *sbi, pgoff_t nid)$/;"	f
f2fs_get_node_page_ra	node.c	/^struct page *f2fs_get_node_page_ra(struct page *parent, int start)$/;"	f
f2fs_get_num_devices	super.c	/^static int f2fs_get_num_devices(struct super_block *sb)$/;"	f	file:
f2fs_get_parent	namei.c	/^struct dentry *f2fs_get_parent(struct dentry *child)$/;"	f
f2fs_get_projid	super.c	/^static int f2fs_get_projid(struct inode *inode, kprojid_t *projid)$/;"	f	file:
f2fs_get_read_data_page	data.c	/^struct page *f2fs_get_read_data_page(struct inode *inode, pgoff_t index,$/;"	f
f2fs_get_reserved_space	super.c	/^static qsize_t *f2fs_get_reserved_space(struct inode *inode)$/;"	f	file:
f2fs_get_sectors_written	checkpoint.c	/^u64 f2fs_get_sectors_written(struct f2fs_sb_info *sbi)$/;"	f
f2fs_get_sum_page	segment.c	/^struct page *f2fs_get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f
f2fs_get_tmp_page	checkpoint.c	/^struct page *f2fs_get_tmp_page(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
f2fs_get_unusable_blocks	segment.c	/^block_t f2fs_get_unusable_blocks(struct f2fs_sb_info *sbi)$/;"	f
f2fs_get_valid_checkpoint	checkpoint.c	/^int f2fs_get_valid_checkpoint(struct f2fs_sb_info *sbi)$/;"	f
f2fs_get_verity_descriptor	verity.c	/^static int f2fs_get_verity_descriptor(struct inode *inode, void *buf,$/;"	f	file:
f2fs_getattr	file.c	/^int f2fs_getattr(const struct path *path, struct kstat *stat,$/;"	f
f2fs_getxattr	xattr.c	/^int f2fs_getxattr(struct inode *inode, int index, const char *name,$/;"	f
f2fs_getxattr	xattr.h	/^static inline int f2fs_getxattr(struct inode *inode, int index,$/;"	f
f2fs_grab_cache_page	f2fs.h	/^static inline struct page *f2fs_grab_cache_page(struct address_space *mapping,$/;"	f
f2fs_grab_meta_page	checkpoint.c	/^struct page *f2fs_grab_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
f2fs_grab_read_bio	data.c	/^static struct bio *f2fs_grab_read_bio(struct inode *inode, block_t blkaddr,$/;"	f	file:
f2fs_handle_failed_inode	inode.c	/^void f2fs_handle_failed_inode(struct inode *inode)$/;"	f
f2fs_has_enough_room	dir.c	/^bool f2fs_has_enough_room(struct inode *dir, struct page *ipage,$/;"	f
f2fs_has_extra_attr	f2fs.h	/^static inline int f2fs_has_extra_attr(struct inode *inode)$/;"	f
f2fs_has_inline_data	f2fs.h	/^static inline int f2fs_has_inline_data(struct inode *inode)$/;"	f
f2fs_has_inline_dentry	f2fs.h	/^static inline int f2fs_has_inline_dentry(struct inode *inode)$/;"	f
f2fs_has_inline_dots	f2fs.h	/^static inline int f2fs_has_inline_dots(struct inode *inode)$/;"	f
f2fs_has_inline_xattr	f2fs.h	/^static inline int f2fs_has_inline_xattr(struct inode *inode)$/;"	f
f2fs_has_stable_inodes	super.c	/^static bool f2fs_has_stable_inodes(struct super_block *sb)$/;"	f	file:
f2fs_has_xattr_block	f2fs.h	/^static inline bool f2fs_has_xattr_block(unsigned int ofs)$/;"	f
f2fs_hash_filename	hash.c	/^void f2fs_hash_filename(const struct inode *dir, struct f2fs_filename *fname)$/;"	f
f2fs_hw_is_readonly	f2fs.h	/^static inline bool f2fs_hw_is_readonly(struct f2fs_sb_info *sbi)$/;"	f
f2fs_hw_should_discard	f2fs.h	/^static inline bool f2fs_hw_should_discard(struct f2fs_sb_info *sbi)$/;"	f
f2fs_hw_support_discard	f2fs.h	/^static inline bool f2fs_hw_support_discard(struct f2fs_sb_info *sbi)$/;"	f
f2fs_i_blocks_write	f2fs.h	/^static inline void f2fs_i_blocks_write(struct inode *inode,$/;"	f
f2fs_i_compr_blocks_update	f2fs.h	/^static inline void f2fs_i_compr_blocks_update(struct inode *inode,$/;"	f
f2fs_i_depth_write	f2fs.h	/^static inline void f2fs_i_depth_write(struct inode *inode, unsigned int depth)$/;"	f
f2fs_i_gc_failures_write	f2fs.h	/^static inline void f2fs_i_gc_failures_write(struct inode *inode,$/;"	f
f2fs_i_links_write	f2fs.h	/^static inline void f2fs_i_links_write(struct inode *inode, bool inc)$/;"	f
f2fs_i_pino_write	f2fs.h	/^static inline void f2fs_i_pino_write(struct inode *inode, nid_t pino)$/;"	f
f2fs_i_size_write	f2fs.h	/^static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)$/;"	f
f2fs_i_xnid_write	f2fs.h	/^static inline void f2fs_i_xnid_write(struct inode *inode, nid_t xnid)$/;"	f
f2fs_iflags_to_fsflags	file.c	/^static inline u32 f2fs_iflags_to_fsflags(u32 iflags)$/;"	f	file:
f2fs_iflags_to_xflags	file.c	/^static inline u32 f2fs_iflags_to_xflags(u32 iflags)$/;"	f	file:
f2fs_iget	inode.c	/^struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)$/;"	f
f2fs_iget_retry	inode.c	/^struct inode *f2fs_iget_retry(struct super_block *sb, unsigned long ino)$/;"	f
f2fs_in_warm_node_list	node.c	/^bool f2fs_in_warm_node_list(struct f2fs_sb_info *sbi, struct page *page)$/;"	f
f2fs_info	f2fs.h	2126;"	d
f2fs_init_acl	acl.c	/^int f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,$/;"	f
f2fs_init_acl	acl.h	/^static inline int f2fs_init_acl(struct inode *inode, struct inode *dir,$/;"	f
f2fs_init_bio_entry_cache	data.c	/^int __init f2fs_init_bio_entry_cache(void)$/;"	f
f2fs_init_bioset	data.c	/^int __init f2fs_init_bioset(void)$/;"	f
f2fs_init_casefolded_name	dir.c	/^int f2fs_init_casefolded_name(const struct inode *dir,$/;"	f
f2fs_init_cic_cache	compress.c	/^static int __init f2fs_init_cic_cache(void)$/;"	f	file:
f2fs_init_compress_cache	compress.c	/^int __init f2fs_init_compress_cache(void)$/;"	f
f2fs_init_compress_cache	f2fs.h	/^static inline int __init f2fs_init_compress_cache(void) { return 0; }$/;"	f
f2fs_init_compress_ctx	compress.c	/^int f2fs_init_compress_ctx(struct compress_ctx *cc)$/;"	f
f2fs_init_compress_mempool	compress.c	/^int f2fs_init_compress_mempool(void)$/;"	f
f2fs_init_compress_mempool	f2fs.h	/^static inline int f2fs_init_compress_mempool(void) { return 0; }$/;"	f
f2fs_init_dic_cache	compress.c	/^static int __init f2fs_init_dic_cache(void)$/;"	f	file:
f2fs_init_extent_cache_info	extent_cache.c	/^void f2fs_init_extent_cache_info(struct f2fs_sb_info *sbi)$/;"	f
f2fs_init_extent_tree	extent_cache.c	/^void f2fs_init_extent_tree(struct inode *inode, struct page *ipage)$/;"	f
f2fs_init_fsync_node_info	node.c	/^void f2fs_init_fsync_node_info(struct f2fs_sb_info *sbi)$/;"	f
f2fs_init_inmem_curseg	segment.c	/^void f2fs_init_inmem_curseg(struct f2fs_sb_info *sbi)$/;"	f
f2fs_init_ino_entry_info	checkpoint.c	/^void f2fs_init_ino_entry_info(struct f2fs_sb_info *sbi)$/;"	f
f2fs_init_inode_metadata	dir.c	/^struct page *f2fs_init_inode_metadata(struct inode *inode, struct inode *dir,$/;"	f
f2fs_init_page_array_cache	compress.c	/^int f2fs_init_page_array_cache(struct f2fs_sb_info *sbi)$/;"	f
f2fs_init_page_array_cache	f2fs.h	/^static inline int f2fs_init_page_array_cache(struct f2fs_sb_info *sbi) { return 0; }$/;"	f
f2fs_init_post_read_processing	data.c	/^int __init f2fs_init_post_read_processing(void)$/;"	f
f2fs_init_post_read_wq	data.c	/^int f2fs_init_post_read_wq(struct f2fs_sb_info *sbi)$/;"	f
f2fs_init_security	xattr.c	/^int f2fs_init_security(struct inode *inode, struct inode *dir,$/;"	f
f2fs_init_security	xattr.h	/^static inline int f2fs_init_security(struct inode *inode, struct inode *dir,$/;"	f
f2fs_init_sysfs	sysfs.c	/^int __init f2fs_init_sysfs(void)$/;"	f
f2fs_init_xattr_caches	xattr.c	/^int f2fs_init_xattr_caches(struct f2fs_sb_info *sbi)$/;"	f
f2fs_init_xattr_caches	xattr.h	/^static inline int f2fs_init_xattr_caches(struct f2fs_sb_info *sbi) { return 0; }$/;"	f
f2fs_initxattrs	xattr.c	/^static int f2fs_initxattrs(struct inode *inode, const struct xattr *xattr_array,$/;"	f	file:
f2fs_inline_data_fiemap	inline.c	/^int f2fs_inline_data_fiemap(struct inode *inode,$/;"	f
f2fs_inode_by_name	dir.c	/^ino_t f2fs_inode_by_name(struct inode *dir, const struct qstr *qstr,$/;"	f
f2fs_inode_cachep	super.c	/^static struct kmem_cache *f2fs_inode_cachep;$/;"	v	typeref:struct:kmem_cache	file:
f2fs_inode_chksum	inode.c	/^static __u32 f2fs_inode_chksum(struct f2fs_sb_info *sbi, struct page *page)$/;"	f	file:
f2fs_inode_chksum_set	inode.c	/^void f2fs_inode_chksum_set(struct f2fs_sb_info *sbi, struct page *page)$/;"	f
f2fs_inode_chksum_verify	inode.c	/^bool f2fs_inode_chksum_verify(struct f2fs_sb_info *sbi, struct page *page)$/;"	f
f2fs_inode_dirtied	super.c	/^int f2fs_inode_dirtied(struct inode *inode, bool sync)$/;"	f
f2fs_inode_entry_slab	checkpoint.c	/^struct kmem_cache *f2fs_inode_entry_slab;$/;"	v	typeref:struct:kmem_cache
f2fs_inode_info	f2fs.h	/^struct f2fs_inode_info {$/;"	s
f2fs_inode_synced	super.c	/^void f2fs_inode_synced(struct inode *inode)$/;"	f
f2fs_inplace_write_data	segment.c	/^int f2fs_inplace_write_data(struct f2fs_io_info *fio)$/;"	f
f2fs_insert_range	file.c	/^static int f2fs_insert_range(struct inode *inode, loff_t offset, loff_t len)$/;"	f	file:
f2fs_invalidate_blocks	segment.c	/^void f2fs_invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)$/;"	f
f2fs_invalidate_page	data.c	/^void f2fs_invalidate_page(struct page *page, unsigned int offset,$/;"	f
f2fs_io_info	f2fs.h	/^struct f2fs_io_info {$/;"	s
f2fs_io_type_to_rw_hint	segment.c	/^enum rw_hint f2fs_io_type_to_rw_hint(struct f2fs_sb_info *sbi,$/;"	f
f2fs_ioc_abort_volatile_write	file.c	/^static int f2fs_ioc_abort_volatile_write(struct file *filp)$/;"	f	file:
f2fs_ioc_add_encryption_key	file.c	/^static int f2fs_ioc_add_encryption_key(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_commit_atomic_write	file.c	/^static int f2fs_ioc_commit_atomic_write(struct file *filp)$/;"	f	file:
f2fs_ioc_compress_file	file.c	/^static int f2fs_ioc_compress_file(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_decompress_file	file.c	/^static int f2fs_ioc_decompress_file(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_defragment	file.c	/^static int f2fs_ioc_defragment(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_enable_verity	file.c	/^static int f2fs_ioc_enable_verity(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_fitrim	file.c	/^static int f2fs_ioc_fitrim(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_flush_device	file.c	/^static int f2fs_ioc_flush_device(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_fsgetxattr	file.c	/^static int f2fs_ioc_fsgetxattr(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_fssetxattr	file.c	/^static int f2fs_ioc_fssetxattr(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_gc	file.c	/^static int f2fs_ioc_gc(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_gc_range	file.c	/^static int f2fs_ioc_gc_range(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_get_compress_option	file.c	/^static int f2fs_ioc_get_compress_option(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_get_encryption_key_status	file.c	/^static int f2fs_ioc_get_encryption_key_status(struct file *filp,$/;"	f	file:
f2fs_ioc_get_encryption_nonce	file.c	/^static int f2fs_ioc_get_encryption_nonce(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_get_encryption_policy	file.c	/^static int f2fs_ioc_get_encryption_policy(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_get_encryption_policy_ex	file.c	/^static int f2fs_ioc_get_encryption_policy_ex(struct file *filp,$/;"	f	file:
f2fs_ioc_get_encryption_pwsalt	file.c	/^static int f2fs_ioc_get_encryption_pwsalt(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_get_features	file.c	/^static int f2fs_ioc_get_features(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_get_pin_file	file.c	/^static int f2fs_ioc_get_pin_file(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_getflags	file.c	/^static int f2fs_ioc_getflags(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_getfslabel	file.c	/^static int f2fs_ioc_getfslabel(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_getversion	file.c	/^static int f2fs_ioc_getversion(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_measure_verity	file.c	/^static int f2fs_ioc_measure_verity(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_move_range	file.c	/^static int f2fs_ioc_move_range(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_precache_extents	file.c	/^static int f2fs_ioc_precache_extents(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_release_volatile_write	file.c	/^static int f2fs_ioc_release_volatile_write(struct file *filp)$/;"	f	file:
f2fs_ioc_remove_encryption_key	file.c	/^static int f2fs_ioc_remove_encryption_key(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_remove_encryption_key_all_users	file.c	/^static int f2fs_ioc_remove_encryption_key_all_users(struct file *filp,$/;"	f	file:
f2fs_ioc_resize_fs	file.c	/^static int f2fs_ioc_resize_fs(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_set_compress_option	file.c	/^static int f2fs_ioc_set_compress_option(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_set_encryption_policy	file.c	/^static int f2fs_ioc_set_encryption_policy(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_set_pin_file	file.c	/^static int f2fs_ioc_set_pin_file(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_setflags	file.c	/^static int f2fs_ioc_setflags(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_setfslabel	file.c	/^static int f2fs_ioc_setfslabel(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_setproject	file.c	/^static int f2fs_ioc_setproject(struct file *filp, __u32 projid)$/;"	f	file:
f2fs_ioc_shutdown	file.c	/^static int f2fs_ioc_shutdown(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioc_start_atomic_write	file.c	/^static int f2fs_ioc_start_atomic_write(struct file *filp)$/;"	f	file:
f2fs_ioc_start_volatile_write	file.c	/^static int f2fs_ioc_start_volatile_write(struct file *filp)$/;"	f	file:
f2fs_ioc_write_checkpoint	file.c	/^static int f2fs_ioc_write_checkpoint(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_ioctl	file.c	/^long f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)$/;"	f
f2fs_is_atomic_file	f2fs.h	/^static inline bool f2fs_is_atomic_file(struct inode *inode)$/;"	f
f2fs_is_checkpoint_ready	segment.h	/^static inline bool f2fs_is_checkpoint_ready(struct f2fs_sb_info *sbi)$/;"	f
f2fs_is_checkpointed_data	segment.c	/^bool f2fs_is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr)$/;"	f
f2fs_is_checkpointed_node	node.c	/^bool f2fs_is_checkpointed_node(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
f2fs_is_commit_atomic_write	f2fs.h	/^static inline bool f2fs_is_commit_atomic_write(struct inode *inode)$/;"	f
f2fs_is_compress_backend_ready	compress.c	/^bool f2fs_is_compress_backend_ready(struct inode *inode)$/;"	f
f2fs_is_compress_backend_ready	f2fs.h	/^static inline bool f2fs_is_compress_backend_ready(struct inode *inode)$/;"	f
f2fs_is_compressed_cluster	compress.c	/^int f2fs_is_compressed_cluster(struct inode *inode, pgoff_t index)$/;"	f
f2fs_is_compressed_page	compress.c	/^bool f2fs_is_compressed_page(struct page *page)$/;"	f
f2fs_is_compressed_page	f2fs.h	/^static inline bool f2fs_is_compressed_page(struct page *page) { return false; }$/;"	f
f2fs_is_dirty_device	checkpoint.c	/^bool f2fs_is_dirty_device(struct f2fs_sb_info *sbi, nid_t ino,$/;"	f
f2fs_is_drop_cache	f2fs.h	/^static inline bool f2fs_is_drop_cache(struct inode *inode)$/;"	f
f2fs_is_first_block_written	f2fs.h	/^static inline bool f2fs_is_first_block_written(struct inode *inode)$/;"	f
f2fs_is_mmap_file	f2fs.h	/^static inline int f2fs_is_mmap_file(struct inode *inode)$/;"	f
f2fs_is_multi_device	f2fs.h	/^static inline bool f2fs_is_multi_device(struct f2fs_sb_info *sbi)$/;"	f
f2fs_is_pinned_file	f2fs.h	/^static inline bool f2fs_is_pinned_file(struct inode *inode)$/;"	f
f2fs_is_time_consistent	f2fs.h	/^static inline bool f2fs_is_time_consistent(struct inode *inode)$/;"	f
f2fs_is_valid_blkaddr	checkpoint.c	/^bool f2fs_is_valid_blkaddr(struct f2fs_sb_info *sbi,$/;"	f
f2fs_is_volatile_file	f2fs.h	/^static inline bool f2fs_is_volatile_file(struct inode *inode)$/;"	f
f2fs_issue_discard	f2fs.h	/^	struct task_struct *f2fs_issue_discard;	\/* discard thread *\/$/;"	m	struct:discard_cmd_control	typeref:struct:discard_cmd_control::task_struct
f2fs_issue_discard	segment.c	/^static int f2fs_issue_discard(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_issue_discard_timeout	segment.c	/^bool f2fs_issue_discard_timeout(struct f2fs_sb_info *sbi)$/;"	f
f2fs_issue_flush	f2fs.h	/^	struct task_struct *f2fs_issue_flush;	\/* flush thread *\/$/;"	m	struct:flush_cmd_control	typeref:struct:flush_cmd_control::task_struct
f2fs_issue_flush	segment.c	/^int f2fs_issue_flush(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
f2fs_join_shrinker	shrinker.c	/^void f2fs_join_shrinker(struct f2fs_sb_info *sbi)$/;"	f
f2fs_kmalloc	f2fs.h	/^static inline void *f2fs_kmalloc(struct f2fs_sb_info *sbi,$/;"	f
f2fs_kmem_cache_alloc	f2fs.h	/^static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,$/;"	f
f2fs_kmem_cache_create	f2fs.h	/^static inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,$/;"	f
f2fs_kset	sysfs.c	/^static struct kset f2fs_kset = {$/;"	v	typeref:struct:kset	file:
f2fs_ktype	sysfs.c	/^static struct kobj_type f2fs_ktype = {$/;"	v	typeref:struct:kobj_type	file:
f2fs_kvmalloc	f2fs.h	/^static inline void *f2fs_kvmalloc(struct f2fs_sb_info *sbi,$/;"	f
f2fs_kvzalloc	f2fs.h	/^static inline void *f2fs_kvzalloc(struct f2fs_sb_info *sbi,$/;"	f
f2fs_kzalloc	f2fs.h	/^static inline void *f2fs_kzalloc(struct f2fs_sb_info *sbi,$/;"	f
f2fs_leave_shrinker	shrinker.c	/^void f2fs_leave_shrinker(struct f2fs_sb_info *sbi)$/;"	f
f2fs_lfs_mode	f2fs.h	/^static inline bool f2fs_lfs_mode(struct f2fs_sb_info *sbi)$/;"	f
f2fs_link	namei.c	/^static int f2fs_link(struct dentry *old_dentry, struct inode *dir,$/;"	f	file:
f2fs_listxattr	xattr.c	/^ssize_t f2fs_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)$/;"	f
f2fs_listxattr	xattr.h	139;"	d
f2fs_llseek	file.c	/^static loff_t f2fs_llseek(struct file *file, loff_t offset, int whence)$/;"	f	file:
f2fs_lock_all	f2fs.h	/^static inline void f2fs_lock_all(struct f2fs_sb_info *sbi)$/;"	f
f2fs_lock_op	f2fs.h	/^static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)$/;"	f
f2fs_lookup	namei.c	/^static struct dentry *f2fs_lookup(struct inode *dir, struct dentry *dentry,$/;"	f	file:
f2fs_lookup_extent_cache	extent_cache.c	/^bool f2fs_lookup_extent_cache(struct inode *inode, pgoff_t pgofs,$/;"	f
f2fs_lookup_extent_tree	extent_cache.c	/^static bool f2fs_lookup_extent_tree(struct inode *inode, pgoff_t pgofs,$/;"	f	file:
f2fs_lookup_hash	segment.c	/^static struct dynamic_discard_map *f2fs_lookup_hash(struct f2fs_sb_info *sbi,  $/;"	f	file:
f2fs_lookup_journal_in_cursum	segment.c	/^int f2fs_lookup_journal_in_cursum(struct f2fs_journal *journal, int type,$/;"	f
f2fs_lookup_pos_rb_tree_ext	extent_cache.c	/^struct rb_node **f2fs_lookup_pos_rb_tree_ext(struct f2fs_sb_info *sbi,$/;"	f
f2fs_lookup_rb_tree	extent_cache.c	/^struct rb_entry *f2fs_lookup_rb_tree(struct rb_root_cached *root,$/;"	f
f2fs_lookup_rb_tree_ext	extent_cache.c	/^struct rb_node **f2fs_lookup_rb_tree_ext(struct f2fs_sb_info *sbi,$/;"	f
f2fs_lookup_rb_tree_for_insert	extent_cache.c	/^struct rb_node **f2fs_lookup_rb_tree_for_insert(struct f2fs_sb_info *sbi,$/;"	f
f2fs_lookup_rb_tree_ret	extent_cache.c	/^struct rb_entry *f2fs_lookup_rb_tree_ret(struct rb_root_cached *root,$/;"	f
f2fs_lz4_ops	compress.c	/^static const struct f2fs_compress_ops f2fs_lz4_ops = {$/;"	v	typeref:struct:f2fs_compress_ops	file:
f2fs_lzo_ops	compress.c	/^static const struct f2fs_compress_ops f2fs_lzo_ops = {$/;"	v	typeref:struct:f2fs_compress_ops	file:
f2fs_lzorle_ops	compress.c	/^static const struct f2fs_compress_ops f2fs_lzorle_ops = {$/;"	v	typeref:struct:f2fs_compress_ops	file:
f2fs_make_empty_inline_dir	inline.c	/^int f2fs_make_empty_inline_dir(struct inode *inode, struct inode *parent,$/;"	f
f2fs_map_blocks	data.c	/^int f2fs_map_blocks(struct inode *inode, struct f2fs_map_blocks *map,$/;"	f
f2fs_map_blocks	f2fs.h	/^struct f2fs_map_blocks {$/;"	s
f2fs_mark_inode_dirty_sync	inode.c	/^void f2fs_mark_inode_dirty_sync(struct inode *inode, bool sync)$/;"	f
f2fs_mask_flags	f2fs.h	/^static inline __u32 f2fs_mask_flags(umode_t mode, __u32 flags)$/;"	f
f2fs_match_ci_name	dir.c	/^static int f2fs_match_ci_name(const struct inode *dir, const struct qstr *name,$/;"	f	file:
f2fs_match_ino	node.c	/^static int f2fs_match_ino(struct inode *inode, unsigned long ino, void *data)$/;"	f	file:
f2fs_match_name	dir.c	/^static inline int f2fs_match_name(const struct inode *dir,$/;"	f	file:
f2fs_may_compress	f2fs.h	/^static inline bool f2fs_may_compress(struct inode *inode)$/;"	f
f2fs_may_extent_tree	f2fs.h	/^static inline bool f2fs_may_extent_tree(struct inode *inode)$/;"	f
f2fs_may_inline_data	inline.c	/^bool f2fs_may_inline_data(struct inode *inode)$/;"	f
f2fs_may_inline_dentry	inline.c	/^bool f2fs_may_inline_dentry(struct inode *inode)$/;"	f
f2fs_merge_page_bio	data.c	/^int f2fs_merge_page_bio(struct f2fs_io_info *fio)$/;"	f
f2fs_meta_aops	checkpoint.c	/^const struct address_space_operations f2fs_meta_aops = {$/;"	v	typeref:struct:address_space_operations
f2fs_migrate_page	data.c	/^int f2fs_migrate_page(struct address_space *mapping,$/;"	f
f2fs_mkdir	namei.c	/^static int f2fs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)$/;"	f	file:
f2fs_mknod	namei.c	/^static int f2fs_mknod(struct inode *dir, struct dentry *dentry,$/;"	f	file:
f2fs_mount	super.c	/^static struct dentry *f2fs_mount(struct file_system_type *fs_type, int flags,$/;"	f	file:
f2fs_mount_info	f2fs.h	/^struct f2fs_mount_info {$/;"	s
f2fs_move_file_range	file.c	/^static int f2fs_move_file_range(struct file *file_in, loff_t pos_in,$/;"	f	file:
f2fs_move_inline_dirents	inline.c	/^static int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage,$/;"	f	file:
f2fs_move_node_page	node.c	/^int f2fs_move_node_page(struct page *node_page, int gc_type)$/;"	f
f2fs_move_rehashed_dirents	inline.c	/^static int f2fs_move_rehashed_dirents(struct inode *dir, struct page *ipage,$/;"	f	file:
f2fs_mpage_readpages	data.c	/^static int f2fs_mpage_readpages(struct inode *inode,$/;"	f	file:
f2fs_need_SSR	segment.c	/^bool f2fs_need_SSR(struct f2fs_sb_info *sbi)$/;"	f
f2fs_need_compress_data	f2fs.h	/^static inline bool f2fs_need_compress_data(struct inode *inode)$/;"	f
f2fs_need_dentry_mark	node.c	/^int f2fs_need_dentry_mark(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
f2fs_need_inode_block_update	node.c	/^bool f2fs_need_inode_block_update(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
f2fs_need_verity	data.c	/^static inline bool f2fs_need_verity(const struct inode *inode, pgoff_t idx)$/;"	f	file:
f2fs_new_inode	namei.c	/^static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)$/;"	f	file:
f2fs_new_inode_page	node.c	/^struct page *f2fs_new_inode_page(struct inode *inode)$/;"	f
f2fs_new_node_page	node.c	/^struct page *f2fs_new_node_page(struct dnode_of_data *dn, unsigned int ofs)$/;"	f
f2fs_nfs_get_inode	super.c	/^static struct inode *f2fs_nfs_get_inode(struct super_block *sb,$/;"	f	file:
f2fs_nm_info	f2fs.h	/^struct f2fs_nm_info {$/;"	s
f2fs_node_aops	node.c	/^const struct address_space_operations f2fs_node_aops = {$/;"	v	typeref:struct:address_space_operations
f2fs_notice	f2fs.h	2124;"	d
f2fs_npages_for_summary_flush	segment.c	/^int f2fs_npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)$/;"	f
f2fs_outplace_write_data	segment.c	/^void f2fs_outplace_write_data(struct dnode_of_data *dn,$/;"	f
f2fs_overwrite_io	data.c	/^bool f2fs_overwrite_io(struct inode *inode, loff_t pos, size_t len)$/;"	f
f2fs_pagecache_get_page	f2fs.h	/^static inline struct page *f2fs_pagecache_get_page($/;"	f
f2fs_parent_dir	dir.c	/^struct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)$/;"	f
f2fs_pin_file_control	file.c	/^int f2fs_pin_file_control(struct inode *inode, bool inc)$/;"	f
f2fs_post_read_required	f2fs.h	/^static inline bool f2fs_post_read_required(struct inode *inode)$/;"	f
f2fs_post_read_work	data.c	/^static void f2fs_post_read_work(struct work_struct *work)$/;"	f	file:
f2fs_preallocate_blocks	data.c	/^int f2fs_preallocate_blocks(struct kiocb *iocb, struct iov_iter *from)$/;"	f
f2fs_precache_extents	file.c	/^int f2fs_precache_extents(struct inode *inode)$/;"	f
f2fs_prepare_compress_overwrite	compress.c	/^int f2fs_prepare_compress_overwrite(struct inode *inode,$/;"	f
f2fs_prepare_lookup	dir.c	/^int f2fs_prepare_lookup(struct inode *dir, struct dentry *dentry,$/;"	f
f2fs_printk	super.c	/^void f2fs_printk(struct f2fs_sb_info *sbi, const char *fmt, ...)$/;"	f
f2fs_private_dio	f2fs.h	/^struct f2fs_private_dio {$/;"	s
f2fs_proc_root	sysfs.c	/^static struct proc_dir_entry *f2fs_proc_root;$/;"	v	typeref:struct:proc_dir_entry	file:
f2fs_put_dnode	f2fs.h	/^static inline void f2fs_put_dnode(struct dnode_of_data *dn)$/;"	f
f2fs_put_page	f2fs.h	/^static inline void f2fs_put_page(struct page *page, int unlock)$/;"	f
f2fs_put_rpages	compress.c	/^static void f2fs_put_rpages(struct compress_ctx *cc)$/;"	f	file:
f2fs_put_rpages_mapping	compress.c	/^static void f2fs_put_rpages_mapping(struct address_space *mapping,$/;"	f	file:
f2fs_put_rpages_wbc	compress.c	/^static void f2fs_put_rpages_wbc(struct compress_ctx *cc,$/;"	f	file:
f2fs_put_super	super.c	/^static void f2fs_put_super(struct super_block *sb)$/;"	f	file:
f2fs_qf_ino	f2fs.h	/^static inline unsigned long f2fs_qf_ino(struct super_block *sb, int type)$/;"	f
f2fs_quota_enable	super.c	/^static int f2fs_quota_enable(struct super_block *sb, int type, int format_id,$/;"	f	file:
f2fs_quota_off	super.c	/^static int f2fs_quota_off(struct super_block *sb, int type)$/;"	f	file:
f2fs_quota_off_umount	super.c	/^void f2fs_quota_off_umount(struct super_block *sb)$/;"	f
f2fs_quota_on	super.c	/^static int f2fs_quota_on(struct super_block *sb, int type, int format_id,$/;"	f	file:
f2fs_quota_on_mount	super.c	/^static int f2fs_quota_on_mount(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
f2fs_quota_operations	super.c	/^static const struct dquot_operations f2fs_quota_operations = {$/;"	v	typeref:struct:dquot_operations	file:
f2fs_quota_read	super.c	/^static ssize_t f2fs_quota_read(struct super_block *sb, int type, char *data,$/;"	f	file:
f2fs_quota_sync	super.c	/^int f2fs_quota_sync(struct super_block *sb, int type)$/;"	f
f2fs_quota_write	super.c	/^static ssize_t f2fs_quota_write(struct super_block *sb, int type,$/;"	f	file:
f2fs_quotactl_ops	super.c	/^static const struct quotactl_ops f2fs_quotactl_ops = {$/;"	v	typeref:struct:quotactl_ops	file:
f2fs_ra_meta_pages	checkpoint.c	/^int f2fs_ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages,$/;"	f
f2fs_ra_meta_pages_cond	checkpoint.c	/^void f2fs_ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index)$/;"	f
f2fs_ra_node_page	node.c	/^void f2fs_ra_node_page(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f
f2fs_ra_node_pages	node.c	/^static void f2fs_ra_node_pages(struct page *parent, int start, int n)$/;"	f	file:
f2fs_radix_tree_insert	f2fs.h	/^static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,$/;"	f
f2fs_read_data_page	data.c	/^static int f2fs_read_data_page(struct file *file, struct page *page)$/;"	f	file:
f2fs_read_end_io	data.c	/^static void f2fs_read_end_io(struct bio *bio)$/;"	f	file:
f2fs_read_inline_data	inline.c	/^int f2fs_read_inline_data(struct inode *inode, struct page *page)$/;"	f
f2fs_read_inline_dir	inline.c	/^int f2fs_read_inline_dir(struct file *file, struct dir_context *ctx,$/;"	f
f2fs_read_merkle_tree_page	verity.c	/^static struct page *f2fs_read_merkle_tree_page(struct inode *inode,$/;"	f	file:
f2fs_read_multi_pages	data.c	/^int f2fs_read_multi_pages(struct compress_ctx *cc, struct bio **bio_ret,$/;"	f
f2fs_read_single_page	data.c	/^static int f2fs_read_single_page(struct inode *inode, struct page *page,$/;"	f	file:
f2fs_readahead	data.c	/^static void f2fs_readahead(struct readahead_control *rac)$/;"	f	file:
f2fs_readdir	dir.c	/^static int f2fs_readdir(struct file *file, struct dir_context *ctx)$/;"	f	file:
f2fs_readonly	f2fs.h	/^static inline bool f2fs_readonly(struct super_block *sb)$/;"	f
f2fs_readpage_limit	data.c	/^static inline loff_t f2fs_readpage_limit(struct inode *inode)$/;"	f	file:
f2fs_realtime_discard_enable	f2fs.h	/^static inline bool f2fs_realtime_discard_enable(struct f2fs_sb_info *sbi)$/;"	f
f2fs_record_iostat	sysfs.c	/^void f2fs_record_iostat(struct f2fs_sb_info *sbi)$/;"	f
f2fs_recover_discard_journals	segment.c	/^int f2fs_recover_discard_journals(struct f2fs_sb_info *sbi)$/;"	f
f2fs_recover_fsync_data	recovery.c	/^int f2fs_recover_fsync_data(struct f2fs_sb_info *sbi, bool check_only)$/;"	f
f2fs_recover_inline_data	inline.c	/^int f2fs_recover_inline_data(struct inode *inode, struct page *npage)$/;"	f
f2fs_recover_inline_xattr	node.c	/^int f2fs_recover_inline_xattr(struct inode *inode, struct page *page)$/;"	f
f2fs_recover_inode_page	node.c	/^int f2fs_recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)$/;"	f
f2fs_recover_orphan_inodes	checkpoint.c	/^int f2fs_recover_orphan_inodes(struct f2fs_sb_info *sbi)$/;"	f
f2fs_recover_xattr_data	node.c	/^int f2fs_recover_xattr_data(struct inode *inode, struct page *page)$/;"	f
f2fs_register_inmem_page	segment.c	/^void f2fs_register_inmem_page(struct inode *inode, struct page *page)$/;"	f
f2fs_register_sysfs	sysfs.c	/^int f2fs_register_sysfs(struct f2fs_sb_info *sbi)$/;"	f
f2fs_release_compress_blocks	file.c	/^static int f2fs_release_compress_blocks(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_release_discard_addrs	segment.c	/^void f2fs_release_discard_addrs(struct f2fs_sb_info *sbi)$/;"	f
f2fs_release_file	file.c	/^static int f2fs_release_file(struct inode *inode, struct file *filp)$/;"	f	file:
f2fs_release_ino_entry	checkpoint.c	/^void f2fs_release_ino_entry(struct f2fs_sb_info *sbi, bool all)$/;"	f
f2fs_release_orphan_inode	checkpoint.c	/^void f2fs_release_orphan_inode(struct f2fs_sb_info *sbi)$/;"	f
f2fs_release_page	data.c	/^int f2fs_release_page(struct page *page, gfp_t wait)$/;"	f
f2fs_release_read_bio	data.c	/^static void f2fs_release_read_bio(struct bio *bio)$/;"	f	file:
f2fs_remount	super.c	/^static int f2fs_remount(struct super_block *sb, int *flags, char *data)$/;"	f	file:
f2fs_remove_dirty_inode	checkpoint.c	/^void f2fs_remove_dirty_inode(struct inode *inode)$/;"	f
f2fs_remove_ino_entry	checkpoint.c	/^void f2fs_remove_ino_entry(struct f2fs_sb_info *sbi, nid_t ino, int type)$/;"	f
f2fs_remove_inode_page	node.c	/^int f2fs_remove_inode_page(struct inode *inode)$/;"	f
f2fs_remove_orphan_inode	checkpoint.c	/^void f2fs_remove_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f
f2fs_rename	namei.c	/^static int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,$/;"	f	file:
f2fs_rename2	namei.c	/^static int f2fs_rename2(struct inode *old_dir, struct dentry *old_dentry,$/;"	f	file:
f2fs_replace_block	segment.c	/^void f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,$/;"	f
f2fs_report_zone_cb	super.c	/^static int f2fs_report_zone_cb(struct blk_zone *zone, unsigned int idx,$/;"	f	file:
f2fs_report_zones_args	super.c	/^struct f2fs_report_zones_args {$/;"	s	file:
f2fs_reserve_block	data.c	/^int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)$/;"	f
f2fs_reserve_compress_blocks	file.c	/^static int f2fs_reserve_compress_blocks(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_reserve_new_block	data.c	/^int f2fs_reserve_new_block(struct dnode_of_data *dn)$/;"	f
f2fs_reserve_new_blocks	data.c	/^int f2fs_reserve_new_blocks(struct dnode_of_data *dn, blkcnt_t count)$/;"	f
f2fs_reset_fsync_node_info	node.c	/^void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)$/;"	f
f2fs_reset_iostat	f2fs.h	/^static inline void f2fs_reset_iostat(struct f2fs_sb_info *sbi)$/;"	f
f2fs_resize_fs	gc.c	/^int f2fs_resize_fs(struct f2fs_sb_info *sbi, __u64 block_count)$/;"	f
f2fs_restore_inmem_curseg	segment.c	/^void f2fs_restore_inmem_curseg(struct f2fs_sb_info *sbi)$/;"	f
f2fs_restore_node_summary	node.c	/^int f2fs_restore_node_summary(struct f2fs_sb_info *sbi,$/;"	f
f2fs_rmdir	namei.c	/^static int f2fs_rmdir(struct inode *dir, struct dentry *dentry)$/;"	f	file:
f2fs_room_for_filename	dir.c	/^int f2fs_room_for_filename(const void *bitmap, int slots, int max_slots)$/;"	f
f2fs_rw_hint_to_seg_type	segment.c	/^int f2fs_rw_hint_to_seg_type(enum rw_hint hint)$/;"	f
f2fs_sanity_check_ckpt	super.c	/^int f2fs_sanity_check_ckpt(struct f2fs_sb_info *sbi)$/;"	f
f2fs_save_inmem_curseg	segment.c	/^void f2fs_save_inmem_curseg(struct f2fs_sb_info *sbi)$/;"	f
f2fs_sb_encoding_map	super.c	/^} f2fs_sb_encoding_map[] = {$/;"	v	typeref:struct:f2fs_sb_encodings	file:
f2fs_sb_encodings	super.c	/^static const struct f2fs_sb_encodings {$/;"	s	file:
f2fs_sb_info	f2fs.h	/^struct f2fs_sb_info {$/;"	s
f2fs_sb_ktype	sysfs.c	/^static struct kobj_type f2fs_sb_ktype = {$/;"	v	typeref:struct:kobj_type	file:
f2fs_sb_read_encoding	super.c	/^static int f2fs_sb_read_encoding(const struct f2fs_super_block *sb,$/;"	f	file:
f2fs_sb_release	sysfs.c	/^static void f2fs_sb_release(struct kobject *kobj)$/;"	f	file:
f2fs_sbi_show	sysfs.c	/^static ssize_t f2fs_sbi_show(struct f2fs_attr *a,$/;"	f	file:
f2fs_sbi_store	sysfs.c	/^static ssize_t f2fs_sbi_store(struct f2fs_attr *a,$/;"	f	file:
f2fs_scan_devices	super.c	/^static int f2fs_scan_devices(struct f2fs_sb_info *sbi)$/;"	f	file:
f2fs_sec_trim_file	file.c	/^static int f2fs_sec_trim_file(struct file *filp, unsigned long arg)$/;"	f	file:
f2fs_secure_erase	file.c	/^static int f2fs_secure_erase(struct block_device *bdev, struct inode *inode,$/;"	f	file:
f2fs_seek_block	file.c	/^static loff_t f2fs_seek_block(struct file *file, loff_t offset, int whence)$/;"	f	file:
f2fs_set_acl	acl.c	/^int f2fs_set_acl(struct inode *inode, struct posix_acl *acl, int type)$/;"	f
f2fs_set_acl	acl.h	42;"	d
f2fs_set_bio_crypt_ctx	data.c	/^static void f2fs_set_bio_crypt_ctx(struct bio *bio, const struct inode *inode,$/;"	f	file:
f2fs_set_bit	f2fs.h	/^static inline void f2fs_set_bit(unsigned int nr, char *addr)$/;"	f
f2fs_set_compressed_page	compress.c	/^static void f2fs_set_compressed_page(struct page *page,$/;"	f	file:
f2fs_set_context	super.c	/^static int f2fs_set_context(struct inode *inode, const void *ctx, size_t len,$/;"	f	file:
f2fs_set_data_blkaddr	data.c	/^void f2fs_set_data_blkaddr(struct dnode_of_data *dn)$/;"	f
f2fs_set_data_page_dirty	data.c	/^static int f2fs_set_data_page_dirty(struct page *page)$/;"	f	file:
f2fs_set_dirty_device	checkpoint.c	/^void f2fs_set_dirty_device(struct f2fs_sb_info *sbi, nid_t ino,$/;"	f
f2fs_set_encrypted_inode	f2fs.h	/^static inline void f2fs_set_encrypted_inode(struct inode *inode)$/;"	f
f2fs_set_inode_flags	inode.c	/^void f2fs_set_inode_flags(struct inode *inode)$/;"	f
f2fs_set_link	dir.c	/^void f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,$/;"	f
f2fs_set_meta_page_dirty	checkpoint.c	/^static int f2fs_set_meta_page_dirty(struct page *page)$/;"	f	file:
f2fs_set_node_page_dirty	node.c	/^static int f2fs_set_node_page_dirty(struct page *page)$/;"	f	file:
f2fs_set_page_private	f2fs.h	/^static inline void f2fs_set_page_private(struct page *page,$/;"	f
f2fs_set_qf_name	super.c	/^static int f2fs_set_qf_name(struct super_block *sb, int qtype,$/;"	f	file:
f2fs_set_test_dummy_encryption	super.c	/^static int f2fs_set_test_dummy_encryption(struct super_block *sb,$/;"	f	file:
f2fs_setattr	file.c	/^int f2fs_setattr(struct dentry *dentry, struct iattr *attr)$/;"	f
f2fs_setflags_common	file.c	/^static int f2fs_setflags_common(struct inode *inode, u32 iflags, u32 mask)$/;"	f	file:
f2fs_setup_casefold	super.c	/^static int f2fs_setup_casefold(struct f2fs_sb_info *sbi)$/;"	f	file:
f2fs_setup_filename	dir.c	/^int f2fs_setup_filename(struct inode *dir, const struct qstr *iname,$/;"	f
f2fs_setxattr	xattr.c	/^int f2fs_setxattr(struct inode *inode, int index, const char *name,$/;"	f
f2fs_setxattr	xattr.h	/^static inline int f2fs_setxattr(struct inode *inode, int index,$/;"	f
f2fs_should_update_inplace	data.c	/^bool f2fs_should_update_inplace(struct inode *inode, struct f2fs_io_info *fio)$/;"	f
f2fs_should_update_outplace	data.c	/^bool f2fs_should_update_outplace(struct inode *inode, struct f2fs_io_info *fio)$/;"	f
f2fs_show_compress_options	super.c	/^static inline void f2fs_show_compress_options(struct seq_file *seq,$/;"	f	file:
f2fs_show_injection_info	f2fs.h	1664;"	d
f2fs_show_injection_info	f2fs.h	1687;"	d
f2fs_show_options	super.c	/^static int f2fs_show_options(struct seq_file *seq, struct dentry *root)$/;"	f	file:
f2fs_show_quota_options	super.c	/^static inline void f2fs_show_quota_options(struct seq_file *seq,$/;"	f	file:
f2fs_shrink_count	shrinker.c	/^unsigned long f2fs_shrink_count(struct shrinker *shrink,$/;"	f
f2fs_shrink_extent_tree	extent_cache.c	/^unsigned int f2fs_shrink_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink)$/;"	f
f2fs_shrink_scan	shrinker.c	/^unsigned long f2fs_shrink_scan(struct shrinker *shrink,$/;"	f
f2fs_shrinker_info	super.c	/^static struct shrinker f2fs_shrinker_info = {$/;"	v	typeref:struct:shrinker	file:
f2fs_skip_inode_update	f2fs.h	/^static inline bool f2fs_skip_inode_update(struct inode *inode, int dsync)$/;"	f
f2fs_sm_info	f2fs.h	/^struct f2fs_sm_info {$/;"	s
f2fs_sops	super.c	/^static const struct super_operations f2fs_sops = {$/;"	v	typeref:struct:super_operations	file:
f2fs_space_for_roll_forward	recovery.c	/^bool f2fs_space_for_roll_forward(struct f2fs_sb_info *sbi)$/;"	f
f2fs_special_inode_operations	namei.c	/^const struct inode_operations f2fs_special_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_start_bidx_of_node	gc.c	/^block_t f2fs_start_bidx_of_node(unsigned int node_ofs, struct inode *inode)$/;"	f
f2fs_start_gc_thread	gc.c	/^int f2fs_start_gc_thread(struct f2fs_sb_info *sbi)$/;"	f
f2fs_stat_info	f2fs.h	/^struct f2fs_stat_info {$/;"	s
f2fs_statfs	super.c	/^static int f2fs_statfs(struct dentry *dentry, struct kstatfs *buf)$/;"	f	file:
f2fs_statfs_project	super.c	/^static int f2fs_statfs_project(struct super_block *sb,$/;"	f	file:
f2fs_stop_checkpoint	checkpoint.c	/^void f2fs_stop_checkpoint(struct f2fs_sb_info *sbi, bool end_io)$/;"	f
f2fs_stop_discard_thread	segment.c	/^void f2fs_stop_discard_thread(struct f2fs_sb_info *sbi)$/;"	f
f2fs_stop_gc_thread	gc.c	/^void f2fs_stop_gc_thread(struct f2fs_sb_info *sbi)$/;"	f
f2fs_submit_bio	data.c	/^void f2fs_submit_bio(struct f2fs_sb_info *sbi,$/;"	f
f2fs_submit_discard_endio	segment.c	/^static void f2fs_submit_discard_endio(struct bio *bio)$/;"	f	file:
f2fs_submit_merged_ipu_write	data.c	/^void f2fs_submit_merged_ipu_write(struct f2fs_sb_info *sbi,$/;"	f
f2fs_submit_merged_write	data.c	/^void f2fs_submit_merged_write(struct f2fs_sb_info *sbi, enum page_type type)$/;"	f
f2fs_submit_merged_write_cond	data.c	/^void f2fs_submit_merged_write_cond(struct f2fs_sb_info *sbi,$/;"	f
f2fs_submit_page_bio	data.c	/^int f2fs_submit_page_bio(struct f2fs_io_info *fio)$/;"	f
f2fs_submit_page_read	data.c	/^static int f2fs_submit_page_read(struct inode *inode, struct page *page,$/;"	f	file:
f2fs_submit_page_write	data.c	/^void f2fs_submit_page_write(struct f2fs_io_info *fio)$/;"	f
f2fs_swap_activate	data.c	/^static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,$/;"	f	file:
f2fs_swap_deactivate	data.c	/^static void f2fs_swap_deactivate(struct file *file)$/;"	f	file:
f2fs_symlink	namei.c	/^static int f2fs_symlink(struct inode *dir, struct dentry *dentry,$/;"	f	file:
f2fs_symlink_inode_operations	namei.c	/^const struct inode_operations f2fs_symlink_inode_operations = {$/;"	v	typeref:struct:inode_operations
f2fs_sync_dirty_inodes	checkpoint.c	/^int f2fs_sync_dirty_inodes(struct f2fs_sb_info *sbi, enum inode_type type)$/;"	f
f2fs_sync_file	file.c	/^int f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)$/;"	f
f2fs_sync_fs	super.c	/^int f2fs_sync_fs(struct super_block *sb, int sync)$/;"	f
f2fs_sync_inode_meta	checkpoint.c	/^int f2fs_sync_inode_meta(struct f2fs_sb_info *sbi)$/;"	f
f2fs_sync_meta_pages	checkpoint.c	/^long f2fs_sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,$/;"	f
f2fs_sync_node_pages	node.c	/^int f2fs_sync_node_pages(struct f2fs_sb_info *sbi,$/;"	f
f2fs_target_device	data.c	/^struct block_device *f2fs_target_device(struct f2fs_sb_info *sbi,$/;"	f
f2fs_target_device_index	data.c	/^int f2fs_target_device_index(struct f2fs_sb_info *sbi, block_t blkaddr)$/;"	f
f2fs_test_and_clear_bit	f2fs.h	/^static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)$/;"	f
f2fs_test_and_set_bit	f2fs.h	/^static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)$/;"	f
f2fs_test_bit	f2fs.h	/^static inline int f2fs_test_bit(unsigned int nr, char *addr)$/;"	f
f2fs_time_over	f2fs.h	/^static inline bool f2fs_time_over(struct f2fs_sb_info *sbi, int type)$/;"	f
f2fs_time_to_wait	f2fs.h	/^static inline unsigned int f2fs_time_to_wait(struct f2fs_sb_info *sbi,$/;"	f
f2fs_tmpfile	namei.c	/^static int f2fs_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)$/;"	f	file:
f2fs_tokens	super.c	/^static match_table_t f2fs_tokens = {$/;"	v	file:
f2fs_trace_ios	trace.c	/^void f2fs_trace_ios(struct f2fs_io_info *fio, int flush)$/;"	f
f2fs_trace_ios	trace.h	38;"	d
f2fs_trace_pid	trace.c	/^void f2fs_trace_pid(struct page *page)$/;"	f
f2fs_trace_pid	trace.h	37;"	d
f2fs_transfer_project_quota	file.c	/^int f2fs_transfer_project_quota(struct inode *inode, kprojid_t kprojid)$/;"	f
f2fs_trim_fs	segment.c	/^int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)$/;"	f
f2fs_truncate	file.c	/^int f2fs_truncate(struct inode *inode)$/;"	f
f2fs_truncate_blocks	file.c	/^int f2fs_truncate_blocks(struct inode *inode, u64 from, bool lock)$/;"	f
f2fs_truncate_data_blocks	file.c	/^void f2fs_truncate_data_blocks(struct dnode_of_data *dn)$/;"	f
f2fs_truncate_data_blocks_range	file.c	/^void f2fs_truncate_data_blocks_range(struct dnode_of_data *dn, int count)$/;"	f
f2fs_truncate_hole	file.c	/^int f2fs_truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)$/;"	f
f2fs_truncate_inline_inode	inline.c	/^void f2fs_truncate_inline_inode(struct inode *inode,$/;"	f
f2fs_truncate_inode_blocks	node.c	/^int f2fs_truncate_inode_blocks(struct inode *inode, pgoff_t from)$/;"	f
f2fs_truncate_partial_cluster	compress.c	/^int f2fs_truncate_partial_cluster(struct inode *inode, u64 from, bool lock)$/;"	f
f2fs_truncate_quota_inode_pages	super.c	/^static void f2fs_truncate_quota_inode_pages(struct super_block *sb)$/;"	f	file:
f2fs_truncate_xattr_node	node.c	/^int f2fs_truncate_xattr_node(struct inode *inode)$/;"	f
f2fs_try_convert_inline_dir	inline.c	/^int f2fs_try_convert_inline_dir(struct inode *dir, struct dentry *dentry)$/;"	f
f2fs_try_to_free_nats	node.c	/^int f2fs_try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)$/;"	f
f2fs_try_to_free_nids	node.c	/^int f2fs_try_to_free_nids(struct f2fs_sb_info *sbi, int nr_shrink)$/;"	f
f2fs_trylock_op	f2fs.h	/^static inline int f2fs_trylock_op(struct f2fs_sb_info *sbi)$/;"	f
f2fs_tuning_parameters	super.c	/^static void f2fs_tuning_parameters(struct f2fs_sb_info *sbi)$/;"	f	file:
f2fs_type_by_mode	dir.c	/^static unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {$/;"	v	file:
f2fs_unfreeze	super.c	/^static int f2fs_unfreeze(struct super_block *sb)$/;"	f	file:
f2fs_unlink	namei.c	/^static int f2fs_unlink(struct inode *dir, struct dentry *dentry)$/;"	f	file:
f2fs_unlock_all	f2fs.h	/^static inline void f2fs_unlock_all(struct f2fs_sb_info *sbi)$/;"	f
f2fs_unlock_op	f2fs.h	/^static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)$/;"	f
f2fs_unlock_rpages	compress.c	/^static void f2fs_unlock_rpages(struct compress_ctx *cc, int len)$/;"	f	file:
f2fs_unregister_sysfs	sysfs.c	/^void f2fs_unregister_sysfs(struct f2fs_sb_info *sbi)$/;"	f
f2fs_update_data_blkaddr	data.c	/^void f2fs_update_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr)$/;"	f
f2fs_update_dentry	dir.c	/^void f2fs_update_dentry(nid_t ino, umode_t mode, struct f2fs_dentry_ptr *d,$/;"	f
f2fs_update_dirty_page	checkpoint.c	/^void f2fs_update_dirty_page(struct inode *inode, struct page *page)$/;"	f
f2fs_update_extension_list	namei.c	/^int f2fs_update_extension_list(struct f2fs_sb_info *sbi, const char *name,$/;"	f
f2fs_update_extent_cache	extent_cache.c	/^void f2fs_update_extent_cache(struct dnode_of_data *dn)$/;"	f
f2fs_update_extent_cache_range	extent_cache.c	/^void f2fs_update_extent_cache_range(struct dnode_of_data *dn,$/;"	f
f2fs_update_extent_tree_range	extent_cache.c	/^static void f2fs_update_extent_tree_range(struct inode *inode,$/;"	f	file:
f2fs_update_inode	inode.c	/^void f2fs_update_inode(struct inode *inode, struct page *node_page)$/;"	f
f2fs_update_inode_page	inode.c	/^void f2fs_update_inode_page(struct inode *inode)$/;"	f
f2fs_update_iostat	f2fs.h	/^static inline void f2fs_update_iostat(struct f2fs_sb_info *sbi,$/;"	f
f2fs_update_meta_page	segment.c	/^void f2fs_update_meta_page(struct f2fs_sb_info *sbi,$/;"	f
f2fs_update_parent_metadata	dir.c	/^void f2fs_update_parent_metadata(struct inode *dir, struct inode *inode,$/;"	f
f2fs_update_sit_info	debug.c	/^void f2fs_update_sit_info(struct f2fs_sb_info *sbi)$/;"	f
f2fs_update_sit_info	f2fs.h	/^static inline void f2fs_update_sit_info(struct f2fs_sb_info *sbi) {}$/;"	f
f2fs_update_time	f2fs.h	/^static inline void f2fs_update_time(struct f2fs_sb_info *sbi, int type)$/;"	f
f2fs_usable_blks_in_seg	segment.c	/^unsigned int f2fs_usable_blks_in_seg(struct f2fs_sb_info *sbi,$/;"	f
f2fs_usable_segs_in_sec	segment.c	/^unsigned int f2fs_usable_segs_in_sec(struct f2fs_sb_info *sbi,$/;"	f
f2fs_usable_zone_blks_in_seg	segment.c	/^static inline unsigned int f2fs_usable_zone_blks_in_seg($/;"	f	file:
f2fs_usable_zone_blks_in_seg	segment.c	/^static inline unsigned int f2fs_usable_zone_blks_in_seg(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_usable_zone_segs_in_sec	segment.c	/^static inline unsigned int f2fs_usable_zone_segs_in_sec($/;"	f	file:
f2fs_usable_zone_segs_in_sec	segment.c	/^static inline unsigned int f2fs_usable_zone_segs_in_sec(struct f2fs_sb_info *sbi,$/;"	f	file:
f2fs_verify_bio	data.c	/^static void f2fs_verify_bio(struct bio *bio)$/;"	f	file:
f2fs_verify_pages	data.c	/^static void f2fs_verify_pages(struct page **rpages, unsigned int cluster_size)$/;"	f	file:
f2fs_verity_in_progress	f2fs.h	/^static inline bool f2fs_verity_in_progress(struct inode *inode)$/;"	f
f2fs_verity_metadata_pos	verity.c	/^static inline loff_t f2fs_verity_metadata_pos(const struct inode *inode)$/;"	f	file:
f2fs_verity_work	data.c	/^static void f2fs_verity_work(struct work_struct *work)$/;"	f	file:
f2fs_verityops	verity.c	/^const struct fsverity_operations f2fs_verityops = {$/;"	v	typeref:struct:fsverity_operations
f2fs_vm_page_mkwrite	file.c	/^static vm_fault_t f2fs_vm_page_mkwrite(struct vm_fault *vmf)$/;"	f	file:
f2fs_vmap	compress.c	/^static void *f2fs_vmap(struct page **pages, unsigned int count)$/;"	f	file:
f2fs_wait_discard_bio	segment.c	/^static void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr)$/;"	f	file:
f2fs_wait_on_all_pages	checkpoint.c	/^void f2fs_wait_on_all_pages(struct f2fs_sb_info *sbi, int type)$/;"	f
f2fs_wait_on_block_writeback	segment.c	/^void f2fs_wait_on_block_writeback(struct inode *inode, block_t blkaddr)$/;"	f
f2fs_wait_on_block_writeback_range	segment.c	/^void f2fs_wait_on_block_writeback_range(struct inode *inode, block_t blkaddr,$/;"	f
f2fs_wait_on_node_pages_writeback	node.c	/^int f2fs_wait_on_node_pages_writeback(struct f2fs_sb_info *sbi,$/;"	f
f2fs_wait_on_page_writeback	segment.c	/^void f2fs_wait_on_page_writeback(struct page *page,$/;"	f
f2fs_warn	f2fs.h	2122;"	d
f2fs_write_begin	data.c	/^static int f2fs_write_begin(struct file *file, struct address_space *mapping,$/;"	f	file:
f2fs_write_cache_pages	data.c	/^static int f2fs_write_cache_pages(struct address_space *mapping,$/;"	f	file:
f2fs_write_checkpoint	checkpoint.c	/^int f2fs_write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f
f2fs_write_compressed_pages	compress.c	/^static int f2fs_write_compressed_pages(struct compress_ctx *cc,$/;"	f	file:
f2fs_write_data_page	data.c	/^static int f2fs_write_data_page(struct page *page,$/;"	f	file:
f2fs_write_data_pages	data.c	/^static int f2fs_write_data_pages(struct address_space *mapping,$/;"	f	file:
f2fs_write_data_summaries	segment.c	/^void f2fs_write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)$/;"	f
f2fs_write_discard_journals	segment.c	/^block_t f2fs_write_discard_journals(struct f2fs_sb_info *sbi, $/;"	f
f2fs_write_end	data.c	/^static int f2fs_write_end(struct file *file,$/;"	f	file:
f2fs_write_end_io	data.c	/^static void f2fs_write_end_io(struct bio *bio)$/;"	f	file:
f2fs_write_failed	data.c	/^static void f2fs_write_failed(struct address_space *mapping, loff_t to)$/;"	f	file:
f2fs_write_inline_data	inline.c	/^int f2fs_write_inline_data(struct inode *inode, struct page *page)$/;"	f
f2fs_write_inode	inode.c	/^int f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)$/;"	f
f2fs_write_merkle_tree_block	verity.c	/^static int f2fs_write_merkle_tree_block(struct inode *inode, const void *buf,$/;"	f	file:
f2fs_write_meta_page	checkpoint.c	/^static int f2fs_write_meta_page(struct page *page,$/;"	f	file:
f2fs_write_meta_pages	checkpoint.c	/^static int f2fs_write_meta_pages(struct address_space *mapping,$/;"	f	file:
f2fs_write_multi_pages	compress.c	/^int f2fs_write_multi_pages(struct compress_ctx *cc,$/;"	f
f2fs_write_node_page	node.c	/^static int f2fs_write_node_page(struct page *page,$/;"	f	file:
f2fs_write_node_pages	node.c	/^static int f2fs_write_node_pages(struct address_space *mapping,$/;"	f	file:
f2fs_write_node_summaries	segment.c	/^void f2fs_write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)$/;"	f
f2fs_write_raw_pages	compress.c	/^static int f2fs_write_raw_pages(struct compress_ctx *cc,$/;"	f	file:
f2fs_write_single_data_page	data.c	/^int f2fs_write_single_data_page(struct page *page, int *submitted,$/;"	f
f2fs_xattr_advise_get	xattr.c	/^static int f2fs_xattr_advise_get(const struct xattr_handler *handler,$/;"	f	file:
f2fs_xattr_advise_handler	xattr.c	/^const struct xattr_handler f2fs_xattr_advise_handler = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_advise_set	xattr.c	/^static int f2fs_xattr_advise_set(const struct xattr_handler *handler,$/;"	f	file:
f2fs_xattr_entry	xattr.h	/^struct f2fs_xattr_entry {$/;"	s
f2fs_xattr_fiemap	data.c	/^static int f2fs_xattr_fiemap(struct inode *inode,$/;"	f	file:
f2fs_xattr_generic_get	xattr.c	/^static int f2fs_xattr_generic_get(const struct xattr_handler *handler,$/;"	f	file:
f2fs_xattr_generic_set	xattr.c	/^static int f2fs_xattr_generic_set(const struct xattr_handler *handler,$/;"	f	file:
f2fs_xattr_handler	xattr.c	/^static inline const struct xattr_handler *f2fs_xattr_handler(int index)$/;"	f	file:
f2fs_xattr_handler_map	xattr.c	/^static const struct xattr_handler *f2fs_xattr_handler_map[] = {$/;"	v	typeref:struct:xattr_handler	file:
f2fs_xattr_handlers	xattr.c	/^const struct xattr_handler *f2fs_xattr_handlers[] = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_handlers	xattr.h	138;"	d
f2fs_xattr_header	xattr.h	/^struct f2fs_xattr_header {$/;"	s
f2fs_xattr_security_handler	xattr.c	/^const struct xattr_handler f2fs_xattr_security_handler = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_trusted_handler	xattr.c	/^const struct xattr_handler f2fs_xattr_trusted_handler = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_trusted_list	xattr.c	/^static bool f2fs_xattr_trusted_list(struct dentry *dentry)$/;"	f	file:
f2fs_xattr_user_handler	xattr.c	/^const struct xattr_handler f2fs_xattr_user_handler = {$/;"	v	typeref:struct:xattr_handler
f2fs_xattr_user_list	xattr.c	/^static bool f2fs_xattr_user_list(struct dentry *dentry)$/;"	f	file:
f2fs_xattr_value_same	xattr.c	/^static bool f2fs_xattr_value_same(struct f2fs_xattr_entry *entry,$/;"	f	file:
f2fs_xflags_map	file.c	/^} f2fs_xflags_map[] = {$/;"	v	typeref:struct:__anon2	file:
f2fs_xflags_to_iflags	file.c	/^static inline u32 f2fs_xflags_to_iflags(u32 xflags)$/;"	f	file:
f2fs_zero_range	file.c	/^static int f2fs_zero_range(struct inode *inode, loff_t offset, loff_t len,$/;"	f	file:
f2fs_zstd_ops	compress.c	/^static const struct f2fs_compress_ops f2fs_zstd_ops = {$/;"	v	typeref:struct:f2fs_compress_ops	file:
failed	f2fs.h	/^	bool failed;			\/* indicate IO error during decompression *\/$/;"	m	struct:decompress_io_ctx
fault_info	f2fs.h	/^	struct f2fs_fault_info fault_info;	\/* For fault injection *\/$/;"	m	struct:f2fs_mount_info	typeref:struct:f2fs_mount_info::f2fs_fault_info
fcc_info	f2fs.h	/^	struct flush_cmd_control *fcc_info;$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::flush_cmd_control
fdev	segment.c	/^       struct f2fs_dev_info *fdev;$/;"	m	struct:check_zone_write_pointer_args	typeref:struct:check_zone_write_pointer_args::f2fs_dev_info	file:
feat_id	sysfs.c	/^enum feat_id {$/;"	g	file:
features	sysfs.c	/^F2FS_GENERAL_RO_ATTR(features);$/;"	v
features_show	sysfs.c	/^static ssize_t features_show(struct f2fs_attr *a,$/;"	f	file:
file_clear_cold	f2fs.h	696;"	d
file_clear_encrypt	f2fs.h	700;"	d
file_clear_hot	f2fs.h	707;"	d
file_enc_name	f2fs.h	701;"	d
file_got_pino	f2fs.h	697;"	d
file_is_cold	f2fs.h	692;"	d
file_is_encrypt	f2fs.h	698;"	d
file_is_hot	f2fs.h	705;"	d
file_is_verity	f2fs.h	708;"	d
file_keep_isize	f2fs.h	703;"	d
file_lost_pino	f2fs.h	695;"	d
file_set_cold	f2fs.h	694;"	d
file_set_enc_name	f2fs.h	702;"	d
file_set_encrypt	f2fs.h	699;"	d
file_set_hot	f2fs.h	706;"	d
file_set_keep_isize	f2fs.h	704;"	d
file_set_verity	f2fs.h	709;"	d
file_type	trace.h	/^enum file_type {$/;"	g
file_wrong_pino	f2fs.h	693;"	d
filename	f2fs.h	/^	__u8 (*filename)[F2FS_SLOT_LEN];$/;"	m	struct:f2fs_dentry_ptr
fill_node_footer	node.h	/^static inline void fill_node_footer(struct page *page, nid_t nid,$/;"	f
fill_node_footer_blkaddr	node.h	/^static inline void fill_node_footer_blkaddr(struct page *page, block_t blkaddr)$/;"	f
fill_zero	file.c	/^static int fill_zero(struct inode *inode, pgoff_t index,$/;"	f	file:
find_fsync_dnodes	recovery.c	/^static int find_fsync_dnodes(struct f2fs_sb_info *sbi, struct list_head *head,$/;"	f	file:
find_gc_inode	gc.c	/^static struct inode *find_gc_inode(struct gc_inode_list *gc_list, nid_t ino)$/;"	f	file:
find_in_block	dir.c	/^static struct f2fs_dir_entry *find_in_block(struct inode *dir,$/;"	f	file:
find_in_level	dir.c	/^static struct f2fs_dir_entry *find_in_level(struct inode *dir,$/;"	f	file:
find_next_inuse	segment.h	/^static inline unsigned int find_next_inuse(struct free_segmap_info *free_i,$/;"	f
fio	f2fs.h	/^	struct f2fs_io_info fio;	\/* store buffered io info. *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::f2fs_io_info
fio	trace.h	/^	struct f2fs_io_info fio;$/;"	m	struct:last_io_info	typeref:struct:last_io_info::f2fs_io_info
fix_curseg_write_pointer	segment.c	/^static int fix_curseg_write_pointer(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
flag	node.h	/^	unsigned char flag;	\/* for node information bits *\/$/;"	m	struct:node_info
flags	f2fs.h	/^	unsigned long flags[BITS_TO_LONGS(FI_MAX)];	\/* use to pass per-file flags *\/$/;"	m	struct:f2fs_inode_info
flush_cmd	f2fs.h	/^struct flush_cmd {$/;"	s
flush_cmd_control	f2fs.h	/^struct flush_cmd_control {$/;"	s
flush_dirty_inode	node.c	/^static bool flush_dirty_inode(struct page *page)$/;"	f	file:
flush_dynamic_discard_maps	segment.c	/^void flush_dynamic_discard_maps(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f
flush_inline_data	node.c	/^static void flush_inline_data(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f	file:
flush_list_empty	f2fs.h	/^	int nr_flushing, nr_flushed, flush_list_empty;$/;"	m	struct:f2fs_stat_info
flush_lock	f2fs.h	/^	struct mutex flush_lock;		\/* for flush exclusion *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::mutex
flush_one_ddm	segment.c	/^static int flush_one_ddm(struct f2fs_sb_info *sbi, struct dynamic_discard_map_control *ddmc,$/;"	f	file:
flush_wait_queue	f2fs.h	/^	wait_queue_head_t flush_wait_queue;	\/* waiting queue for wake-up *\/$/;"	m	struct:flush_cmd_control
fofs	f2fs.h	/^	unsigned int fofs;		\/* start offset in a file *\/$/;"	m	struct:extent_info
free_info	f2fs.h	/^	struct free_segmap_info *free_info;	\/* free segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::free_segmap_info
free_nid	node.h	/^struct free_nid {$/;"	s
free_nid_bitmap	f2fs.h	/^	unsigned char **free_nid_bitmap;$/;"	m	struct:f2fs_nm_info
free_nid_count	f2fs.h	/^	unsigned short *free_nid_count;	\/* free nid count of NAT block *\/$/;"	m	struct:f2fs_nm_info
free_nid_list	f2fs.h	/^	struct list_head free_nid_list;		\/* list for free nids excluding preallocated nids *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::list_head
free_nid_root	f2fs.h	/^	struct radix_tree_root free_nid_root;\/* root of the free_nid cache *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::radix_tree_root
free_nid_slab	node.c	/^static struct kmem_cache *free_nid_slab;$/;"	v	typeref:struct:kmem_cache	file:
free_nids	f2fs.h	/^	int free_nids, avail_nids, alloc_nids;$/;"	m	struct:f2fs_stat_info
free_physical_sections	segment.h	/^static inline unsigned int free_physical_sections(struct f2fs_sb_info *sbi)$/;"	f
free_secmap	segment.h	/^	unsigned long *free_secmap;	\/* free section bitmap *\/$/;"	m	struct:free_segmap_info
free_secs	f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
free_sections	segment.h	/^	unsigned int free_sections;	\/* # of free sections *\/$/;"	m	struct:free_segmap_info
free_sections	segment.h	/^static inline unsigned int free_sections(struct f2fs_sb_info *sbi)$/;"	f
free_segmap	segment.h	/^	unsigned long *free_segmap;	\/* free segment bitmap *\/$/;"	m	struct:free_segmap_info
free_segmap_info	segment.h	/^struct free_segmap_info {$/;"	s
free_segment_range	gc.c	/^static int free_segment_range(struct f2fs_sb_info *sbi,$/;"	f	file:
free_segments	segment.h	/^	unsigned int free_segments;	\/* # of free segments *\/$/;"	m	struct:free_segmap_info
free_segments	segment.h	/^static inline unsigned int free_segments(struct f2fs_sb_info *sbi)$/;"	f
free_segments	sysfs.c	/^F2FS_GENERAL_RO_ATTR(free_segments);$/;"	v
free_segments_show	sysfs.c	/^static ssize_t free_segments_show(struct f2fs_attr *a,$/;"	f	file:
free_segs	f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
free_segs_blk_count	gc.h	/^static inline block_t free_segs_blk_count(struct f2fs_sb_info *sbi)$/;"	f
free_segs_blk_count_zoned	gc.h	/^static inline block_t free_segs_blk_count_zoned(struct f2fs_sb_info *sbi)$/;"	f
free_user_blocks	gc.h	/^static inline block_t free_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
fs_mode	f2fs.h	/^	int fs_mode;			\/* fs mode: LFS or ADAPTIVE *\/$/;"	m	struct:f2fs_mount_info
fsflag	file.c	/^	u32 fsflag;$/;"	m	struct:__anon1	file:
fstrim_list	f2fs.h	/^	struct list_head fstrim_list;		\/* in-flight discard from fstrim *\/$/;"	m	struct:discard_cmd_control	typeref:struct:discard_cmd_control::list_head
fsverity_descriptor_location	verity.c	/^struct fsverity_descriptor_location {$/;"	s	file:
fsync_entry_slab	recovery.c	/^static struct kmem_cache *fsync_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
fsync_inode_entry	f2fs.h	/^struct fsync_inode_entry {$/;"	s
fsync_mode	f2fs.h	/^	int fsync_mode;			\/* fsync policy *\/$/;"	m	struct:f2fs_mount_info
fsync_mode	f2fs.h	/^enum fsync_mode {$/;"	g
fsync_node_entry	f2fs.h	/^struct fsync_node_entry {$/;"	s
fsync_node_entry_slab	node.c	/^static struct kmem_cache *fsync_node_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
fsync_node_list	f2fs.h	/^	struct list_head fsync_node_list;	\/* node list head *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::list_head
fsync_node_lock	f2fs.h	/^	spinlock_t fsync_node_lock;		\/* for node entry lock *\/$/;"	m	struct:f2fs_sb_info
fsync_node_num	f2fs.h	/^	unsigned int fsync_node_num;		\/* number of node entries *\/$/;"	m	struct:f2fs_sb_info
fsync_seg_id	f2fs.h	/^	unsigned int fsync_seg_id;		\/* sequence id *\/$/;"	m	struct:f2fs_sb_info
full_nat_bits	f2fs.h	/^	unsigned char *full_nat_bits;	\/* full NAT pages *\/$/;"	m	struct:f2fs_nm_info
full_seg	f2fs.h	/^	unsigned int full_seg[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
gang_lookup_pids	trace.c	/^static unsigned int gang_lookup_pids(pid_t *results, unsigned long first_index,$/;"	f	file:
gc_data_segment	gc.c	/^static int gc_data_segment(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,$/;"	f	file:
gc_inode_list	gc.h	/^struct gc_inode_list {$/;"	s
gc_lock	f2fs.h	/^	struct rw_semaphore gc_lock;		\/*$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
gc_mode	f2fs.h	/^	unsigned int gc_mode;			\/* current GC state *\/$/;"	m	struct:f2fs_sb_info
gc_mode	segment.h	/^	int gc_mode;			\/* GC_CB or GC_GREEDY *\/$/;"	m	struct:victim_sel_policy
gc_node_segment	gc.c	/^static int gc_node_segment(struct f2fs_sb_info *sbi,$/;"	f	file:
gc_pin_file_threshold	f2fs.h	/^	u64 gc_pin_file_threshold;$/;"	m	struct:f2fs_sb_info
gc_thread	f2fs.h	/^	struct f2fs_gc_kthread	*gc_thread;	\/* GC thread *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_gc_kthread
gc_thread_func	gc.c	/^static int gc_thread_func(void *data)$/;"	f	file:
gc_wait_queue_head	gc.h	/^	wait_queue_head_t gc_wait_queue_head;$/;"	m	struct:f2fs_gc_kthread
gc_wake	gc.h	/^	unsigned int gc_wake;$/;"	m	struct:f2fs_gc_kthread
gdirty_list	f2fs.h	/^	struct list_head gdirty_list;	\/* linked in global dirty list *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::list_head
get_atssr_segment	segment.c	/^static void get_atssr_segment(struct f2fs_sb_info *sbi, int type,$/;"	f	file:
get_blocktype_secs	f2fs.h	/^static inline int get_blocktype_secs(struct f2fs_sb_info *sbi, int block_type)$/;"	f
get_cb_cost	gc.c	/^static unsigned int get_cb_cost(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f	file:
get_checkpoint_version	checkpoint.c	/^static int get_checkpoint_version(struct f2fs_sb_info *sbi, block_t cp_addr,$/;"	f	file:
get_ckpt_valid_blocks	segment.h	/^static inline unsigned int get_ckpt_valid_blocks(struct f2fs_sb_info *sbi,$/;"	f
get_current_nat_page	node.c	/^static struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f	file:
get_current_sit_page	segment.c	/^static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,$/;"	f	file:
get_data_block_dio	data.c	/^static int get_data_block_dio(struct inode *inode, sector_t iblock,$/;"	f	file:
get_data_block_dio_write	data.c	/^static int get_data_block_dio_write(struct inode *inode, sector_t iblock,$/;"	f	file:
get_ddm_info	segment.c	/^static void get_ddm_info(struct f2fs_sb_info *sbi, unsigned int segno, unsigned int offset, $/;"	f	file:
get_ddmap_from_extended_ddm_hash	segment.c	/^static unsigned long *get_ddmap_from_extended_ddm_hash(struct f2fs_sb_info *sbi, $/;"	f	file:
get_ddmap_from_extended_ddm_rb	segment.c	/^static unsigned long *get_ddmap_from_extended_ddm_rb(struct f2fs_sb_info *sbi, $/;"	f	file:
get_dirty_pages	f2fs.h	/^static inline int get_dirty_pages(struct inode *inode)$/;"	f
get_extent_info	f2fs.h	/^static inline void get_extent_info(struct extent_info *ext,$/;"	f
get_extra_isize	f2fs.h	/^static inline int get_extra_isize(struct inode *inode)$/;"	f
get_free_segment	segment.c	/^static unsigned int get_free_segment(struct f2fs_sb_info *sbi)$/;"	f	file:
get_free_zone	segment.c	/^static unsigned int get_free_zone(struct f2fs_sb_info *sbi)$/;"	f	file:
get_free_zone_in_superzone	segment.c	/^static unsigned int get_free_zone_in_superzone(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
get_fsync_inode	recovery.c	/^static struct fsync_inode_entry *get_fsync_inode(struct list_head *head,$/;"	f	file:
get_gc_cost	gc.c	/^static inline unsigned int get_gc_cost(struct f2fs_sb_info *sbi,$/;"	f	file:
get_inline_info	f2fs.h	/^static inline void get_inline_info(struct inode *inode, struct f2fs_inode *ri)$/;"	f
get_inline_xattr_addrs	f2fs.h	/^static inline int get_inline_xattr_addrs(struct inode *inode)$/;"	f
get_max_cost	gc.c	/^static unsigned int get_max_cost(struct f2fs_sb_info *sbi,$/;"	f	file:
get_mtime	segment.h	/^static inline unsigned long long get_mtime(struct f2fs_sb_info *sbi,$/;"	f
get_nat_bitmap	node.h	/^static inline void get_nat_bitmap(struct f2fs_sb_info *sbi, void *addr)$/;"	f
get_nat_flag	node.h	/^static inline bool get_nat_flag(struct nat_entry *ne, unsigned int type)$/;"	f
get_new_segment	segment.c	/^static void get_new_segment(struct f2fs_sb_info *sbi,$/;"	f	file:
get_new_segment_IFLBA	segment.c	/^static void get_new_segment_IFLBA(struct f2fs_sb_info *sbi,$/;"	f	file:
get_next_nat_page	node.c	/^static struct page *get_next_nat_page(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f	file:
get_next_sit_page	segment.c	/^static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,$/;"	f	file:
get_nid	node.h	/^static inline nid_t get_nid(struct page *p, int off, bool i)$/;"	f
get_node_path	node.c	/^static int get_node_path(struct inode *inode, long block,$/;"	f	file:
get_one_seg_bitmap_from_extended_ddm	segment.c	/^static unsigned long *get_one_seg_bitmap_from_extended_ddm(struct f2fs_sb_info *sbi, $/;"	f	file:
get_pages	f2fs.h	/^static inline s64 get_pages(struct f2fs_sb_info *sbi, int count_type)$/;"	f
get_parent_ino	file.c	/^static int get_parent_ino(struct inode *inode, nid_t *pino)$/;"	f	file:
get_sec_entry	segment.h	/^static inline struct sec_entry *get_sec_entry(struct f2fs_sb_info *sbi,$/;"	f
get_sectors_written	checkpoint.c	/^static inline u64 get_sectors_written(struct block_device *bdev)$/;"	f	file:
get_seg_dmap	segment.c	/^static unsigned long *get_seg_dmap(struct f2fs_sb_info *sbi, unsigned int p_segno){$/;"	f	file:
get_seg_entry	segment.h	/^static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,$/;"	f
get_segment_mtime	segment.c	/^static inline unsigned long long get_segment_mtime(struct f2fs_sb_info *sbi,$/;"	f	file:
get_sit_bitmap	segment.h	/^static inline void get_sit_bitmap(struct f2fs_sb_info *sbi,$/;"	f
get_ssr_segment	segment.c	/^static int get_ssr_segment(struct f2fs_sb_info *sbi, int type,$/;"	f	file:
get_target_zoned_dev	segment.c	/^static struct f2fs_dev_info *get_target_zoned_dev(struct f2fs_sb_info *sbi,$/;"	f	file:
get_valid_blocks	segment.h	/^static inline unsigned int get_valid_blocks(struct f2fs_sb_info *sbi,$/;"	f
get_victim	segment.h	/^	int (*get_victim)(struct f2fs_sb_info *, unsigned int *,$/;"	m	struct:victim_selection
get_victim_by_default	gc.c	/^static int get_victim_by_default(struct f2fs_sb_info *sbi,$/;"	f	file:
get_zone_idx	segment.c	/^static unsigned int get_zone_idx(struct f2fs_sb_info *sbi, unsigned int secno,$/;"	f	file:
grab_sit_entry_set	segment.c	/^static struct sit_entry_set *grab_sit_entry_set(void)$/;"	f	file:
granularity	f2fs.h	/^	unsigned int granularity;	\/* discard granularity *\/$/;"	m	struct:discard_policy
h_magic	xattr.h	/^	__le32  h_magic;        \/* magic number for identification *\/$/;"	m	struct:f2fs_xattr_header
h_refcount	xattr.h	/^	__le32  h_refcount;     \/* reference count *\/$/;"	m	struct:f2fs_xattr_header
h_reserved	xattr.h	/^	__u32   h_reserved[4];  \/* zero right now *\/$/;"	m	struct:f2fs_xattr_header
has_curseg_enough_space	segment.h	/^static inline bool has_curseg_enough_space(struct f2fs_sb_info *sbi)$/;"	f
has_enough_invalid_blocks	gc.h	/^static inline bool has_enough_invalid_blocks(struct f2fs_sb_info *sbi)$/;"	f
has_not_enough_free_physical_secs	segment.h	/^static inline bool has_not_enough_free_physical_secs(struct f2fs_sb_info *sbi,$/;"	f
has_not_enough_free_secs	segment.h	/^static inline bool has_not_enough_free_secs(struct f2fs_sb_info *sbi,$/;"	f
hash	f2fs.h	/^	f2fs_hash_t hash;$/;"	m	struct:f2fs_filename
hbits	f2fs.h	/^	unsigned int hbits;$/;"	m	struct:dynamic_discard_map_control
history_head	f2fs.h	/^	struct list_head history_head;		\/* contain every ddm entry *\/$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::list_head
history_list	f2fs.h	/^	struct list_head history_list; \/*existing all ddm list*\/$/;"	m	struct:dynamic_discard_map	typeref:struct:dynamic_discard_map::list_head
history_seg_cnt	f2fs.h	/^	atomic_t history_seg_cnt;$/;"	m	struct:dynamic_discard_map_control
hit_cached	f2fs.h	/^	unsigned long long hit_largest, hit_cached, hit_rbtree;$/;"	m	struct:f2fs_stat_info
hit_largest	f2fs.h	/^	unsigned long long hit_largest, hit_cached, hit_rbtree;$/;"	m	struct:f2fs_stat_info
hit_rbtree	f2fs.h	/^	unsigned long long hit_largest, hit_cached, hit_rbtree;$/;"	m	struct:f2fs_stat_info
hit_total	f2fs.h	/^	unsigned long long hit_total, total_ext;$/;"	m	struct:f2fs_stat_info
hnode	f2fs.h	/^	struct hlist_node hnode;$/;"	m	struct:dynamic_discard_map	typeref:struct:dynamic_discard_map::hlist_node
ht	f2fs.h	/^	struct hlist_head *ht;$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::hlist_head
i_acl_mode	f2fs.h	/^	umode_t i_acl_mode;		\/* keep file acl mode temporarily *\/$/;"	m	struct:f2fs_inode_info
i_advise	f2fs.h	/^	unsigned char i_advise;		\/* use to give file attribute hints *\/$/;"	m	struct:f2fs_inode_info
i_cluster_size	f2fs.h	/^	unsigned int i_cluster_size;		\/* cluster size *\/$/;"	m	struct:f2fs_inode_info
i_compr_blocks	f2fs.h	/^	atomic_t i_compr_blocks;		\/* # of compressed blocks *\/$/;"	m	struct:f2fs_inode_info
i_compress_algorithm	f2fs.h	/^	unsigned char i_compress_algorithm;	\/* algorithm type *\/$/;"	m	struct:f2fs_inode_info
i_compress_flag	f2fs.h	/^	unsigned short i_compress_flag;		\/* compress flag *\/$/;"	m	struct:f2fs_inode_info
i_crtime	f2fs.h	/^	struct timespec64 i_crtime;	\/* inode creation time *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::timespec64
i_current_depth	f2fs.h	/^	unsigned int i_current_depth;	\/* only for directory depth *\/$/;"	m	struct:f2fs_inode_info
i_dir_level	f2fs.h	/^	unsigned char i_dir_level;	\/* use for dentry level for large dir *\/$/;"	m	struct:f2fs_inode_info
i_disk_time	f2fs.h	/^	struct timespec64 i_disk_time[4];\/* inode disk times *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::timespec64
i_dquot	f2fs.h	/^	struct dquot *i_dquot[MAXQUOTAS];$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::dquot
i_extra_isize	f2fs.h	/^	int i_extra_isize;		\/* size of extra space located in i_addr *\/$/;"	m	struct:f2fs_inode_info
i_flags	f2fs.h	/^	unsigned long i_flags;		\/* keep an inode flags for ioctl *\/$/;"	m	struct:f2fs_inode_info
i_gc_failures	f2fs.h	/^	unsigned int i_gc_failures[MAX_GC_FAILURE];$/;"	m	struct:f2fs_inode_info
i_gc_rwsem	f2fs.h	/^	struct rw_semaphore i_gc_rwsem[2];$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::rw_semaphore
i_inline_xattr_size	f2fs.h	/^	int i_inline_xattr_size;	\/* inline xattr size *\/$/;"	m	struct:f2fs_inode_info
i_log_cluster_size	f2fs.h	/^	unsigned char i_log_cluster_size;	\/* log of cluster size *\/$/;"	m	struct:f2fs_inode_info
i_mmap_sem	f2fs.h	/^	struct rw_semaphore i_mmap_sem;$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::rw_semaphore
i_pino	f2fs.h	/^	unsigned int i_pino;		\/* parent inode number *\/$/;"	m	struct:f2fs_inode_info
i_projid	f2fs.h	/^	kprojid_t i_projid;		\/* id for project quota *\/$/;"	m	struct:f2fs_inode_info
i_reserved_quota	f2fs.h	/^	qsize_t i_reserved_quota;$/;"	m	struct:f2fs_inode_info
i_sem	f2fs.h	/^	struct rw_semaphore i_sem;	\/* protect fi info *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::rw_semaphore
i_size_lock	f2fs.h	/^	spinlock_t i_size_lock;		\/* protect last_disk_size *\/$/;"	m	struct:f2fs_inode_info
i_xattr_nid	f2fs.h	/^	nid_t i_xattr_nid;		\/* node id that contains xattrs *\/$/;"	m	struct:f2fs_inode_info
i_xattr_sem	f2fs.h	/^	struct rw_semaphore i_xattr_sem; \/* avoid racing between reading and changing EAs *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::rw_semaphore
id	sysfs.c	/^	int id;$/;"	m	struct:f2fs_attr	file:
iflag	file.c	/^	u32 iflag;$/;"	m	struct:__anon1	file:
iflag	file.c	/^	u32 iflag;$/;"	m	struct:__anon2	file:
ilist	gc.h	/^	struct list_head ilist;$/;"	m	struct:gc_inode_list	typeref:struct:gc_inode_list::list_head
im	f2fs.h	/^	struct inode_management im[MAX_INO_ENTRY];	\/* manage inode cache *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::inode_management
in_list	f2fs.h	/^	bool in_list;		\/* indicate fio is in io_list *\/$/;"	m	struct:f2fs_io_info
inc_node_version	node.h	75;"	d
inc_page_count	f2fs.h	/^static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)$/;"	f
inc_valid_block_count	f2fs.h	/^static inline int inc_valid_block_count(struct f2fs_sb_info *sbi,$/;"	f
inc_valid_inode_count	f2fs.h	/^static inline void inc_valid_inode_count(struct f2fs_sb_info *sbi)$/;"	f
inc_valid_node_count	f2fs.h	/^static inline int inc_valid_node_count(struct f2fs_sb_info *sbi,$/;"	f
increase_sleep_time	gc.h	/^static inline void increase_sleep_time(struct f2fs_gc_kthread *gc_th,$/;"	f
init_atgc_management	gc.c	/^static void init_atgc_management(struct f2fs_sb_info *sbi)$/;"	f	file:
init_blkz_info	super.c	/^static int init_blkz_info(struct f2fs_sb_info *sbi, int devi)$/;"	f	file:
init_compress_ctx	compress.c	/^	int (*init_compress_ctx)(struct compress_ctx *cc);$/;"	m	struct:f2fs_compress_ops	file:
init_decompress_ctx	compress.c	/^	int (*init_decompress_ctx)(struct decompress_io_ctx *dic);$/;"	m	struct:f2fs_compress_ops	file:
init_dent_inode	dir.c	/^static void init_dent_inode(struct inode *dir, struct inode *inode,$/;"	f	file:
init_dirty_segmap	segment.c	/^static void init_dirty_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
init_f2fs_fs	super.c	/^static int __init init_f2fs_fs(void)$/;"	f	file:
init_free_nid_cache	node.c	/^static int init_free_nid_cache(struct f2fs_sb_info *sbi)$/;"	f	file:
init_free_segmap	segment.c	/^static void init_free_segmap(struct f2fs_sb_info *sbi)$/;"	f	file:
init_inodecache	super.c	/^static int __init init_inodecache(void)$/;"	f	file:
init_min_max_mtime	segment.c	/^static void init_min_max_mtime(struct f2fs_sb_info *sbi)$/;"	f	file:
init_node_manager	node.c	/^static int init_node_manager(struct f2fs_sb_info *sbi)$/;"	f	file:
init_once	super.c	/^static void init_once(void *foo)$/;"	f	file:
init_percpu_info	super.c	/^static int init_percpu_info(struct f2fs_sb_info *sbi)$/;"	f	file:
init_recovered_filename	recovery.c	/^static int init_recovered_filename(const struct inode *dir,$/;"	f	file:
init_sb_info	super.c	/^static void init_sb_info(struct f2fs_sb_info *sbi)$/;"	f	file:
init_victim_secmap	segment.c	/^static int init_victim_secmap(struct f2fs_sb_info *sbi)$/;"	f	file:
inited	segment.h	/^	bool inited;				\/* indicate inmem log is inited *\/$/;"	m	struct:curseg_info
inject_ops	f2fs.h	/^	atomic_t inject_ops;$/;"	m	struct:f2fs_fault_info
inject_rate	f2fs.h	/^	unsigned int inject_rate;$/;"	m	struct:f2fs_fault_info
inject_type	f2fs.h	/^	unsigned int inject_type;$/;"	m	struct:f2fs_fault_info
inline_data_addr	f2fs.h	/^static inline void *inline_data_addr(struct inode *inode, struct page *page)$/;"	f
inline_dir	f2fs.h	/^	atomic_t inline_dir;			\/* # of inline_dentry inodes *\/$/;"	m	struct:f2fs_sb_info
inline_dir	f2fs.h	/^	int inline_xattr, inline_inode, inline_dir, append, update, orphans;$/;"	m	struct:f2fs_stat_info
inline_inode	f2fs.h	/^	atomic_t inline_inode;			\/* # of inline_data inodes *\/$/;"	m	struct:f2fs_sb_info
inline_inode	f2fs.h	/^	int inline_xattr, inline_inode, inline_dir, append, update, orphans;$/;"	m	struct:f2fs_stat_info
inline_xattr	f2fs.h	/^	atomic_t inline_xattr;			\/* # of inline_xattr inodes *\/$/;"	m	struct:f2fs_sb_info
inline_xattr	f2fs.h	/^	int inline_xattr, inline_inode, inline_dir, append, update, orphans;$/;"	m	struct:f2fs_stat_info
inline_xattr_addr	f2fs.h	/^static inline void *inline_xattr_addr(struct inode *inode, struct page *page)$/;"	f
inline_xattr_size	f2fs.h	/^	int inline_xattr_size;		\/* inline xattr size *\/$/;"	m	struct:f2fs_mount_info
inline_xattr_size	f2fs.h	/^static inline int inline_xattr_size(struct inode *inode)$/;"	f
inline_xattr_slab	f2fs.h	/^	struct kmem_cache *inline_xattr_slab;	\/* inline xattr entry *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::kmem_cache
inline_xattr_slab_size	f2fs.h	/^	unsigned int inline_xattr_slab_size;	\/* default inline xattr slab size *\/$/;"	m	struct:f2fs_sb_info
inmem_entry_slab	segment.c	/^static struct kmem_cache *inmem_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
inmem_ilist	f2fs.h	/^	struct list_head inmem_ilist;	\/* list for inmem inodes *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::list_head
inmem_lock	f2fs.h	/^	struct mutex inmem_lock;	\/* lock for inmemory pages *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::mutex
inmem_pages	f2fs.h	/^	int inmem_pages;$/;"	m	struct:f2fs_stat_info
inmem_pages	f2fs.h	/^	struct list_head inmem_pages;	\/* inmemory pages managed by f2fs *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::list_head
inmem_pages	segment.h	/^struct inmem_pages {$/;"	s
inmem_task	f2fs.h	/^	struct task_struct *inmem_task;	\/* store inmemory task *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::task_struct
ino	f2fs.h	/^	nid_t ino;			\/* inode number *\/$/;"	m	struct:extent_tree
ino	f2fs.h	/^	nid_t ino;			\/* inode number *\/$/;"	m	struct:ino_entry
ino	f2fs.h	/^	nid_t ino;		\/* inode number *\/$/;"	m	struct:f2fs_io_info
ino	f2fs.h	/^	nid_t ino;$/;"	m	struct:flush_cmd
ino	node.h	/^	nid_t ino;		\/* inode number of the node's owner *\/$/;"	m	struct:node_info
ino_entry	f2fs.h	/^struct ino_entry {$/;"	s
ino_entry_slab	checkpoint.c	/^static struct kmem_cache *ino_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
ino_list	f2fs.h	/^	struct list_head ino_list;		\/* inode list head *\/$/;"	m	struct:inode_management	typeref:struct:inode_management::list_head
ino_lock	f2fs.h	/^	spinlock_t ino_lock;			\/* for ino entry lock *\/$/;"	m	struct:inode_management
ino_num	f2fs.h	/^	unsigned long ino_num;			\/* number of entries *\/$/;"	m	struct:inode_management
ino_of_node	node.h	/^static inline nid_t ino_of_node(struct page *node_page)$/;"	f
ino_root	f2fs.h	/^	struct radix_tree_root ino_root;	\/* ino entry array *\/$/;"	m	struct:inode_management	typeref:struct:inode_management::radix_tree_root
inode	f2fs.h	/^	struct inode *inode;		\/* inode the context belong to *\/$/;"	m	struct:compress_ctx	typeref:struct:compress_ctx::inode
inode	f2fs.h	/^	struct inode *inode;		\/* inode the context belong to *\/$/;"	m	struct:compress_io_ctx	typeref:struct:compress_io_ctx::inode
inode	f2fs.h	/^	struct inode *inode;		\/* inode the context belong to *\/$/;"	m	struct:decompress_io_ctx	typeref:struct:decompress_io_ctx::inode
inode	f2fs.h	/^	struct inode *inode;		\/* vfs inode pointer *\/$/;"	m	struct:dnode_of_data	typeref:struct:dnode_of_data::inode
inode	f2fs.h	/^	struct inode *inode;	\/* vfs inode pointer *\/$/;"	m	struct:fsync_inode_entry	typeref:struct:fsync_inode_entry::inode
inode	f2fs.h	/^	struct inode *inode;	\/* vfs inode pointer *\/$/;"	m	struct:inode_entry	typeref:struct:inode_entry::inode
inode	f2fs.h	/^	struct inode *inode;$/;"	m	struct:f2fs_dentry_ptr	typeref:struct:f2fs_dentry_ptr::inode
inode	f2fs.h	/^	struct inode *inode;$/;"	m	struct:f2fs_private_dio	typeref:struct:f2fs_private_dio::inode
inode_dec_dirty_pages	f2fs.h	/^static inline void inode_dec_dirty_pages(struct inode *inode)$/;"	f
inode_entry	f2fs.h	/^struct inode_entry {$/;"	s
inode_inc_dirty_pages	f2fs.h	/^static inline void inode_inc_dirty_pages(struct inode *inode)$/;"	f
inode_list	f2fs.h	/^	struct list_head inode_list[NR_INODE_TYPE];	\/* dirty inode list *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::list_head
inode_lock	f2fs.h	/^	spinlock_t inode_lock[NR_INODE_TYPE];	\/* for dirty inode list lock *\/$/;"	m	struct:f2fs_sb_info
inode_management	f2fs.h	/^struct inode_management {$/;"	s
inode_page	f2fs.h	/^	struct page *inode_page;	\/* its inode page, NULL is possible *\/$/;"	m	struct:dnode_of_data	typeref:struct:dnode_of_data::page
inode_page_locked	f2fs.h	/^	bool inode_page_locked;		\/* inode page is locked or not *\/$/;"	m	struct:dnode_of_data
inode_type	f2fs.h	/^enum inode_type {$/;"	g
inplace_count	f2fs.h	/^	atomic_t inplace_count;		\/* # of inplace update *\/$/;"	m	struct:f2fs_sb_info
inplace_count	f2fs.h	/^	unsigned int inplace_count;$/;"	m	struct:f2fs_stat_info
insert_victim_entry	gc.c	/^static void insert_victim_entry(struct f2fs_sb_info *sbi,$/;"	f	file:
interval_time	f2fs.h	/^	long interval_time[MAX_TIME];		\/* to store thresholds *\/$/;"	m	struct:f2fs_sb_info
invalid_segmap	segment.h	/^	unsigned long *invalid_segmap;$/;"	m	struct:sit_info
io_aware	f2fs.h	/^	bool io_aware;			\/* issue discard in idle time *\/$/;"	m	struct:discard_policy
io_aware_gran	f2fs.h	/^	unsigned int io_aware_gran;	\/* minimum granularity discard not be aware of I\/O *\/$/;"	m	struct:discard_policy
io_is_mergeable	data.c	/^static bool io_is_mergeable(struct f2fs_sb_info *sbi, struct bio *bio,$/;"	f	file:
io_list	f2fs.h	/^	struct list_head io_list;	\/* track fios *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::list_head
io_lock	f2fs.h	/^	spinlock_t io_lock;		\/* serialize DATA\/NODE IOs *\/$/;"	m	struct:f2fs_bio_info
io_order_lock	f2fs.h	/^	struct rw_semaphore io_order_lock;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
io_rwsem	f2fs.h	/^	struct rw_semaphore io_rwsem;	\/* blocking op for bio *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::rw_semaphore
io_skip_bggc	f2fs.h	/^	unsigned int io_skip_bggc, other_skip_bggc;$/;"	m	struct:f2fs_stat_info
io_skip_bggc	f2fs.h	/^	unsigned int io_skip_bggc;		\/* skip background gc for in-flight IO *\/$/;"	m	struct:f2fs_sb_info
io_type	f2fs.h	/^	enum iostat_type io_type;	\/* io type *\/$/;"	m	struct:f2fs_io_info	typeref:enum:f2fs_io_info::iostat_type
io_type_is_mergeable	data.c	/^static bool io_type_is_mergeable(struct f2fs_bio_info *io,$/;"	f	file:
io_wbc	f2fs.h	/^	struct writeback_control *io_wbc; \/* writeback control *\/$/;"	m	struct:f2fs_io_info	typeref:struct:f2fs_io_info::writeback_control
iostat_enable	f2fs.h	/^	bool iostat_enable;$/;"	m	struct:f2fs_sb_info
iostat_info_seq_show	sysfs.c	/^static int __maybe_unused iostat_info_seq_show(struct seq_file *seq,$/;"	f	file:
iostat_lock	f2fs.h	/^	spinlock_t iostat_lock;$/;"	m	struct:f2fs_sb_info
iostat_next_period	f2fs.h	/^	unsigned long iostat_next_period;$/;"	m	struct:f2fs_sb_info
iostat_period_ms	f2fs.h	/^	unsigned int iostat_period_ms;$/;"	m	struct:f2fs_sb_info
iostat_type	f2fs.h	/^enum iostat_type {$/;"	g
ipu_policy	f2fs.h	/^	unsigned int ipu_policy;	\/* in-place-update policy *\/$/;"	m	struct:f2fs_sm_info
iroot	gc.h	/^	struct radix_tree_root iroot;$/;"	m	struct:gc_inode_list	typeref:struct:gc_inode_list::radix_tree_root
is_alive	gc.c	/^static bool is_alive(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,$/;"	f	file:
is_cold_data	node.h	/^static inline int is_cold_data(struct page *page)$/;"	f
is_cold_node	node.h	412;"	d
is_conv_zone	segment.c	/^static bool is_conv_zone(struct f2fs_sb_info *sbi, unsigned int zone_idx,$/;"	f	file:
is_dent_dnode	node.h	414;"	d
is_dirty	f2fs.h	/^	atomic_t is_dirty;		\/* DDM is dirty?*\/$/;"	m	struct:dynamic_discard_map
is_dot_dotdot	f2fs.h	/^static inline bool is_dot_dotdot(const u8 *name, size_t len)$/;"	f
is_empty_ddm	segment.c	/^static bool is_empty_ddm(struct f2fs_sb_info *sbi, struct dynamic_discard_map_control *ddmc,$/;"	f	file:
is_extension_exist	namei.c	/^static inline int is_extension_exist(const unsigned char *s, const char *sub)$/;"	f	file:
is_file	f2fs.h	/^static inline int is_file(struct inode *inode, int type)$/;"	f
is_fsync_dnode	node.h	413;"	d
is_idle	f2fs.h	/^static inline bool is_idle(struct f2fs_sb_info *sbi, int type)$/;"	f
is_inflight_io	f2fs.h	/^static inline bool is_inflight_io(struct f2fs_sb_info *sbi, int type)$/;"	f
is_inline_node	node.h	/^static inline int is_inline_node(struct page *page)$/;"	f
is_inode_flag_set	f2fs.h	/^static inline int is_inode_flag_set(struct inode *inode, int flag)$/;"	f
is_journalled_quota	f2fs.h	/^static inline bool is_journalled_quota(struct f2fs_sb_info *sbi)$/;"	f
is_next_segment_free	segment.c	/^static int is_next_segment_free(struct f2fs_sb_info *sbi,$/;"	f	file:
is_node	node.h	/^static inline int is_node(struct page *page, int type)$/;"	f
is_page_in_cluster	compress.c	/^static bool is_page_in_cluster(struct compress_ctx *cc, pgoff_t index)$/;"	f	file:
is_por	f2fs.h	/^	bool is_por;		\/* indicate IO is from recovery or not *\/$/;"	m	struct:f2fs_io_info
is_read_io	f2fs.h	1210;"	d
is_recoverable_dnode	node.h	/^static inline bool is_recoverable_dnode(struct page *page)$/;"	f
is_sbi_flag_set	f2fs.h	/^static inline bool is_sbi_flag_set(struct f2fs_sb_info *sbi, unsigned int type)$/;"	f
is_set_ckpt_flags	f2fs.h	/^static inline bool is_set_ckpt_flags(struct f2fs_sb_info *sbi, unsigned int f)$/;"	f
issue_all_discard_journals	segment.c	/^static void issue_all_discard_journals(struct f2fs_sb_info *sbi)$/;"	f	file:
issue_and_clean_all_ddm	segment.c	/^void issue_and_clean_all_ddm(struct f2fs_sb_info *sbi)$/;"	f
issue_discard_thread	segment.c	/^static int issue_discard_thread(void *data)$/;"	f	file:
issue_flush_thread	segment.c	/^static int issue_flush_thread(void *data)$/;"	f	file:
issue_list	f2fs.h	/^	struct llist_head issue_list;		\/* list for command issue *\/$/;"	m	struct:flush_cmd_control	typeref:struct:flush_cmd_control::llist_head
issue_small_discards_of_ddm	segment.c	/^static int issue_small_discards_of_ddm(struct f2fs_sb_info *sbi, struct dynamic_discard_map *ddm,$/;"	f	file:
issued_discard	f2fs.h	/^	atomic_t issued_discard;		\/* # of issued discard *\/$/;"	m	struct:discard_cmd_control
issued_discard_head	f2fs.h	/^	struct list_head issued_discard_head;		\/* issued discard cmd list *\/$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::list_head
issued_flush	f2fs.h	/^	atomic_t issued_flush;			\/* # of issued flushes *\/$/;"	m	struct:flush_cmd_control
journal	segment.h	/^	struct f2fs_journal *journal;		\/* cached journal info *\/$/;"	m	struct:curseg_info	typeref:struct:curseg_info::f2fs_journal
journal_issued_discard_cmd	segment.c	/^static void journal_issued_discard_cmd(struct f2fs_sb_info *sbi, block_t lstart, block_t len)$/;"	f	file:
journal_issued_discard_cmds	segment.c	/^static int journal_issued_discard_cmds(struct f2fs_sb_info *sbi)$/;"	f	file:
journal_rwsem	segment.h	/^	struct rw_semaphore journal_rwsem;	\/* protect journal area *\/$/;"	m	struct:curseg_info	typeref:struct:curseg_info::rw_semaphore
kbytes_written	f2fs.h	/^	u64 kbytes_written;$/;"	m	struct:f2fs_sb_info
key	f2fs.h	/^		unsigned long long key;		\/* 64-bits key *\/$/;"	m	union:rb_entry::__anon21
key	f2fs.h	/^	unsigned long long key;$/;"	m	struct:dynamic_discard_map
kill_f2fs_super	super.c	/^static void kill_f2fs_super(struct super_block *sb)$/;"	f	file:
largest	f2fs.h	/^	struct extent_info largest;	\/* largested extent info *\/$/;"	m	struct:extent_tree	typeref:struct:extent_tree::extent_info
largest_updated	f2fs.h	/^	bool largest_updated;		\/* largest extent updated *\/$/;"	m	struct:extent_tree
last_block	f2fs.h	/^	sector_t *last_block;		\/* last block number in bio *\/$/;"	m	struct:f2fs_io_info
last_block_in_bio	f2fs.h	/^	sector_t last_block_in_bio;	\/* last block number *\/$/;"	m	struct:f2fs_bio_info
last_dentry	f2fs.h	/^	block_t last_dentry;	\/* block address locating the last dentry *\/$/;"	m	struct:fsync_inode_entry
last_disk_size	f2fs.h	/^	loff_t	last_disk_size;		\/* lastly written file size *\/$/;"	m	struct:f2fs_inode_info
last_fsync_dnode	node.c	/^static struct page *last_fsync_dnode(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f	file:
last_io	trace.c	/^static struct last_io_info last_io;$/;"	v	typeref:struct:last_io_info	file:
last_io_info	trace.h	/^struct last_io_info {$/;"	s
last_time	f2fs.h	/^	unsigned long last_time[MAX_TIME];	\/* to store time in jiffies *\/$/;"	m	struct:f2fs_sb_info
last_valid_block_count	f2fs.h	/^	block_t last_valid_block_count;		\/* for recovery *\/$/;"	m	struct:f2fs_sb_info
last_victim	segment.h	/^	unsigned int last_victim[MAX_GC_POLICY]; \/* last victim segment # *\/$/;"	m	struct:sit_info
len	f2fs.h	/^			block_t len;	\/* length *\/$/;"	m	struct:discard_cmd::__anon17::__anon18
len	f2fs.h	/^			unsigned int len;	\/* length of the entry *\/$/;"	m	struct:rb_entry::__anon21::__anon22
len	f2fs.h	/^	block_t len;			\/* length *\/$/;"	m	struct:discard_info
len	f2fs.h	/^	unsigned int len;		\/* length of the extent *\/$/;"	m	struct:extent_info
len	f2fs.h	/^	unsigned int len;$/;"	m	struct:discard_range
len	file.c	/^	compat_u64 len;$/;"	m	struct:compat_f2fs_gc_range	file:
len	file.c	/^	compat_u64 len;$/;"	m	struct:compat_f2fs_move_range	file:
len	trace.h	/^	block_t len;$/;"	m	struct:last_io_info
lifetime_write_kbytes	sysfs.c	/^F2FS_GENERAL_RO_ATTR(lifetime_write_kbytes);$/;"	v
lifetime_write_kbytes_show	sysfs.c	/^static ssize_t lifetime_write_kbytes_show(struct f2fs_attr *a,$/;"	f	file:
limit_free_user_blocks	gc.h	/^static inline block_t limit_free_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
limit_invalid_user_blocks	gc.h	/^static inline block_t limit_invalid_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
limit_reserve_root	super.c	/^static inline void limit_reserve_root(struct f2fs_sb_info *sbi)$/;"	f	file:
list	f2fs.h	/^	struct list_head list;		\/* command list *\/$/;"	m	struct:discard_cmd	typeref:struct:discard_cmd::list_head
list	f2fs.h	/^	struct list_head list;		\/* list head *\/$/;"	m	struct:ino_entry	typeref:struct:ino_entry::list_head
list	f2fs.h	/^	struct list_head list;		\/* node in global extent list of sbi *\/$/;"	m	struct:extent_node	typeref:struct:extent_node::list_head
list	f2fs.h	/^	struct list_head list;		\/* serialize IOs *\/$/;"	m	struct:f2fs_io_info	typeref:struct:f2fs_io_info::list_head
list	f2fs.h	/^	struct list_head list;		\/* to be used by sbi->zombie_list *\/$/;"	m	struct:extent_tree	typeref:struct:extent_tree::list_head
list	f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:discard_entry	typeref:struct:discard_entry::list_head
list	f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:fsync_inode_entry	typeref:struct:fsync_inode_entry::list_head
list	f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:fsync_node_entry	typeref:struct:fsync_node_entry::list_head
list	f2fs.h	/^	struct list_head list;	\/* list head *\/$/;"	m	struct:inode_entry	typeref:struct:inode_entry::list_head
list	f2fs.h	/^	struct list_head list; 			\/* discard range entry list *\/$/;"	m	struct:discard_range_entry	typeref:struct:discard_range_entry::list_head
list	f2fs.h	/^	struct list_head list;$/;"	m	struct:bio_entry	typeref:struct:bio_entry::list_head
list	gc.h	/^	struct list_head list;$/;"	m	struct:victim_entry	typeref:struct:victim_entry::list_head
list	node.h	/^	struct list_head list;	\/* for clean or dirty nat list *\/$/;"	m	struct:nat_entry	typeref:struct:nat_entry::list_head
list	node.h	/^	struct list_head list;	\/* for free node id list *\/$/;"	m	struct:free_nid	typeref:struct:free_nid::list_head
list	segment.h	/^	struct list_head list;$/;"	m	struct:inmem_pages	typeref:struct:inmem_pages::list_head
list_for_each_xattr	xattr.h	70;"	d
llnode	f2fs.h	/^	struct llist_node llnode;$/;"	m	struct:flush_cmd	typeref:struct:flush_cmd::llist_node
load_free_nid_bitmap	node.c	/^static inline void load_free_nid_bitmap(struct f2fs_sb_info *sbi)$/;"	f	file:
locate_dirty_segment	segment.c	/^static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)$/;"	f	file:
lock	f2fs.h	/^	rwlock_t lock;			\/* protect extent info rb-tree *\/$/;"	m	struct:extent_tree
lock	f2fs.h	/^	spinlock_t lock;		\/* for state\/bio_ref updating *\/$/;"	m	struct:discard_cmd
log_blocks_per_blkz	f2fs.h	/^	unsigned int log_blocks_per_blkz;	\/* log2 F2FS blocks per zone *\/$/;"	m	struct:f2fs_sb_info
log_blocks_per_seg	f2fs.h	/^	unsigned int log_blocks_per_seg;	\/* log2 blocks per segment *\/$/;"	m	struct:f2fs_sb_info
log_blocksize	f2fs.h	/^	unsigned int log_blocksize;		\/* log2 block size *\/$/;"	m	struct:f2fs_sb_info
log_cluster_size	f2fs.h	/^	unsigned int log_cluster_size;	\/* log of cluster size *\/$/;"	m	struct:compress_ctx
log_cluster_size	f2fs.h	/^	unsigned int log_cluster_size;	\/* log of cluster size *\/$/;"	m	struct:decompress_io_ctx
log_sectors_per_block	f2fs.h	/^	unsigned int log_sectors_per_block;	\/* log2 sectors per block *\/$/;"	m	struct:f2fs_sb_info
long_threshold	f2fs.h	/^	unsigned int long_threshold;		\/* determine to issue discard directly or not*\/$/;"	m	struct:dynamic_discard_map_control
lookup_all_xattrs	xattr.c	/^static int lookup_all_xattrs(struct inode *inode, struct page *ipage,$/;"	f	file:
lookup_central_victim	gc.c	/^static struct rb_node *lookup_central_victim(struct f2fs_sb_info *sbi,$/;"	f	file:
lookup_victim_by_age	gc.c	/^static void lookup_victim_by_age(struct f2fs_sb_info *sbi,$/;"	f	file:
lstart	f2fs.h	/^			block_t lstart;	\/* logical start address *\/$/;"	m	struct:discard_cmd::__anon17::__anon18
lstart	f2fs.h	/^	block_t lstart;			\/* logical start address *\/$/;"	m	struct:discard_info
lz4_compress_pages	compress.c	/^static int lz4_compress_pages(struct compress_ctx *cc)$/;"	f	file:
lz4_decompress_pages	compress.c	/^static int lz4_decompress_pages(struct decompress_io_ctx *dic)$/;"	f	file:
lz4_destroy_compress_ctx	compress.c	/^static void lz4_destroy_compress_ctx(struct compress_ctx *cc)$/;"	f	file:
lz4_init_compress_ctx	compress.c	/^static int lz4_init_compress_ctx(struct compress_ctx *cc)$/;"	f	file:
lzo_compress_pages	compress.c	/^static int lzo_compress_pages(struct compress_ctx *cc)$/;"	f	file:
lzo_decompress_pages	compress.c	/^static int lzo_decompress_pages(struct decompress_io_ctx *dic)$/;"	f	file:
lzo_destroy_compress_ctx	compress.c	/^static void lzo_destroy_compress_ctx(struct compress_ctx *cc)$/;"	f	file:
lzo_init_compress_ctx	compress.c	/^static int lzo_init_compress_ctx(struct compress_ctx *cc)$/;"	f	file:
lzorle_compress_pages	compress.c	/^static int lzorle_compress_pages(struct compress_ctx *cc)$/;"	f	file:
m_flags	f2fs.h	/^	unsigned int m_flags;$/;"	m	struct:f2fs_map_blocks
m_lblk	f2fs.h	/^	block_t m_lblk;$/;"	m	struct:f2fs_map_blocks
m_len	f2fs.h	/^	unsigned int m_len;$/;"	m	struct:f2fs_map_blocks
m_may_create	f2fs.h	/^	bool m_may_create;		\/* indicate it is from write path *\/$/;"	m	struct:f2fs_map_blocks
m_next_extent	f2fs.h	/^	pgoff_t *m_next_extent;		\/* point to next possible extent *\/$/;"	m	struct:f2fs_map_blocks
m_next_pgofs	f2fs.h	/^	pgoff_t *m_next_pgofs;		\/* point next possible non-hole pgofs *\/$/;"	m	struct:f2fs_map_blocks
m_pblk	f2fs.h	/^	block_t m_pblk;$/;"	m	struct:f2fs_map_blocks
m_seg_type	f2fs.h	/^	int m_seg_type;$/;"	m	struct:f2fs_map_blocks
magic	f2fs.h	/^	u32 magic;			\/* magic number to indicate page is compressed *\/$/;"	m	struct:compress_io_ctx
magic	f2fs.h	/^	u32 magic;			\/* magic number to indicate page is compressed *\/$/;"	m	struct:decompress_io_ctx
magic	super.c	/^	__u16 magic;$/;"	m	struct:f2fs_sb_encodings	file:
main_area_sections	f2fs.h	/^	int main_area_segs, main_area_sections, main_area_zones;$/;"	m	struct:f2fs_stat_info
main_area_segs	f2fs.h	/^	int main_area_segs, main_area_sections, main_area_zones;$/;"	m	struct:f2fs_stat_info
main_area_zones	f2fs.h	/^	int main_area_segs, main_area_sections, main_area_zones;$/;"	m	struct:f2fs_stat_info
main_blkaddr	f2fs.h	/^	block_t main_blkaddr;		\/* start block address of main area *\/$/;"	m	struct:f2fs_sm_info
main_blkaddr	sysfs.c	/^F2FS_GENERAL_RO_ATTR(main_blkaddr);$/;"	v
main_blkaddr_show	sysfs.c	/^static ssize_t main_blkaddr_show(struct f2fs_attr *a,$/;"	f	file:
main_segments	f2fs.h	/^	unsigned int main_segments;	\/* # of segments in main area *\/$/;"	m	struct:f2fs_sm_info
major	trace.h	/^	int major, minor;$/;"	m	struct:last_io_info
make_dentry_ptr_block	f2fs.h	/^static inline void make_dentry_ptr_block(struct inode *inode,$/;"	f
make_dentry_ptr_inline	f2fs.h	/^static inline void make_dentry_ptr_inline(struct inode *inode,$/;"	f
make_empty_dir	dir.c	/^static int make_empty_dir(struct inode *inode,$/;"	f	file:
max	f2fs.h	/^	int max;$/;"	m	struct:f2fs_dentry_ptr
max_aw_cnt	f2fs.h	/^	atomic_t max_aw_cnt;			\/* max # of atomic writes *\/$/;"	m	struct:f2fs_sb_info
max_aw_cnt	f2fs.h	/^	int aw_cnt, max_aw_cnt, vw_cnt, max_vw_cnt;$/;"	m	struct:f2fs_stat_info
max_candidate_count	f2fs.h	/^	unsigned int max_candidate_count;	\/* max candidate count *\/$/;"	m	struct:atgc_management
max_discards	f2fs.h	/^	unsigned int max_discards;		\/* max. discards to be issued *\/$/;"	m	struct:discard_cmd_control
max_file_blocks	f2fs.h	/^	loff_t max_file_blocks;			\/* max block index of file *\/$/;"	m	struct:f2fs_sb_info
max_file_blocks	super.c	/^static loff_t max_file_blocks(void)$/;"	f	file:
max_inode_blocks	data.c	/^static loff_t max_inode_blocks(struct inode *inode)$/;"	f	file:
max_interval	f2fs.h	/^	unsigned int max_interval;	\/* used for candidates not exist *\/$/;"	m	struct:discard_policy
max_io_bytes	f2fs.h	/^	u64 max_io_bytes;			\/* max io bytes to merge IOs *\/$/;"	m	struct:f2fs_sb_info
max_level	f2fs.h	/^	char max_level;			\/* level of current page located *\/$/;"	m	struct:dnode_of_data
max_mtime	segment.h	/^	unsigned long long max_mtime;		\/* max. modification time *\/$/;"	m	struct:sit_info
max_nid	f2fs.h	/^	nid_t max_nid;			\/* maximum possible node ids *\/$/;"	m	struct:f2fs_nm_info
max_orphans	f2fs.h	/^	unsigned int max_orphans;		\/* max orphan inodes *\/$/;"	m	struct:f2fs_sb_info
max_requests	f2fs.h	/^	unsigned int max_requests;	\/* # of discards issued per round *\/$/;"	m	struct:discard_policy
max_search	segment.h	/^	unsigned int max_search;	\/*$/;"	m	struct:victim_sel_policy
max_sleep_time	gc.h	/^	unsigned int max_sleep_time;$/;"	m	struct:f2fs_gc_kthread
max_victim_search	f2fs.h	/^	unsigned int max_victim_search;$/;"	m	struct:f2fs_sb_info
max_vw_cnt	f2fs.h	/^	atomic_t max_vw_cnt;			\/* max # of volatile writes *\/$/;"	m	struct:f2fs_sb_info
max_vw_cnt	f2fs.h	/^	int aw_cnt, max_aw_cnt, vw_cnt, max_vw_cnt;$/;"	m	struct:f2fs_stat_info
mem_type	node.h	/^enum mem_type {$/;"	g
meta_count	f2fs.h	/^	atomic_t meta_count[META_MAX];		\/* # of meta blocks *\/$/;"	m	struct:f2fs_sb_info
meta_count	f2fs.h	/^	unsigned int meta_count[META_MAX];$/;"	m	struct:f2fs_stat_info
meta_ino_num	f2fs.h	/^	unsigned int meta_ino_num;		\/* meta inode number*\/$/;"	m	struct:f2fs_sb_info
meta_inode	f2fs.h	/^	struct inode *meta_inode;		\/* cache meta blocks *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::inode
meta_pages	f2fs.h	/^	int dirty_count, node_pages, meta_pages;$/;"	m	struct:f2fs_stat_info
mid_interval	f2fs.h	/^	unsigned int mid_interval;	\/* used for device busy *\/$/;"	m	struct:discard_policy
migration_granularity	f2fs.h	/^	unsigned int migration_granularity;$/;"	m	struct:f2fs_sb_info
min_cost	segment.h	/^	unsigned int min_cost;		\/* minimum cost *\/$/;"	m	struct:victim_sel_policy
min_fsync_blocks	f2fs.h	/^	unsigned int min_fsync_blocks;	\/* threshold for fsync *\/$/;"	m	struct:f2fs_sm_info
min_hot_blocks	f2fs.h	/^	unsigned int min_hot_blocks;	\/* threshold for hot block allocation *\/$/;"	m	struct:f2fs_sm_info
min_interval	f2fs.h	/^	unsigned int min_interval;	\/* used for candidates exist *\/$/;"	m	struct:discard_policy
min_ipu_util	f2fs.h	/^	unsigned int min_ipu_util;	\/* in-place-update threshold *\/$/;"	m	struct:f2fs_sm_info
min_mtime	segment.h	/^	unsigned long long min_mtime;		\/* min. modification time *\/$/;"	m	struct:sit_info
min_segno	segment.h	/^	unsigned int min_segno;		\/* segment # having min. cost *\/$/;"	m	struct:victim_sel_policy
min_seq_blocks	f2fs.h	/^	unsigned int min_seq_blocks;	\/* threshold for sequential blocks *\/$/;"	m	struct:f2fs_sm_info
min_sleep_time	gc.h	/^	unsigned int min_sleep_time;$/;"	m	struct:f2fs_gc_kthread
min_ssr_sections	f2fs.h	/^	unsigned int min_ssr_sections;	\/* threshold to trigger SSR allocation *\/$/;"	m	struct:f2fs_sm_info
minor	trace.h	/^	int major, minor;$/;"	m	struct:last_io_info
mount_opt	f2fs.h	/^	struct f2fs_mount_info mount_opt;	\/* mount options *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_mount_info
mounted_time	segment.h	/^	unsigned long long mounted_time;	\/* mount time *\/$/;"	m	struct:sit_info
mounted_time_sec	sysfs.c	/^F2FS_GENERAL_RO_ATTR(mounted_time_sec);$/;"	v
mounted_time_sec_show	sysfs.c	/^static ssize_t mounted_time_sec_show(struct f2fs_attr *a,$/;"	f	file:
move_data_block	gc.c	/^static int move_data_block(struct inode *inode, block_t bidx,$/;"	f	file:
move_data_page	gc.c	/^static int move_data_page(struct inode *inode, block_t bidx, int gc_type,$/;"	f	file:
moved_blocks_background	sysfs.c	/^F2FS_GENERAL_RO_ATTR(moved_blocks_background);$/;"	v
moved_blocks_background_show	sysfs.c	/^static ssize_t moved_blocks_background_show(struct f2fs_attr *a,$/;"	f	file:
moved_blocks_foreground	sysfs.c	/^F2FS_GENERAL_RO_ATTR(moved_blocks_foreground);$/;"	v
moved_blocks_foreground_show	sysfs.c	/^static ssize_t moved_blocks_foreground_show(struct f2fs_attr *a,$/;"	f	file:
mtime	gc.h	/^			unsigned long long mtime;	\/* mtime of section *\/$/;"	m	struct:victim_entry::__anon3::__anon4
mtime	gc.h	/^	unsigned long long mtime;	\/* mtime of section *\/$/;"	m	struct:victim_info
mtime	segment.h	/^	unsigned long long mtime;	\/* modification time of the segment *\/$/;"	m	struct:seg_entry
name	super.c	/^	char *name;$/;"	m	struct:f2fs_sb_encodings	file:
nat_area_segs	f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
nat_bitmap	f2fs.h	/^	char *nat_bitmap;		\/* NAT bitmap pointer *\/$/;"	m	struct:f2fs_nm_info
nat_bitmap_mir	f2fs.h	/^	char *nat_bitmap_mir;		\/* NAT bitmap mirror *\/$/;"	m	struct:f2fs_nm_info
nat_bits	f2fs.h	/^	unsigned char *nat_bits;	\/* NAT bits blocks *\/$/;"	m	struct:f2fs_nm_info
nat_bits_blocks	f2fs.h	/^	unsigned int nat_bits_blocks;	\/* # of nat bits blocks *\/$/;"	m	struct:f2fs_nm_info
nat_blkaddr	f2fs.h	/^	block_t nat_blkaddr;		\/* base disk address of NAT *\/$/;"	m	struct:f2fs_nm_info
nat_block_bitmap	f2fs.h	/^	unsigned char *nat_block_bitmap;$/;"	m	struct:f2fs_nm_info
nat_blocks	f2fs.h	/^	unsigned int nat_blocks;	\/* # of nat blocks *\/$/;"	m	struct:f2fs_nm_info
nat_cnt	f2fs.h	/^	unsigned int nat_cnt[MAX_NAT_STATE]; \/* the # of cached nat entries *\/$/;"	m	struct:f2fs_nm_info
nat_entries	f2fs.h	/^	struct list_head nat_entries;	\/* cached nat entry list (clean) *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::list_head
nat_entry	node.h	/^struct nat_entry {$/;"	s
nat_entry_set	node.h	/^struct nat_entry_set {$/;"	s
nat_entry_set_slab	node.c	/^static struct kmem_cache *nat_entry_set_slab;$/;"	v	typeref:struct:kmem_cache	file:
nat_entry_slab	node.c	/^static struct kmem_cache *nat_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
nat_get_blkaddr	node.h	68;"	d
nat_get_ino	node.h	70;"	d
nat_get_nid	node.h	66;"	d
nat_get_version	node.h	72;"	d
nat_in_journal	f2fs.h	377;"	d
nat_list_lock	f2fs.h	/^	spinlock_t nat_list_lock;	\/* protect clean nat entry list *\/$/;"	m	struct:f2fs_nm_info
nat_reset_flag	node.h	/^static inline void nat_reset_flag(struct nat_entry *ne)$/;"	f
nat_root	f2fs.h	/^	struct radix_tree_root nat_root;\/* root of the nat entry cache *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::radix_tree_root
nat_set_blkaddr	node.h	69;"	d
nat_set_ino	node.h	71;"	d
nat_set_nid	node.h	67;"	d
nat_set_root	f2fs.h	/^	struct radix_tree_root nat_set_root;\/* root of the nat set cache *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::radix_tree_root
nat_set_version	node.h	73;"	d
nat_state	f2fs.h	/^enum nat_state {$/;"	g
nat_tree_lock	f2fs.h	/^	struct rw_semaphore nat_tree_lock;	\/* protect nat_tree_lock *\/$/;"	m	struct:f2fs_nm_info	typeref:struct:f2fs_nm_info::rw_semaphore
nats	f2fs.h	/^	int nats, dirty_nats, sits, dirty_sits;$/;"	m	struct:f2fs_stat_info
nats_in_cursum	f2fs.h	374;"	d
ndirty_all	f2fs.h	/^	unsigned int ndirty_dirs, ndirty_files, nquota_files, ndirty_all;$/;"	m	struct:f2fs_stat_info
ndirty_data	f2fs.h	/^	int ndirty_data, ndirty_qdata;$/;"	m	struct:f2fs_stat_info
ndirty_dent	f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_meta, ndirty_imeta;$/;"	m	struct:f2fs_stat_info
ndirty_dirs	f2fs.h	/^	unsigned int ndirty_dirs, ndirty_files, nquota_files, ndirty_all;$/;"	m	struct:f2fs_stat_info
ndirty_files	f2fs.h	/^	unsigned int ndirty_dirs, ndirty_files, nquota_files, ndirty_all;$/;"	m	struct:f2fs_stat_info
ndirty_imeta	f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_meta, ndirty_imeta;$/;"	m	struct:f2fs_stat_info
ndirty_inode	f2fs.h	/^	unsigned int ndirty_inode[NR_INODE_TYPE];	\/* # of dirty inodes *\/$/;"	m	struct:f2fs_sb_info
ndirty_meta	f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_meta, ndirty_imeta;$/;"	m	struct:f2fs_stat_info
ndirty_node	f2fs.h	/^	int ndirty_node, ndirty_dent, ndirty_meta, ndirty_imeta;$/;"	m	struct:f2fs_stat_info
ndirty_qdata	f2fs.h	/^	int ndirty_data, ndirty_qdata;$/;"	m	struct:f2fs_stat_info
need_do_checkpoint	file.c	/^static inline enum cp_reason_type need_do_checkpoint(struct inode *inode)$/;"	f	file:
need_inode_page_update	file.c	/^static bool need_inode_page_update(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f	file:
need_inplace_update	data.c	/^static inline bool need_inplace_update(struct f2fs_io_info *fio)$/;"	f	file:
need_lock	f2fs.h	/^	int need_lock;		\/* indicate we need to lock cp_rwsem *\/$/;"	m	struct:f2fs_io_info
need_lock_type	f2fs.h	/^enum need_lock_type {$/;"	g
new_blkaddr	f2fs.h	/^	block_t new_blkaddr;	\/* new block address to be written *\/$/;"	m	struct:f2fs_io_info
new_curseg	segment.c	/^static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)$/;"	f	file:
new_curseg_IFLBA	segment.c	/^static void new_curseg_IFLBA(struct f2fs_sb_info *sbi, int type, bool new_sec)$/;"	f	file:
next_blkaddr_of_node	node.h	/^static inline block_t next_blkaddr_of_node(struct page *node_page)$/;"	f
next_blkoff	segment.h	/^	unsigned short next_blkoff;		\/* next block offset to write *\/$/;"	m	struct:curseg_info
next_free_nid	node.h	/^static inline void next_free_nid(struct f2fs_sb_info *sbi, nid_t *nid)$/;"	f
next_nat_addr	node.h	/^static inline pgoff_t next_nat_addr(struct f2fs_sb_info *sbi,$/;"	f
next_pos	f2fs.h	/^	unsigned int next_pos;			\/* next discard position *\/$/;"	m	struct:discard_cmd_control
next_scan_nid	f2fs.h	/^	nid_t next_scan_nid;		\/* the next nid to be scanned *\/$/;"	m	struct:f2fs_nm_info
next_segno	segment.h	/^	unsigned int next_segno;		\/* preallocated segment *\/$/;"	m	struct:curseg_info
next_sit_addr	segment.h	/^static inline pgoff_t next_sit_addr(struct f2fs_sb_info *sbi,$/;"	f
next_victim_seg	f2fs.h	/^	unsigned int next_victim_seg[2];	\/* next segment in victim section *\/$/;"	m	struct:f2fs_sb_info
ni	node.h	/^	struct node_info ni;	\/* in-memory node information *\/$/;"	m	struct:nat_entry	typeref:struct:nat_entry::node_info
nid	f2fs.h	/^	nid_t nid;			\/* node id of the direct node block *\/$/;"	m	struct:dnode_of_data
nid	node.h	/^	nid_t nid;		\/* node id *\/$/;"	m	struct:free_nid
nid	node.h	/^	nid_t nid;		\/* node id *\/$/;"	m	struct:node_info
nid_cnt	f2fs.h	/^	unsigned int nid_cnt[MAX_NID_STATE];	\/* the number of free node id *\/$/;"	m	struct:f2fs_nm_info
nid_in_journal	f2fs.h	378;"	d
nid_list_lock	f2fs.h	/^	spinlock_t nid_list_lock;	\/* protect nid lists ops *\/$/;"	m	struct:f2fs_nm_info
nid_of_node	node.h	/^static inline nid_t nid_of_node(struct page *node_page)$/;"	f
nid_state	f2fs.h	/^enum nid_state {$/;"	g
nid_t	f2fs.h	/^typedef u32 nid_t;$/;"	t
nm_info	f2fs.h	/^	struct f2fs_nm_info *nm_info;		\/* node manager *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_nm_info
no_gc_sleep_time	gc.h	/^	unsigned int no_gc_sleep_time;$/;"	m	struct:f2fs_gc_kthread
node_blks	f2fs.h	/^	int tot_blks, data_blks, node_blks;$/;"	m	struct:f2fs_stat_info
node_change	f2fs.h	/^	struct rw_semaphore node_change;	\/* locking node change *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
node_changed	f2fs.h	/^	bool node_changed;		\/* is node block changed *\/$/;"	m	struct:dnode_of_data
node_cnt	f2fs.h	/^	atomic_t node_cnt;			\/* dynamic discard map node count *\/$/;"	m	struct:dynamic_discard_map_control
node_cnt	f2fs.h	/^	atomic_t node_cnt;		\/* # of extent node in rb-tree*\/$/;"	m	struct:extent_tree
node_info	node.h	/^struct node_info {$/;"	s
node_info_from_raw_nat	node.h	/^static inline void node_info_from_raw_nat(struct node_info *ni,$/;"	f
node_ino_num	f2fs.h	/^	unsigned int node_ino_num;		\/* node inode number*\/$/;"	m	struct:f2fs_sb_info
node_inode	f2fs.h	/^	struct inode *node_inode;		\/* cache node blocks *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::inode
node_io_flag	f2fs.h	/^	unsigned int node_io_flag;$/;"	m	struct:f2fs_sb_info
node_page	f2fs.h	/^	struct page *node_page;		\/* cached direct node page *\/$/;"	m	struct:dnode_of_data	typeref:struct:dnode_of_data::page
node_pages	f2fs.h	/^	int dirty_count, node_pages, meta_pages;$/;"	m	struct:f2fs_stat_info
node_segs	f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
node_write	f2fs.h	/^	struct rw_semaphore node_write;		\/* locking node writes *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
nquota_files	f2fs.h	/^	unsigned int ndirty_dirs, ndirty_files, nquota_files, ndirty_all;$/;"	m	struct:f2fs_stat_info
nquota_files	f2fs.h	/^	unsigned int nquota_files;		\/* # of quota sysfile *\/$/;"	m	struct:f2fs_sb_info
nr_bitmap	f2fs.h	/^	int nr_bitmap;$/;"	m	struct:f2fs_dentry_ptr
nr_blkz	f2fs.h	/^	unsigned int nr_blkz;		\/* Total number of zones *\/$/;"	m	struct:f2fs_dev_info
nr_cpages	f2fs.h	/^	unsigned int nr_cpages;		\/* total page number in cpages *\/$/;"	m	struct:compress_ctx
nr_cpages	f2fs.h	/^	unsigned int nr_cpages;		\/* total page number in cpages *\/$/;"	m	struct:decompress_io_ctx
nr_dio_read	f2fs.h	/^	int nr_dio_read, nr_dio_write;$/;"	m	struct:f2fs_stat_info
nr_dio_write	f2fs.h	/^	int nr_dio_read, nr_dio_write;$/;"	m	struct:f2fs_stat_info
nr_dirty	segment.h	/^	int nr_dirty[NR_DIRTY_TYPE];		\/* # of dirty segments *\/$/;"	m	struct:dirty_seglist_info
nr_discard_cmd	f2fs.h	/^	int nr_discard_cmd;$/;"	m	struct:f2fs_stat_info
nr_discarded	f2fs.h	/^	int nr_discarding, nr_discarded;$/;"	m	struct:f2fs_stat_info
nr_discarding	f2fs.h	/^	int nr_discarding, nr_discarded;$/;"	m	struct:f2fs_stat_info
nr_discards	f2fs.h	/^	unsigned int nr_discards;		\/* # of discards in the list *\/$/;"	m	struct:discard_cmd_control
nr_flushed	f2fs.h	/^	int nr_flushing, nr_flushed, flush_list_empty;$/;"	m	struct:f2fs_stat_info
nr_flushing	f2fs.h	/^	int nr_flushing, nr_flushed, flush_list_empty;$/;"	m	struct:f2fs_stat_info
nr_pages	f2fs.h	/^	atomic_t nr_pages[NR_COUNT_TYPE];$/;"	m	struct:f2fs_sb_info
nr_pages_to_skip	segment.h	/^static inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)$/;"	f
nr_pages_to_write	segment.h	/^static inline long nr_pages_to_write(struct f2fs_sb_info *sbi, int type,$/;"	f
nr_rd_data	f2fs.h	/^	int nr_rd_data, nr_rd_node, nr_rd_meta;$/;"	m	struct:f2fs_stat_info
nr_rd_meta	f2fs.h	/^	int nr_rd_data, nr_rd_node, nr_rd_meta;$/;"	m	struct:f2fs_stat_info
nr_rd_node	f2fs.h	/^	int nr_rd_data, nr_rd_node, nr_rd_meta;$/;"	m	struct:f2fs_stat_info
nr_rpages	f2fs.h	/^	unsigned int nr_rpages;		\/* total page number in rpages *\/$/;"	m	struct:compress_ctx
nr_rpages	f2fs.h	/^	unsigned int nr_rpages;		\/* total page number in rpages *\/$/;"	m	struct:compress_io_ctx
nr_rpages	f2fs.h	/^	unsigned int nr_rpages;		\/* total page number in rpages *\/$/;"	m	struct:decompress_io_ctx
nr_wb_cp_data	f2fs.h	/^	int bg_gc, nr_wb_cp_data, nr_wb_data;$/;"	m	struct:f2fs_stat_info
nr_wb_data	f2fs.h	/^	int bg_gc, nr_wb_cp_data, nr_wb_data;$/;"	m	struct:f2fs_stat_info
num_compress_pages	compress.c	/^static int num_compress_pages = 512;$/;"	v	file:
offset	segment.h	/^	unsigned int offset;		\/* last scanned bitmap offset *\/$/;"	m	struct:victim_sel_policy
offset	sysfs.c	/^	int offset;$/;"	m	struct:f2fs_attr	file:
offset_in_addr	f2fs.h	/^static inline int offset_in_addr(struct f2fs_inode *i)$/;"	f
offset_in_cluster	compress.c	/^static unsigned int offset_in_cluster(struct compress_ctx *cc, pgoff_t index)$/;"	f	file:
ofs	f2fs.h	/^			unsigned int ofs;	\/* start offset of the entry *\/$/;"	m	struct:rb_entry::__anon21::__anon22
ofs_in_node	f2fs.h	/^	unsigned int ofs_in_node;	\/* data offset in the node page *\/$/;"	m	struct:dnode_of_data
ofs_of_node	node.h	/^static inline unsigned int ofs_of_node(struct page *node_page)$/;"	f
ofs_unit	segment.h	/^	unsigned int ofs_unit;		\/* bitmap search unit *\/$/;"	m	struct:victim_sel_policy
old_addr	segment.h	/^	block_t old_addr;		\/* for revoking when fail to commit *\/$/;"	m	struct:inmem_pages
old_blkaddr	f2fs.h	/^	block_t old_blkaddr;	\/* old block address before Cow *\/$/;"	m	struct:f2fs_io_info
oldest_age	segment.h	/^	unsigned long long oldest_age;	\/* oldest age of segments having the same min cost *\/$/;"	m	struct:victim_sel_policy
on_f2fs_build_free_nids	node.c	23;"	d	file:
op	f2fs.h	/^	int op;			\/* contains REQ_OP_ *\/$/;"	m	struct:f2fs_io_info
op_flags	f2fs.h	/^	int op_flags;		\/* req_flag_bits *\/$/;"	m	struct:f2fs_io_info
opt	f2fs.h	/^	unsigned int opt;$/;"	m	struct:f2fs_mount_info
ordered	f2fs.h	/^	bool ordered;			\/* issue discard by lba order *\/$/;"	m	struct:discard_policy
orig_end_io	f2fs.h	/^	bio_end_io_t *orig_end_io;$/;"	m	struct:f2fs_private_dio
orig_private	f2fs.h	/^	void *orig_private;$/;"	m	struct:f2fs_private_dio
orphans	f2fs.h	/^	int inline_xattr, inline_inode, inline_dir, append, update, orphans;$/;"	m	struct:f2fs_stat_info
other_skip_bggc	f2fs.h	/^	unsigned int io_skip_bggc, other_skip_bggc;$/;"	m	struct:f2fs_stat_info
other_skip_bggc	f2fs.h	/^	unsigned int other_skip_bggc;		\/* skip background gc for other reasons *\/$/;"	m	struct:f2fs_sb_info
overp_segs	f2fs.h	/^	int rsvd_segs, overp_segs;$/;"	m	struct:f2fs_stat_info
overprovision_segments	segment.h	/^static inline int overprovision_segments(struct f2fs_sb_info *sbi)$/;"	f
ovp_segments	f2fs.h	/^	unsigned int ovp_segments;	\/* # of overprovision segments *\/$/;"	m	struct:f2fs_sm_info
padding	segment.h	/^	unsigned int padding:6;		\/* padding *\/$/;"	m	struct:seg_entry
page	f2fs.h	/^	struct page *page;	\/* page to be written *\/$/;"	m	struct:f2fs_io_info	typeref:struct:f2fs_io_info::page
page	f2fs.h	/^	struct page *page;	\/* warm node page pointer *\/$/;"	m	struct:fsync_node_entry	typeref:struct:fsync_node_entry::page
page	segment.h	/^	struct page *page;$/;"	m	struct:inmem_pages	typeref:struct:inmem_pages::page
page_array_alloc	compress.c	/^static void *page_array_alloc(struct inode *inode, int nr)$/;"	f	file:
page_array_free	compress.c	/^static void page_array_free(struct inode *inode, void *pages, int nr)$/;"	f	file:
page_array_slab	f2fs.h	/^	struct kmem_cache *page_array_slab;	\/* page array entry *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::kmem_cache
page_array_slab_size	f2fs.h	/^	unsigned int page_array_slab_size;	\/* default page array slab size *\/$/;"	m	struct:f2fs_sb_info
page_is_mergeable	data.c	/^static bool page_is_mergeable(struct f2fs_sb_info *sbi, struct bio *bio,$/;"	f	file:
page_mem	f2fs.h	/^	unsigned long long base_mem, cache_mem, page_mem;$/;"	m	struct:f2fs_stat_info
page_type	f2fs.h	/^enum page_type {$/;"	g
pagecache_read	verity.c	/^static int pagecache_read(struct inode *inode, void *buf, size_t count,$/;"	f	file:
pagecache_write	verity.c	/^static int pagecache_write(struct inode *inode, const void *buf, size_t count,$/;"	f	file:
parse_options	super.c	/^static int parse_options(struct super_block *sb, char *options, bool is_remount)$/;"	f	file:
path	f2fs.h	/^	char path[MAX_PATH_LEN];$/;"	m	struct:f2fs_dev_info
pend_list	f2fs.h	/^	struct list_head pend_list[MAX_PLIST_NUM];\/* store pending entries *\/$/;"	m	struct:discard_cmd_control	typeref:struct:discard_cmd_control::list_head
pending_pages	f2fs.h	/^	atomic_t pending_pages;		\/* in-flight compressed page count *\/$/;"	m	struct:compress_io_ctx
pending_pages	f2fs.h	/^	atomic_t pending_pages;		\/* in-flight compressed page count *\/$/;"	m	struct:decompress_io_ctx
pid	trace.h	/^	pid_t pid;$/;"	m	struct:last_io_info
pids_lock	trace.c	/^static spinlock_t pids_lock;$/;"	v	file:
pin_sem	f2fs.h	/^	struct rw_semaphore pin_sem;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
plist_idx	f2fs.h	285;"	d
pos	verity.c	/^	__le64 pos;$/;"	m	struct:fsverity_descriptor_location	file:
pos_in	file.c	/^	compat_u64 pos_in;$/;"	m	struct:compat_f2fs_move_range	file:
pos_out	file.c	/^	compat_u64 pos_out;$/;"	m	struct:compat_f2fs_move_range	file:
post_read_wq	f2fs.h	/^	struct workqueue_struct *post_read_wq;	\/* post read workqueue *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::workqueue_struct
prefree_count	f2fs.h	/^	int prefree_count, call_count, cp_count, bg_cp_count;$/;"	m	struct:f2fs_stat_info
prefree_segments	segment.h	/^static inline unsigned int prefree_segments(struct f2fs_sb_info *sbi)$/;"	f
prepare_compress_overwrite	compress.c	/^static int prepare_compress_overwrite(struct compress_ctx *cc,$/;"	f	file:
prepare_write_begin	data.c	/^static int prepare_write_begin(struct f2fs_sb_info *sbi,$/;"	f	file:
prev_rw_iostat	f2fs.h	/^	unsigned long long prev_rw_iostat[NR_IO_TYPE];$/;"	m	struct:f2fs_sb_info
private2	f2fs.h	/^	void *private2;			\/* extra payload buffer *\/$/;"	m	struct:compress_ctx
private2	f2fs.h	/^	void *private2;			\/* extra payload buffer *\/$/;"	m	struct:decompress_io_ctx
punch_hole	file.c	/^static int punch_hole(struct inode *inode, loff_t offset, loff_t len)$/;"	f	file:
put_gc_inode	gc.c	/^static void put_gc_inode(struct gc_inode_list *gc_list)$/;"	f	file:
queued	f2fs.h	/^	unsigned char queued;		\/* queued discard *\/$/;"	m	struct:discard_cmd
queued_discard	f2fs.h	/^	atomic_t queued_discard;		\/* # of queued discard *\/$/;"	m	struct:discard_cmd_control
queued_flush	f2fs.h	/^	atomic_t queued_flush;			\/* # of queued flushes *\/$/;"	m	struct:flush_cmd_control
quota_sem	f2fs.h	/^	struct rw_semaphore quota_sem;		\/* blocking cp for flags *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
quotatypes	super.c	/^static const char * const quotatypes[] = INITQFNAMES;$/;"	v	file:
ra_data_block	gc.c	/^static int ra_data_block(struct inode *inode, pgoff_t index)$/;"	f	file:
ra_nid_pages	f2fs.h	/^	unsigned int ra_nid_pages;	\/* # of nid pages to be readaheaded *\/$/;"	m	struct:f2fs_nm_info
ra_offset	f2fs.h	/^	pgoff_t ra_offset;		\/* ongoing readahead offset *\/$/;"	m	struct:f2fs_inode_info
ram_thresh	f2fs.h	/^	unsigned int ram_thresh;	\/* control the memory footprint *\/$/;"	m	struct:f2fs_nm_info
raw_nat_from_node_info	node.h	/^static inline void raw_nat_from_node_info(struct f2fs_nat_entry *raw_ne,$/;"	f
raw_super	f2fs.h	/^	struct f2fs_super_block *raw_super;	\/* raw super block pointer *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_super_block
rb_entry	f2fs.h	/^struct rb_entry {$/;"	s
rb_node	f2fs.h	/^	struct rb_node rb_node;		\/* rb node located in rb-tree *\/$/;"	m	struct:discard_cmd	typeref:struct:discard_cmd::rb_node
rb_node	f2fs.h	/^	struct rb_node rb_node;		\/* rb node located in rb-tree *\/$/;"	m	struct:extent_node	typeref:struct:extent_node::rb_node
rb_node	f2fs.h	/^	struct rb_node rb_node;		\/* rb node located in rb-tree *\/$/;"	m	struct:rb_entry	typeref:struct:rb_entry::rb_node
rb_node	gc.h	/^	struct rb_node rb_node;		\/* rb node located in rb-tree *\/$/;"	m	struct:victim_entry	typeref:struct:victim_entry::rb_node
rbe	f2fs.h	/^	struct rb_entry rbe;$/;"	m	struct:dynamic_discard_map	typeref:struct:dynamic_discard_map::rb_entry
rbtree_check	f2fs.h	/^	bool rbtree_check;			\/* config for consistence check *\/$/;"	m	struct:discard_cmd_control
rbuf	f2fs.h	/^	void *rbuf;			\/* virtual mapped address on rpages *\/$/;"	m	struct:compress_ctx
rbuf	f2fs.h	/^	void *rbuf;			\/* virtual mapped address on rpages *\/$/;"	m	struct:decompress_io_ctx
read_all_xattrs	xattr.c	/^static int read_all_xattrs(struct inode *inode, struct page *ipage,$/;"	f	file:
read_compacted_summaries	segment.c	/^static int read_compacted_summaries(struct f2fs_sb_info *sbi)$/;"	f	file:
read_hit_cached	f2fs.h	/^	atomic64_t read_hit_cached;		\/* # of hit cached extent node *\/$/;"	m	struct:f2fs_sb_info
read_hit_largest	f2fs.h	/^	atomic64_t read_hit_largest;		\/* # of hit largest extent node *\/$/;"	m	struct:f2fs_sb_info
read_hit_rbtree	f2fs.h	/^	atomic64_t read_hit_rbtree;		\/* # of hit rbtree extent node *\/$/;"	m	struct:f2fs_sb_info
read_inline_xattr	xattr.c	/^static int read_inline_xattr(struct inode *inode, struct page *ipage,$/;"	f	file:
read_node_page	node.c	/^static int read_node_page(struct page *page, int op_flags)$/;"	f	file:
read_normal_summaries	segment.c	/^static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)$/;"	f	file:
read_raw_super_block	super.c	/^static int read_raw_super_block(struct f2fs_sb_info *sbi,$/;"	f	file:
read_xattr_block	xattr.c	/^static int read_xattr_block(struct inode *inode, void *txattr_addr)$/;"	f	file:
readdir_ra	f2fs.h	/^	int readdir_ra;				\/* readahead inode in readdir *\/$/;"	m	struct:f2fs_sb_info
reason	f2fs.h	/^	int reason;$/;"	m	struct:cp_control
rec_prefree_segments	f2fs.h	/^	unsigned int rec_prefree_segments;$/;"	m	struct:f2fs_sm_info
recover_data	recovery.c	/^static int recover_data(struct f2fs_sb_info *sbi, struct list_head *inode_list,$/;"	f	file:
recover_dentry	recovery.c	/^static int recover_dentry(struct inode *inode, struct page *ipage,$/;"	f	file:
recover_info_from_ddm	segment.c	/^static void recover_info_from_ddm(struct f2fs_sb_info *sbi, unsigned long long ddmkey, $/;"	f	file:
recover_inline_flags	recovery.c	/^static void recover_inline_flags(struct inode *inode, struct f2fs_inode *ri)$/;"	f	file:
recover_inode	recovery.c	/^static int recover_inode(struct inode *inode, struct page *page)$/;"	f	file:
recover_orphan_inode	checkpoint.c	/^static int recover_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f	file:
recover_quota_data	recovery.c	/^static int recover_quota_data(struct inode *inode, struct page *page)$/;"	f	file:
redirty_blocks	file.c	/^static int redirty_blocks(struct inode *inode, pgoff_t page_idx, int len)$/;"	f	file:
ref	f2fs.h	/^	unsigned short ref;		\/* reference count *\/$/;"	m	struct:discard_cmd
release_compress_blocks	file.c	/^static int release_compress_blocks(struct dnode_of_data *dn, pgoff_t count)$/;"	f	file:
release_discard_addr	segment.c	/^static void release_discard_addr(struct discard_entry *entry)$/;"	f	file:
release_discard_range	segment.c	/^static void release_discard_range(struct discard_range_entry *entry)$/;"	f	file:
release_sit_entry_set	segment.c	/^static void release_sit_entry_set(struct sit_entry_set *ses)$/;"	f	file:
release_victim_entry	gc.c	/^static void release_victim_entry(struct f2fs_sb_info *sbi)$/;"	f	file:
remove_ddm_journals	segment.c	/^static void remove_ddm_journals(struct f2fs_sb_info *sbi, struct dynamic_discard_map *ddm)$/;"	f	file:
remove_free_nid	node.c	/^static void remove_free_nid(struct f2fs_sb_info *sbi, nid_t nid)$/;"	f	file:
remove_issued_discard_cmds	segment.c	/^static void remove_issued_discard_cmds(struct f2fs_sb_info *sbi)$/;"	f	file:
remove_nats_in_journal	node.c	/^static void remove_nats_in_journal(struct f2fs_sb_info *sbi)$/;"	f	file:
remove_sits_in_journal	segment.c	/^static void remove_sits_in_journal(struct f2fs_sb_info *sbi)$/;"	f	file:
report_one_zone_cb	segment.c	/^static int report_one_zone_cb(struct blk_zone *zone, unsigned int idx,$/;"	f	file:
reserve_compress_blocks	file.c	/^static int reserve_compress_blocks(struct dnode_of_data *dn, pgoff_t count)$/;"	f	file:
reserved	f2fs.h	/^	__le32 reserved[COMPRESS_DATA_RESERVED_SIZE];	\/* reserved *\/$/;"	m	struct:compress_data
reserved_blocks	f2fs.h	/^	block_t reserved_blocks;		\/* configurable reserved blocks *\/$/;"	m	struct:f2fs_sb_info
reserved_sections	segment.h	/^static inline int reserved_sections(struct f2fs_sb_info *sbi)$/;"	f
reserved_segments	f2fs.h	/^	unsigned int reserved_segments;	\/* # of reserved segments *\/$/;"	m	struct:f2fs_sm_info
reserved_segments	segment.h	/^static inline unsigned int reserved_segments(struct f2fs_sb_info *sbi)$/;"	f
reset_curseg	segment.c	/^static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)$/;"	f	file:
restore_curseg_summaries	segment.c	/^static int restore_curseg_summaries(struct f2fs_sb_info *sbi)$/;"	f	file:
ret	f2fs.h	/^	int ret;$/;"	m	struct:flush_cmd
retry	f2fs.h	/^	bool retry;		\/* need to reallocate block address *\/$/;"	m	struct:f2fs_io_info
rlen	f2fs.h	/^	size_t rlen;			\/* valid data length in rbuf *\/$/;"	m	struct:compress_ctx
rlen	f2fs.h	/^	size_t rlen;			\/* valid data length in rbuf *\/$/;"	m	struct:decompress_io_ctx
root	f2fs.h	/^	struct rb_root_cached root;		\/* root of discard map rb-tree *\/$/;"	m	struct:dynamic_discard_map_control	typeref:struct:dynamic_discard_map_control::rb_root_cached
root	f2fs.h	/^	struct rb_root_cached root;		\/* root of discard rb-tree *\/$/;"	m	struct:discard_cmd_control	typeref:struct:discard_cmd_control::rb_root_cached
root	f2fs.h	/^	struct rb_root_cached root;		\/* root of victim rb-tree *\/$/;"	m	struct:atgc_management	typeref:struct:atgc_management::rb_root_cached
root	f2fs.h	/^	struct rb_root_cached root;	\/* root of extent info rb-tree *\/$/;"	m	struct:extent_tree	typeref:struct:extent_tree::rb_root_cached
root_ino_num	f2fs.h	/^	unsigned int root_ino_num;		\/* root inode number*\/$/;"	m	struct:f2fs_sb_info
root_reserved_blocks	f2fs.h	/^	block_t root_reserved_blocks;	\/* root reserved blocks *\/$/;"	m	struct:f2fs_mount_info
rpages	f2fs.h	/^	struct page **rpages;		\/* pages store raw data in cluster *\/$/;"	m	struct:compress_ctx	typeref:struct:compress_ctx::page
rpages	f2fs.h	/^	struct page **rpages;		\/* pages store raw data in cluster *\/$/;"	m	struct:compress_io_ctx	typeref:struct:compress_io_ctx::page
rpages	f2fs.h	/^	struct page **rpages;		\/* pages store raw data in cluster *\/$/;"	m	struct:decompress_io_ctx	typeref:struct:decompress_io_ctx::page
rsvd_segs	f2fs.h	/^	int rsvd_segs, overp_segs;$/;"	m	struct:f2fs_stat_info
rw_iostat	f2fs.h	/^	unsigned long long rw_iostat[NR_IO_TYPE];$/;"	m	struct:f2fs_sb_info
s_chksum_driver	f2fs.h	/^	struct crypto_shash *s_chksum_driver;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::crypto_shash
s_chksum_seed	f2fs.h	/^	__u32 s_chksum_seed;$/;"	m	struct:f2fs_sb_info
s_flag	f2fs.h	/^	unsigned long s_flag;				\/* flags for sbi *\/$/;"	m	struct:f2fs_sb_info
s_jquota_fmt	f2fs.h	/^	int s_jquota_fmt;			\/* Format of quota to use *\/$/;"	m	struct:f2fs_mount_info
s_kobj	f2fs.h	/^	struct kobject s_kobj;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::kobject
s_kobj_unregister	f2fs.h	/^	struct completion s_kobj_unregister;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::completion
s_list	f2fs.h	/^	struct list_head s_list;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::list_head
s_ndevs	f2fs.h	/^	int s_ndevs;				\/* number of devices *\/$/;"	m	struct:f2fs_sb_info
s_ops	segment.h	/^	const struct segment_allocation *s_ops;$/;"	m	struct:sit_info	typeref:struct:sit_info::segment_allocation
s_proc	f2fs.h	/^	struct proc_dir_entry *s_proc;		\/* proc entry *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::proc_dir_entry
s_qf_names	f2fs.h	/^	char *s_qf_names[MAXQUOTAS];$/;"	m	struct:f2fs_mount_info
s_resgid	f2fs.h	/^	kgid_t s_resgid;		\/* reserved blocks for gid *\/$/;"	m	struct:f2fs_mount_info
s_resuid	f2fs.h	/^	kuid_t s_resuid;		\/* reserved blocks for uid *\/$/;"	m	struct:f2fs_mount_info
sanity_check_area_boundary	super.c	/^static inline bool sanity_check_area_boundary(struct f2fs_sb_info *sbi,$/;"	f	file:
sanity_check_curseg	segment.c	/^static int sanity_check_curseg(struct f2fs_sb_info *sbi)$/;"	f	file:
sanity_check_inode	inode.c	/^static bool sanity_check_inode(struct inode *inode, struct page *node_page)$/;"	f	file:
sanity_check_raw_super	super.c	/^static int sanity_check_raw_super(struct f2fs_sb_info *sbi,$/;"	f	file:
sanity_check_seg_type	segment.h	/^static inline void sanity_check_seg_type(struct f2fs_sb_info *sbi,$/;"	f
sb	f2fs.h	/^	struct super_block *sb;			\/* pointer to VFS super block *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::super_block
sb_lock	f2fs.h	/^	struct rw_semaphore sb_lock;		\/* lock for raw super block *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::rw_semaphore
sbi	data.c	/^	struct f2fs_sb_info *sbi;$/;"	m	struct:bio_post_read_ctx	typeref:struct:bio_post_read_ctx::f2fs_sb_info	file:
sbi	f2fs.h	/^	struct f2fs_sb_info *sbi;	\/* f2fs superblock *\/$/;"	m	struct:f2fs_bio_info	typeref:struct:f2fs_bio_info::f2fs_sb_info
sbi	f2fs.h	/^	struct f2fs_sb_info *sbi;	\/* f2fs_sb_info pointer *\/$/;"	m	struct:f2fs_io_info	typeref:struct:f2fs_io_info::f2fs_sb_info
sbi	f2fs.h	/^	struct f2fs_sb_info *sbi;$/;"	m	struct:f2fs_stat_info	typeref:struct:f2fs_stat_info::f2fs_sb_info
sbi	segment.c	/^       struct f2fs_sb_info *sbi;$/;"	m	struct:check_zone_write_pointer_args	typeref:struct:check_zone_write_pointer_args::f2fs_sb_info	file:
scan_curseg_cache	node.c	/^static void scan_curseg_cache(struct f2fs_sb_info *sbi)$/;"	f	file:
scan_free_nid_bits	node.c	/^static void scan_free_nid_bits(struct f2fs_sb_info *sbi)$/;"	f	file:
scan_nat_page	node.c	/^static int scan_nat_page(struct f2fs_sb_info *sbi,$/;"	f	file:
sec_entries	segment.h	/^	struct sec_entry *sec_entries;		\/* SIT section-level cache *\/$/;"	m	struct:sit_info	typeref:struct:sit_info::sec_entry
sec_entry	segment.h	/^struct sec_entry {$/;"	s
sec_usage_check	segment.h	/^static inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)$/;"	f
secs_per_zone	f2fs.h	/^	unsigned int secs_per_zone;		\/* sections per zone *\/$/;"	m	struct:f2fs_sb_info
sectors_written_start	f2fs.h	/^	u64 sectors_written_start;$/;"	m	struct:f2fs_sb_info
seg0_blkaddr	f2fs.h	/^	block_t seg0_blkaddr;		\/* block address of 0'th segment *\/$/;"	m	struct:f2fs_sm_info
seg_entry	segment.h	/^struct seg_entry {$/;"	s
seg_info_from_raw_sit	segment.h	/^static inline void seg_info_from_raw_sit(struct seg_entry *se,$/;"	f
seg_info_to_raw_sit	segment.h	/^static inline void seg_info_to_raw_sit(struct seg_entry *se,$/;"	f
seg_info_to_sit_page	segment.h	/^static inline void seg_info_to_sit_page(struct f2fs_sb_info *sbi,$/;"	f
seg_type	segment.h	/^	unsigned short seg_type;		\/* segment type like CURSEG_XXX_TYPE *\/$/;"	m	struct:curseg_info
seglist_lock	segment.h	/^	struct mutex seglist_lock;		\/* lock for segment bitmaps *\/$/;"	m	struct:dirty_seglist_info	typeref:struct:dirty_seglist_info::mutex
segmap_lock	segment.h	/^	spinlock_t segmap_lock;		\/* free segmap lock *\/$/;"	m	struct:free_segmap_info
segment_allocation	segment.h	/^struct segment_allocation {$/;"	s
segment_bits_seq_show	sysfs.c	/^static int __maybe_unused segment_bits_seq_show(struct seq_file *seq,$/;"	f	file:
segment_count	f2fs.h	/^	unsigned int segment_count;	\/* total # of segments *\/$/;"	m	struct:f2fs_sm_info
segment_count	f2fs.h	/^	unsigned int segment_count[2];		\/* # of allocated segments *\/$/;"	m	struct:f2fs_sb_info
segment_count	f2fs.h	/^	unsigned int segment_count[2];$/;"	m	struct:f2fs_stat_info
segment_info_seq_show	sysfs.c	/^static int __maybe_unused segment_info_seq_show(struct seq_file *seq,$/;"	f	file:
segno	gc.h	/^			unsigned int segno;		\/* segment No. *\/$/;"	m	struct:victim_entry::__anon3::__anon4
segno	gc.h	/^	unsigned int segno;		\/* section No. *\/$/;"	m	struct:victim_info
segno	segment.h	/^	unsigned int segno;			\/* current segment number *\/$/;"	m	struct:curseg_info
segno_in_journal	f2fs.h	380;"	d
segs_per_node	f2fs.h	/^	unsigned int segs_per_node;		\/*number of segments each node manages*\/$/;"	m	struct:dynamic_discard_map_control
segs_per_sec	f2fs.h	/^	unsigned int segs_per_sec;		\/* segments per section *\/$/;"	m	struct:f2fs_sb_info
select_gc_type	gc.c	/^static int select_gc_type(struct f2fs_sb_info *sbi, int gc_type)$/;"	f	file:
select_policy	gc.c	/^static void select_policy(struct f2fs_sb_info *sbi, int gc_type,$/;"	f	file:
sentries	segment.h	/^	struct seg_entry *sentries;		\/* SIT segment-level cache *\/$/;"	m	struct:sit_info	typeref:struct:sit_info::seg_entry
sentry_lock	segment.h	/^	struct rw_semaphore sentry_lock;	\/* to protect SIT cache *\/$/;"	m	struct:sit_info	typeref:struct:sit_info::rw_semaphore
sents_per_block	segment.h	/^	unsigned int sents_per_block;		\/* # of SIT entries per block *\/$/;"	m	struct:sit_info
seq_id	f2fs.h	/^	unsigned int seq_id;	\/* sequence id *\/$/;"	m	struct:fsync_node_entry
set	node.h	/^	nid_t set;			\/* set number*\/$/;"	m	struct:nat_entry_set
set_acl_inode	f2fs.h	/^static inline void set_acl_inode(struct inode *inode, umode_t mode)$/;"	f
set_ckpt_flags	f2fs.h	/^static inline void set_ckpt_flags(struct f2fs_sb_info *sbi, unsigned int f)$/;"	f
set_cluster_dirty	compress.c	/^static void set_cluster_dirty(struct compress_ctx *cc)$/;"	f	file:
set_cluster_writeback	compress.c	/^static void set_cluster_writeback(struct compress_ctx *cc)$/;"	f	file:
set_cold_data	node.h	/^static inline void set_cold_data(struct page *page)$/;"	f
set_cold_node	node.h	/^static inline void set_cold_node(struct page *page, bool is_dir)$/;"	f
set_compress_context	f2fs.h	/^static inline void set_compress_context(struct inode *inode)$/;"	f
set_compress_inode	namei.c	/^static void set_compress_inode(struct f2fs_sb_info *sbi, struct inode *inode,$/;"	f	file:
set_de_type	dir.c	/^static void set_de_type(struct f2fs_dir_entry *de, umode_t mode)$/;"	f	file:
set_dentry_mark	node.h	457;"	d
set_extent_info	f2fs.h	/^static inline void set_extent_info(struct extent_info *ei, unsigned int fofs,$/;"	f
set_file	f2fs.h	/^static inline void set_file(struct inode *inode, int type)$/;"	f
set_file_temperature	namei.c	/^static inline void set_file_temperature(struct f2fs_sb_info *sbi, struct inode *inode,$/;"	f	file:
set_fsync_mark	node.h	458;"	d
set_inline_node	node.h	/^static inline void set_inline_node(struct page *page)$/;"	f
set_inode_flag	f2fs.h	/^static inline void set_inode_flag(struct inode *inode, int flag)$/;"	f
set_list	node.h	/^	struct list_head set_list;	\/* link with other nat sets *\/$/;"	m	struct:nat_entry_set	typeref:struct:nat_entry_set::list_head
set_list	segment.h	/^	struct list_head set_list;	\/* link with all sit sets *\/$/;"	m	struct:sit_entry_set	typeref:struct:sit_entry_set::list_head
set_mark	node.h	/^static inline void set_mark(struct page *page, int mark, int type)$/;"	f
set_nat_flag	node.h	/^static inline void set_nat_flag(struct nat_entry *ne,$/;"	f
set_new_dnode	f2fs.h	/^static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,$/;"	f
set_nid	node.h	/^static inline int set_nid(struct page *p, int off, nid_t nid, bool i)$/;"	f
set_node_addr	node.c	/^static void set_node_addr(struct f2fs_sb_info *sbi, struct node_info *ni,$/;"	f	file:
set_opt	f2fs.h	103;"	d
set_prefree_as_free_segments	segment.c	/^static void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)$/;"	f	file:
set_raw_extent	f2fs.h	/^static inline void set_raw_extent(struct extent_info *ext,$/;"	f
set_raw_inline	f2fs.h	/^static inline void set_raw_inline(struct inode *inode, struct f2fs_inode *ri)$/;"	f
set_sbi_flag	f2fs.h	/^static inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)$/;"	f
set_summary	segment.h	/^static inline void set_summary(struct f2fs_summary *sum, nid_t nid,$/;"	f
set_to_next_nat	node.h	/^static inline void set_to_next_nat(struct f2fs_nm_info *nm_i, nid_t start_nid)$/;"	f
set_to_next_sit	segment.h	/^static inline void set_to_next_sit(struct sit_info *sit_i, unsigned int start)$/;"	f
show	sysfs.c	/^	ssize_t (*show)(struct f2fs_attr *, struct f2fs_sb_info *, char *);$/;"	m	struct:f2fs_attr	file:
shrinker_run_no	f2fs.h	/^	unsigned int shrinker_run_no;$/;"	m	struct:f2fs_sb_info
shrinker_run_no	shrinker.c	/^static unsigned int shrinker_run_no;$/;"	v	file:
sit_area_segs	f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
sit_base_addr	segment.h	/^	block_t sit_base_addr;		\/* start block address of SIT area *\/$/;"	m	struct:sit_info
sit_bitmap	segment.h	/^	char *sit_bitmap;		\/* SIT bitmap pointer *\/$/;"	m	struct:sit_info
sit_bitmap_mir	segment.h	/^	char *sit_bitmap_mir;		\/* SIT bitmap mirror *\/$/;"	m	struct:sit_info
sit_blocks	segment.h	/^	block_t sit_blocks;		\/* # of blocks used by SIT area *\/$/;"	m	struct:sit_info
sit_entry_set	f2fs.h	/^	struct list_head sit_entry_set;	\/* sit entry set list *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::list_head
sit_entry_set	segment.h	/^struct sit_entry_set {$/;"	s
sit_entry_set_slab	segment.c	/^static struct kmem_cache *sit_entry_set_slab;$/;"	v	typeref:struct:kmem_cache	file:
sit_in_journal	f2fs.h	379;"	d
sit_info	f2fs.h	/^	struct sit_info *sit_info;		\/* whole segment information *\/$/;"	m	struct:f2fs_sm_info	typeref:struct:f2fs_sm_info::sit_info
sit_info	segment.h	/^struct sit_info {$/;"	s
sits	f2fs.h	/^	int nats, dirty_nats, sits, dirty_sits;$/;"	m	struct:f2fs_stat_info
sits_in_cursum	f2fs.h	375;"	d
size	verity.c	/^	__le32 size;$/;"	m	struct:fsverity_descriptor_location	file:
skipped_atomic_files	f2fs.h	/^	unsigned long long skipped_atomic_files[2];	\/* FG_GC and BG_GC *\/$/;"	m	struct:f2fs_sb_info
skipped_atomic_files	f2fs.h	/^	unsigned long long skipped_atomic_files[2];$/;"	m	struct:f2fs_stat_info
skipped_gc_rwsem	f2fs.h	/^	unsigned long long skipped_gc_rwsem;		\/* FG_GC only *\/$/;"	m	struct:f2fs_sb_info
sm_info	f2fs.h	/^	struct f2fs_sm_info *sm_info;		\/* segment manager *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_sm_info
ssa_area_segs	f2fs.h	/^	int all_area_segs, sit_area_segs, nat_area_segs, ssa_area_segs;$/;"	m	struct:f2fs_stat_info
ssa_blkaddr	f2fs.h	/^	block_t ssa_blkaddr;		\/* start block address of SSA area *\/$/;"	m	struct:f2fs_sm_info
start	f2fs.h	/^			block_t start;	\/* actual start address in dev *\/$/;"	m	struct:discard_cmd::__anon17::__anon18
start	f2fs.h	/^	block_t start;			\/* actual start address in dev *\/$/;"	m	struct:discard_info
start	file.c	/^	compat_u64 start;$/;"	m	struct:compat_f2fs_gc_range	file:
start_blk	f2fs.h	/^	block_t start_blk;$/;"	m	struct:f2fs_dev_info
start_blkaddr	f2fs.h	/^	block_t start_blkaddr;	\/* start blockaddr of current segment *\/$/;"	m	struct:discard_entry
start_blkaddr	f2fs.h	/^	unsigned int start_blkaddr;$/;"	m	struct:discard_range
start_idx_of_cluster	compress.c	/^static pgoff_t start_idx_of_cluster(struct compress_ctx *cc)$/;"	f	file:
start_segno	f2fs.h	/^	block_t start_segno;		\/*IFLBA: moved from free_i to here*\/$/;"	m	struct:f2fs_sm_info
start_segno	segment.h	/^	unsigned int start_segno;	\/* start segment number logically *\/$/;"	m	struct:free_segmap_info
start_segno	segment.h	/^	unsigned int start_segno;	\/* start segno of sits in set *\/$/;"	m	struct:sit_entry_set
start_sum_block	segment.h	/^static inline block_t start_sum_block(struct f2fs_sb_info *sbi)$/;"	f
stat	debug.c	/^DEFINE_SHOW_ATTRIBUTE(stat);$/;"	v
stat_add_compr_blocks	f2fs.h	3708;"	d
stat_add_compr_blocks	f2fs.h	3805;"	d
stat_dec_atomic_write	f2fs.h	3808;"	d
stat_dec_compr_inode	f2fs.h	3703;"	d
stat_dec_compr_inode	f2fs.h	3804;"	d
stat_dec_dirty_inode	f2fs.h	3663;"	d
stat_dec_dirty_inode	f2fs.h	3792;"	d
stat_dec_inline_dir	f2fs.h	3693;"	d
stat_dec_inline_dir	f2fs.h	3802;"	d
stat_dec_inline_inode	f2fs.h	3683;"	d
stat_dec_inline_inode	f2fs.h	3800;"	d
stat_dec_inline_xattr	f2fs.h	3673;"	d
stat_dec_inline_xattr	f2fs.h	3798;"	d
stat_dec_volatile_write	f2fs.h	3738;"	d
stat_dec_volatile_write	f2fs.h	3811;"	d
stat_inc_atomic_write	f2fs.h	3807;"	d
stat_inc_bg_cp_count	f2fs.h	3657;"	d
stat_inc_bg_cp_count	f2fs.h	3786;"	d
stat_inc_bggc_count	f2fs.h	3659;"	d
stat_inc_bggc_count	f2fs.h	3788;"	d
stat_inc_block_count	f2fs.h	3725;"	d
stat_inc_block_count	f2fs.h	3815;"	d
stat_inc_cached_node_hit	f2fs.h	3667;"	d
stat_inc_cached_node_hit	f2fs.h	3796;"	d
stat_inc_call_count	f2fs.h	3658;"	d
stat_inc_call_count	f2fs.h	3787;"	d
stat_inc_compr_inode	f2fs.h	3698;"	d
stat_inc_compr_inode	f2fs.h	3803;"	d
stat_inc_cp_count	f2fs.h	3656;"	d
stat_inc_cp_count	f2fs.h	3785;"	d
stat_inc_data_blk_count	f2fs.h	3763;"	d
stat_inc_data_blk_count	f2fs.h	3819;"	d
stat_inc_dirty_inode	f2fs.h	3662;"	d
stat_inc_dirty_inode	f2fs.h	3791;"	d
stat_inc_inline_dir	f2fs.h	3688;"	d
stat_inc_inline_dir	f2fs.h	3801;"	d
stat_inc_inline_inode	f2fs.h	3678;"	d
stat_inc_inline_inode	f2fs.h	3799;"	d
stat_inc_inline_xattr	f2fs.h	3668;"	d
stat_inc_inline_xattr	f2fs.h	3797;"	d
stat_inc_inplace_blocks	f2fs.h	3727;"	d
stat_inc_inplace_blocks	f2fs.h	3816;"	d
stat_inc_largest_node_hit	f2fs.h	3666;"	d
stat_inc_largest_node_hit	f2fs.h	3795;"	d
stat_inc_meta_count	f2fs.h	3712;"	d
stat_inc_meta_count	f2fs.h	3813;"	d
stat_inc_node_blk_count	f2fs.h	3771;"	d
stat_inc_node_blk_count	f2fs.h	3820;"	d
stat_inc_rbtree_node_hit	f2fs.h	3665;"	d
stat_inc_rbtree_node_hit	f2fs.h	3794;"	d
stat_inc_seg_count	f2fs.h	3747;"	d
stat_inc_seg_count	f2fs.h	3817;"	d
stat_inc_seg_type	f2fs.h	3723;"	d
stat_inc_seg_type	f2fs.h	3814;"	d
stat_inc_tot_blk_count	f2fs.h	3760;"	d
stat_inc_tot_blk_count	f2fs.h	3818;"	d
stat_inc_total_hit	f2fs.h	3664;"	d
stat_inc_total_hit	f2fs.h	3793;"	d
stat_inc_volatile_write	f2fs.h	3736;"	d
stat_inc_volatile_write	f2fs.h	3810;"	d
stat_info	f2fs.h	/^	struct f2fs_stat_info *stat_info;	\/* FS status information *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_stat_info
stat_io_skip_bggc_count	f2fs.h	3660;"	d
stat_io_skip_bggc_count	f2fs.h	3789;"	d
stat_list	f2fs.h	/^	struct list_head stat_list;$/;"	m	struct:f2fs_stat_info	typeref:struct:f2fs_stat_info::list_head
stat_lock	f2fs.h	/^	spinlock_t stat_lock;			\/* lock for stat operations *\/$/;"	m	struct:f2fs_sb_info
stat_other_skip_bggc_count	f2fs.h	3661;"	d
stat_other_skip_bggc_count	f2fs.h	3790;"	d
stat_show	debug.c	/^static int stat_show(struct seq_file *s, void *v)$/;"	f	file:
stat_sub_compr_blocks	f2fs.h	3710;"	d
stat_sub_compr_blocks	f2fs.h	3806;"	d
stat_update_max_atomic_write	f2fs.h	3729;"	d
stat_update_max_atomic_write	f2fs.h	3809;"	d
stat_update_max_volatile_write	f2fs.h	3740;"	d
stat_update_max_volatile_write	f2fs.h	3812;"	d
state	f2fs.h	/^	unsigned char state;		\/* state *\/$/;"	m	struct:discard_cmd
state	node.h	/^	int state;		\/* in use or not: FREE_NID or PREALLOC_NID *\/$/;"	m	struct:free_nid
store	sysfs.c	/^	ssize_t (*store)(struct f2fs_attr *, struct f2fs_sb_info *,$/;"	m	struct:f2fs_attr	file:
str2hashbuf	hash.c	/^static void str2hashbuf(const unsigned char *msg, size_t len,$/;"	f	file:
struct_type	sysfs.c	/^	int struct_type;$/;"	m	struct:f2fs_attr	file:
submit_flush_wait	segment.c	/^static int submit_flush_wait(struct f2fs_sb_info *sbi, nid_t ino)$/;"	f	file:
submitted	f2fs.h	/^	bool submitted;		\/* indicate IO submission *\/$/;"	m	struct:f2fs_io_info
sum_blk	segment.h	/^	struct f2fs_summary_block *sum_blk;	\/* cached summary block *\/$/;"	m	struct:curseg_info	typeref:struct:curseg_info::f2fs_summary_block
sum_blk_addr	segment.h	/^static inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)$/;"	f
sync	f2fs.h	/^	bool sync;			\/* submit discard with REQ_SYNC flag *\/$/;"	m	struct:discard_policy
sync	file.c	/^	u32 sync;$/;"	m	struct:compat_f2fs_gc_range	file:
task	f2fs.h	/^	struct task_struct *task;	\/* lookup and create consistency *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::task_struct
temp	f2fs.h	/^	enum temp_type temp;	\/* contains HOT\/WARM\/COLD *\/$/;"	m	struct:f2fs_io_info	typeref:enum:f2fs_io_info::temp_type
temp_type	f2fs.h	/^enum temp_type {$/;"	g
test_opt	f2fs.h	104;"	d
time_to_inject	f2fs.h	/^static inline bool time_to_inject(struct f2fs_sb_info *sbi, int type)$/;"	f
timeout	f2fs.h	/^	bool timeout;			\/* discard timeout for put_super *\/$/;"	m	struct:discard_policy
tmp_map	segment.h	/^	unsigned long *tmp_map;			\/* bitmap for temporal use *\/$/;"	m	struct:sit_info
tot_blks	f2fs.h	/^	int tot_blks, data_blks, node_blks;$/;"	m	struct:f2fs_stat_info
tot_segs	f2fs.h	/^	int tot_segs, node_segs, data_segs, free_segs, free_secs;$/;"	m	struct:f2fs_stat_info
total_count	f2fs.h	/^	int total_count, utilization;$/;"	m	struct:f2fs_stat_info
total_ext	f2fs.h	/^	unsigned long long hit_total, total_ext;$/;"	m	struct:f2fs_stat_info
total_ext_node	f2fs.h	/^	atomic_t total_ext_node;		\/* extent info count *\/$/;"	m	struct:f2fs_sb_info
total_ext_tree	f2fs.h	/^	atomic_t total_ext_tree;		\/* extent tree count *\/$/;"	m	struct:f2fs_sb_info
total_hit_ext	f2fs.h	/^	atomic64_t total_hit_ext;		\/* # of lookup extent cache *\/$/;"	m	struct:f2fs_sb_info
total_node_count	f2fs.h	/^	unsigned int total_node_count;		\/* total node block count *\/$/;"	m	struct:f2fs_sb_info
total_sections	f2fs.h	/^	unsigned int total_sections;		\/* total section count *\/$/;"	m	struct:f2fs_sb_info
total_segments	f2fs.h	/^	unsigned int total_segments;$/;"	m	struct:f2fs_dev_info
total_valid_block_count	f2fs.h	/^	block_t total_valid_block_count;	\/* # of valid blocks *\/$/;"	m	struct:f2fs_sb_info
total_valid_inode_count	f2fs.h	/^	struct percpu_counter total_valid_inode_count;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::percpu_counter
total_valid_node_count	f2fs.h	/^	unsigned int total_valid_node_count;	\/* valid node block count *\/$/;"	m	struct:f2fs_sb_info
total_zombie_tree	f2fs.h	/^	atomic_t total_zombie_tree;		\/* extent zombie tree count *\/$/;"	m	struct:f2fs_sb_info
tpages	f2fs.h	/^	struct page **tpages;		\/* temp pages to pad holes in cluster *\/$/;"	m	struct:decompress_io_ctx	typeref:struct:decompress_io_ctx::page
trim_end	f2fs.h	/^	__u64 trim_end;$/;"	m	struct:cp_control
trim_minlen	f2fs.h	/^	__u64 trim_minlen;$/;"	m	struct:cp_control
trim_sections	f2fs.h	/^	unsigned int trim_sections;		\/* # of sections to trim *\/$/;"	m	struct:f2fs_sm_info
trim_start	f2fs.h	/^	__u64 trim_start;$/;"	m	struct:cp_control
truncate_dnode	node.c	/^static int truncate_dnode(struct dnode_of_data *dn)$/;"	f	file:
truncate_node	node.c	/^static int truncate_node(struct dnode_of_data *dn)$/;"	f	file:
truncate_nodes	node.c	/^static int truncate_nodes(struct dnode_of_data *dn, unsigned int nofs,$/;"	f	file:
truncate_partial_data_page	file.c	/^static int truncate_partial_data_page(struct inode *inode, u64 from,$/;"	f	file:
truncate_partial_nodes	node.c	/^static int truncate_partial_nodes(struct dnode_of_data *dn,$/;"	f	file:
try_to_fix_pino	file.c	/^static void try_to_fix_pino(struct inode *inode)$/;"	f	file:
type	f2fs.h	/^	enum page_type type;	\/* contains DATA\/NODE\/META\/META_FLUSH *\/$/;"	m	struct:f2fs_io_info	typeref:enum:f2fs_io_info::page_type
type	f2fs.h	/^	int type;			\/* type of discard *\/$/;"	m	struct:discard_policy
type	segment.h	/^	unsigned int type:6;		\/* segment type like CURSEG_XXX_TYPE *\/$/;"	m	struct:seg_entry
type	trace.h	/^	enum file_type type;$/;"	m	struct:last_io_info	typeref:enum:last_io_info::file_type
umount_mutex	f2fs.h	/^	struct mutex umount_mutex;$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::mutex
unblock_operations	checkpoint.c	/^static void unblock_operations(struct f2fs_sb_info *sbi)$/;"	f	file:
undiscard_blks	f2fs.h	/^	unsigned int undiscard_blks;		\/* # of undiscard blocks *\/$/;"	m	struct:discard_cmd_control
undiscard_blks	f2fs.h	/^	unsigned int undiscard_blks;$/;"	m	struct:f2fs_stat_info
unusable	sysfs.c	/^F2FS_GENERAL_RO_ATTR(unusable);$/;"	v
unusable_block_count	f2fs.h	/^	block_t unusable_block_count;		\/* # of blocks saved by last cp *\/$/;"	m	struct:f2fs_sb_info
unusable_cap	f2fs.h	/^	block_t unusable_cap;		\/* Amount of space allowed to be$/;"	m	struct:f2fs_mount_info
unusable_cap_perc	f2fs.h	/^	block_t unusable_cap_perc;	\/* percentage for cap *\/$/;"	m	struct:f2fs_mount_info
unusable_show	sysfs.c	/^static ssize_t unusable_show(struct f2fs_attr *a,$/;"	f	file:
update	f2fs.h	/^	int inline_xattr, inline_inode, inline_dir, append, update, orphans;$/;"	m	struct:f2fs_stat_info
update_ckpt_flags	checkpoint.c	/^static void update_ckpt_flags(struct f2fs_sb_info *sbi, struct cp_control *cpc)$/;"	f	file:
update_device_state	segment.c	/^static void update_device_state(struct f2fs_io_info *fio)$/;"	f	file:
update_dirty_dynamic_discard_map	segment.c	/^static int update_dirty_dynamic_discard_map(struct f2fs_sb_info *sbi, int *discard_limit)$/;"	f	file:
update_discard_range_entry	segment.c	/^static void update_discard_range_entry(struct discard_range_entry *dre, unsigned int target_idx, $/;"	f	file:
update_dynamic_discard_map	segment.c	/^static void update_dynamic_discard_map(struct f2fs_sb_info *sbi, unsigned int segno,$/;"	f	file:
update_free_nid_bitmap	node.c	/^static void update_free_nid_bitmap(struct f2fs_sb_info *sbi, nid_t nid,$/;"	f	file:
update_fs_metadata	gc.c	/^static void update_fs_metadata(struct f2fs_sb_info *sbi, int secs)$/;"	f	file:
update_general_status	debug.c	/^static void update_general_status(struct f2fs_sb_info *sbi)$/;"	f	file:
update_mem_info	debug.c	/^static void update_mem_info(struct f2fs_sb_info *sbi)$/;"	f	file:
update_nats_in_cursum	f2fs.h	/^static inline int update_nats_in_cursum(struct f2fs_journal *journal, int i)$/;"	f
update_sb_metadata	gc.c	/^static void update_sb_metadata(struct f2fs_sb_info *sbi, int secs)$/;"	f	file:
update_segment_mtime	segment.c	/^static void update_segment_mtime(struct f2fs_sb_info *sbi, block_t blkaddr,$/;"	f	file:
update_sit_entry	segment.c	/^static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)$/;"	f	file:
update_sits_in_cursum	f2fs.h	/^static inline int update_sits_in_cursum(struct f2fs_journal *journal, int i)$/;"	f
urgent_sleep_time	gc.h	/^	unsigned int urgent_sleep_time;$/;"	m	struct:f2fs_gc_kthread
user_block_count	f2fs.h	/^	block_t user_block_count;		\/* # of user blocks *\/$/;"	m	struct:f2fs_sb_info
usr_fname	f2fs.h	/^	const struct qstr *usr_fname;$/;"	m	struct:f2fs_filename	typeref:struct:f2fs_filename::qstr
util_free	f2fs.h	/^	int util_free, util_valid, util_invalid;$/;"	m	struct:f2fs_stat_info
util_invalid	f2fs.h	/^	int util_free, util_valid, util_invalid;$/;"	m	struct:f2fs_stat_info
util_valid	f2fs.h	/^	int util_free, util_valid, util_invalid;$/;"	m	struct:f2fs_stat_info
utilization	f2fs.h	/^	int total_count, utilization;$/;"	m	struct:f2fs_stat_info
utilization	segment.h	/^static inline int utilization(struct f2fs_sb_info *sbi)$/;"	f
uuid_is_nonzero	file.c	/^static bool uuid_is_nonzero(__u8 u[16])$/;"	f	file:
v_ops	segment.h	/^	const struct victim_selection *v_ops;	\/* victim selction operation *\/$/;"	m	struct:dirty_seglist_info	typeref:struct:dirty_seglist_info::victim_selection
valid_blks	f2fs.h	/^	unsigned int valid_blks[NR_CURSEG_TYPE];$/;"	m	struct:f2fs_stat_info
valid_blocks	segment.h	/^	unsigned int valid_blocks:10;	\/* # of valid blocks *\/$/;"	m	struct:seg_entry
valid_blocks	segment.h	/^	unsigned int valid_blocks;	\/* # of valid blocks in a section *\/$/;"	m	struct:sec_entry
valid_count	f2fs.h	/^	unsigned int valid_count, valid_node_count, valid_inode_count, discard_blks;$/;"	m	struct:f2fs_stat_info
valid_inode_count	f2fs.h	/^	unsigned int valid_count, valid_node_count, valid_inode_count, discard_blks;$/;"	m	struct:f2fs_stat_info
valid_inode_count	f2fs.h	/^static inline s64 valid_inode_count(struct f2fs_sb_info *sbi)$/;"	f
valid_node_count	f2fs.h	/^	unsigned int valid_count, valid_node_count, valid_inode_count, discard_blks;$/;"	m	struct:f2fs_stat_info
valid_node_count	f2fs.h	/^static inline unsigned int valid_node_count(struct f2fs_sb_info *sbi)$/;"	f
valid_super_block	f2fs.h	/^	int valid_super_block;			\/* valid super block no *\/$/;"	m	struct:f2fs_sb_info
valid_user_blocks	f2fs.h	/^static inline block_t valid_user_blocks(struct f2fs_sb_info *sbi)$/;"	f
validate_checkpoint	checkpoint.c	/^static struct page *validate_checkpoint(struct f2fs_sb_info *sbi,$/;"	f	file:
ver_after	f2fs.h	106;"	d
verify_blkaddr	f2fs.h	/^static inline void verify_blkaddr(struct f2fs_sb_info *sbi,$/;"	f
verify_fio_blkaddr	segment.h	/^static inline void verify_fio_blkaddr(struct f2fs_io_info *fio)$/;"	f
verity_pages	f2fs.h	/^	atomic_t verity_pages;		\/* in-flight page count for verity *\/$/;"	m	struct:decompress_io_ctx
version	f2fs.h	/^	unsigned char version;		\/* version of the node *\/$/;"	m	struct:f2fs_io_info
version	node.h	/^	unsigned char version;	\/* version of the node *\/$/;"	m	struct:node_info
version	super.c	/^	char *version;$/;"	m	struct:f2fs_sb_encodings	file:
version	verity.c	/^	__le32 version;$/;"	m	struct:fsverity_descriptor_location	file:
vfs_inode	f2fs.h	/^	struct inode vfs_inode;		\/* serve a vfs inode *\/$/;"	m	struct:f2fs_inode_info	typeref:struct:f2fs_inode_info::inode
vi	gc.h	/^		struct victim_info vi;	\/* victim info *\/$/;"	m	union:victim_entry::__anon3	typeref:struct:victim_entry::__anon3::victim_info
victim_bits_seq_show	sysfs.c	/^static int __maybe_unused victim_bits_seq_show(struct seq_file *seq,$/;"	f	file:
victim_count	f2fs.h	/^	unsigned int victim_count;		\/* victim count in rb-tree *\/$/;"	m	struct:atgc_management
victim_entry	gc.h	/^struct victim_entry {$/;"	s
victim_entry_slab	gc.c	/^static struct kmem_cache *victim_entry_slab;$/;"	v	typeref:struct:kmem_cache	file:
victim_info	gc.h	/^struct victim_info {$/;"	s
victim_list	f2fs.h	/^	struct list_head victim_list;		\/* linked with all victim entries *\/$/;"	m	struct:atgc_management	typeref:struct:atgc_management::list_head
victim_secmap	segment.h	/^	unsigned long *victim_secmap;		\/* background GC victims *\/$/;"	m	struct:dirty_seglist_info
victim_sel_policy	segment.h	/^struct victim_sel_policy {$/;"	s
victim_selection	segment.h	/^struct victim_selection {$/;"	s
vw_cnt	f2fs.h	/^	atomic_t vw_cnt;			\/* # of volatile writes *\/$/;"	m	struct:f2fs_sb_info
vw_cnt	f2fs.h	/^	int aw_cnt, max_aw_cnt, vw_cnt, max_vw_cnt;$/;"	m	struct:f2fs_stat_info
wait	f2fs.h	/^	struct completion wait;		\/* compleation *\/$/;"	m	struct:discard_cmd	typeref:struct:discard_cmd::completion
wait	f2fs.h	/^	struct completion wait;$/;"	m	struct:flush_cmd	typeref:struct:flush_cmd::completion
wait_list	f2fs.h	/^	struct list_head wait_list;		\/* store on-flushing entries *\/$/;"	m	struct:discard_cmd_control	typeref:struct:discard_cmd_control::list_head
wake_up_discard_thread	segment.h	/^static inline void wake_up_discard_thread(struct f2fs_sb_info *sbi, bool force)$/;"	f
wb_sync_req	f2fs.h	/^	atomic_t wb_sync_req[META];	\/* count # of WB_SYNC threads *\/$/;"	m	struct:f2fs_sb_info
whint_mode	f2fs.h	/^	int whint_mode;$/;"	m	struct:f2fs_mount_info
work	data.c	/^	struct work_struct work;$/;"	m	struct:bio_post_read_ctx	typeref:struct:bio_post_read_ctx::work_struct	file:
write	f2fs.h	/^	bool write;$/;"	m	struct:f2fs_private_dio
write_all_xattrs	xattr.c	/^static inline int write_all_xattrs(struct inode *inode, __u32 hsize,$/;"	f	file:
write_compacted_summaries	segment.c	/^static void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)$/;"	f	file:
write_current_sum_page	segment.c	/^static void write_current_sum_page(struct f2fs_sb_info *sbi,$/;"	f	file:
write_discard_bitmap_journals	segment.c	/^static block_t write_discard_bitmap_journals(struct f2fs_sb_info *sbi, block_t *blk)$/;"	f	file:
write_discard_range_journals	segment.c	/^static block_t write_discard_range_journals(struct f2fs_sb_info *sbi, block_t *blk)$/;"	f	file:
write_io	f2fs.h	/^	struct f2fs_bio_info *write_io[NR_PAGE_TYPE];	\/* for write bios *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::f2fs_bio_info
write_io_dummy	f2fs.h	/^	mempool_t *write_io_dummy;		\/* Dummy pages *\/$/;"	m	struct:f2fs_sb_info
write_io_size_bits	f2fs.h	/^	int write_io_size_bits;		\/* Write IO size bits *\/$/;"	m	struct:f2fs_mount_info
write_normal_summaries	segment.c	/^static void write_normal_summaries(struct f2fs_sb_info *sbi,$/;"	f	file:
write_orphan_inodes	checkpoint.c	/^static void write_orphan_inodes(struct f2fs_sb_info *sbi, block_t start_blk)$/;"	f	file:
write_sum_page	segment.c	/^static void write_sum_page(struct f2fs_sb_info *sbi,$/;"	f	file:
writepages	f2fs.h	/^	struct mutex writepages;		\/* mutex for writepages() *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::mutex
written_block_count	segment.h	/^static inline block_t written_block_count(struct f2fs_sb_info *sbi)$/;"	f
written_valid_blocks	segment.h	/^	block_t written_valid_blocks;	\/* # of valid blocks in main area *\/$/;"	m	struct:sit_info
xattr_alloc	xattr.c	/^static void *xattr_alloc(struct f2fs_sb_info *sbi, int size, bool *is_inline)$/;"	f	file:
xattr_free	xattr.c	/^static void xattr_free(struct f2fs_sb_info *sbi, void *xattr_addr,$/;"	f	file:
xflag	file.c	/^	u32 xflag;$/;"	m	struct:__anon2	file:
zombie_list	f2fs.h	/^	struct list_head zombie_list;		\/* extent zombie tree list *\/$/;"	m	struct:f2fs_sb_info	typeref:struct:f2fs_sb_info::list_head
zombie_tree	f2fs.h	/^	int ext_tree, zombie_tree, ext_node;$/;"	m	struct:f2fs_stat_info
zone	segment.h	/^	unsigned int zone;			\/* current zone number *\/$/;"	m	struct:curseg_info
zone_cap_mismatch	super.c	/^	bool zone_cap_mismatch;$/;"	m	struct:f2fs_report_zones_args	file:
zone_capacity_blocks	f2fs.h	/^	block_t *zone_capacity_blocks;  \/* Array of zone capacity in blks *\/$/;"	m	struct:f2fs_dev_info
zstd_compress_pages	compress.c	/^static int zstd_compress_pages(struct compress_ctx *cc)$/;"	f	file:
zstd_decompress_pages	compress.c	/^static int zstd_decompress_pages(struct decompress_io_ctx *dic)$/;"	f	file:
zstd_destroy_compress_ctx	compress.c	/^static void zstd_destroy_compress_ctx(struct compress_ctx *cc)$/;"	f	file:
zstd_destroy_decompress_ctx	compress.c	/^static void zstd_destroy_decompress_ctx(struct decompress_io_ctx *dic)$/;"	f	file:
zstd_init_compress_ctx	compress.c	/^static int zstd_init_compress_ctx(struct compress_ctx *cc)$/;"	f	file:
zstd_init_decompress_ctx	compress.c	/^static int zstd_init_decompress_ctx(struct decompress_io_ctx *dic)$/;"	f	file:
